!WRF:MEDIATION_LAYER:PHYSICS					!WRF:MEDIATION_LAYER:PHYSICS
!								!
MODULE module_radiation_driver					MODULE module_radiation_driver
CONTAINS							CONTAINS
!BOP								!BOP
! !IROUTINE: radiation_driver - interface to radiation physic	! !IROUTINE: radiation_driver - interface to radiation physic

! !INTERFACE:							! !INTERFACE:
   SUBROUTINE radiation_driver (                             	   SUBROUTINE radiation_driver (                             
               ACFRCV ,ACFRST ,ALBEDO  &			               ACFRCV ,ACFRST ,ALBEDO  &
              ,CFRACH ,CFRACL ,CFRACM  &			              ,CFRACH ,CFRACL ,CFRACM  &
              ,CUPPT  ,CZMEAN ,DT      &			              ,CUPPT  ,CZMEAN ,DT      &
              ,DZ8W   ,EMISS  ,GLW     &			              ,DZ8W   ,EMISS  ,GLW     &
              ,GMT    ,GSW    ,HBOT    &			              ,GMT    ,GSW    ,HBOT    &
              ,HTOP   ,HBOTR  ,HTOPR   &			              ,HTOP   ,HBOTR  ,HTOPR   &
              ,ICLOUD                  &			              ,ICLOUD                  &
              ,ITIMESTEP,JULDAY, JULIAN &			              ,ITIMESTEP,JULDAY, JULIAN &
              ,JULYR  ,LW_PHYSICS       &			              ,JULYR  ,LW_PHYSICS       &
              ,NCFRCV ,NCFRST ,NPHS     &			              ,NCFRCV ,NCFRST ,NPHS     &
              ,O3INPUT, O3RAD           &			              ,O3INPUT, O3RAD           &
              ,AER_OPT, aerod           &			              ,AER_OPT, aerod           &
              ,swint_opt                &			              ,swint_opt                &
              ,P8W    ,P ,PI            &			              ,P8W    ,P ,PI            &
							      >	              ,p_top                    &
              ,RADT   ,RA_CALL_OFFSET   &			              ,RADT   ,RA_CALL_OFFSET   &
              ,RHO    ,RLWTOA           &			              ,RHO    ,RLWTOA           &
              ,RSWTOA ,RTHRATEN         &			              ,RSWTOA ,RTHRATEN         &
              ,RTHRATENLW      ,RTHRATENSW    &			              ,RTHRATENLW      ,RTHRATENSW    &
              ,SNOW   ,STEPRA ,SWDOWN  &			              ,SNOW   ,STEPRA ,SWDOWN  &
              ,SWDOWNC ,SW_PHYSICS     &			              ,SWDOWNC ,SW_PHYSICS     &
              ,T8W     ,T ,TAUCLDC &				              ,T8W     ,T ,TAUCLDC &
              ,TAUCLDI ,TSK ,VEGFRA  &				              ,TAUCLDI ,TSK ,VEGFRA  &
              ,WARM_RAIN ,XICE ,XLAND   &			              ,WARM_RAIN ,XICE ,XLAND   &
              ,XLAT ,XLONG ,YR          &			              ,XLAT ,XLONG ,YR          &
!Optional solar variables					!Optional solar variables
              ,DECLINX ,SOLCONX ,COSZEN ,HRANG    &		              ,DECLINX ,SOLCONX ,COSZEN ,HRANG    &
              , CEN_LAT                                      	              , CEN_LAT                                      
              ,Z                                             	              ,Z                                             
              ,ALEVSIZ, no_src_types               &		              ,ALEVSIZ, no_src_types               &
              ,LEVSIZ, N_OZMIXM                    &		              ,LEVSIZ, N_OZMIXM                    &
              ,N_AEROSOLC                                    	              ,N_AEROSOLC                                    
              ,PAERLEV   ,ID                                 	              ,PAERLEV   ,ID                                 
              ,CAM_ABS_DIM1, CAM_ABS_DIM2 &			              ,CAM_ABS_DIM1, CAM_ABS_DIM2 &
              ,CAM_ABS_FREQ_S                         &		              ,CAM_ABS_FREQ_S                         &
              ,XTIME                                         	              ,XTIME                                         
              ,CURR_SECS, ADAPT_STEP_FLAG       &		              ,CURR_SECS, ADAPT_STEP_FLAG       &
              !BSINGH - For WRFCuP scheme		      <
              ,cu_physics,shallowcu_forced_ra   & !CuP, wig 1 <
              ,cubot,cutop,cupflag,cldfra_cup   & !CuP, wig 1 <
              ,shall                            & !CuP, wig 4 <
              ,qc_ic_cup,qndrop_ic_cup          & !CuP, rce 1 <
              !BSINGH - ENDS				      <
            ! indexes						            ! indexes
              ,IDS,IDE, JDS,JDE, KDS,KDE          &		              ,IDS,IDE, JDS,JDE, KDS,KDE          &
              ,IMS,IME, JMS,JME, KMS,KME          &		              ,IMS,IME, JMS,JME, KMS,KME          &
              ,i_start,i_end          &				              ,i_start,i_end          &
              ,j_start,j_end          &				              ,j_start,j_end          &
              ,kts, kte                          &		              ,kts, kte                          &
              ,num_tiles                                   &	              ,num_tiles                                   &
            ! Optional						            ! Optional
              , TLWDN, TLWUP                        & ! godda	              , TLWDN, TLWUP                        & ! godda
              , SLWDN, SLWUP                        & ! godda	              , SLWDN, SLWUP                        & ! godda
              , TSWDN, TSWUP                        & ! godda	              , TSWDN, TSWUP                        & ! godda
              , SSWDN, SSWUP                        & ! godda	              , SSWDN, SSWUP                        & ! godda
              , CLDFRA,CLDFRA_MP_ALL,lradius,iradius          |	              , CLDFRA,CLDFRA_MP_ALL,CLDT,ZNU       &
!lm							      |	#if (EM_CORE == 1)
							      >	              , lradius,iradius                     &
							      >	#endif
              , cldfra_dp, cldfra_sh                & ! ckay 	              , cldfra_dp, cldfra_sh                & ! ckay 
              , ICLOUD_CU                           &	      <
              , QC_CU , QI_CU                       &	      <
!lm							      <
              , re_cloud, re_ice, re_snow           & ! G. Th	              , re_cloud, re_ice, re_snow           & ! G. Th
              , has_reqc, has_reqi, has_reqs        & ! G. Th	              , has_reqc, has_reqi, has_reqs        & ! G. Th
              , PB                                           	              , PB                                           
              , F_ICE_PHY,F_RAIN_PHY       &			              , F_ICE_PHY,F_RAIN_PHY       &
              , QV, F_QV                     &			              , QV, F_QV                     &
              , QC, F_QC                     &			              , QC, F_QC                     &
              , QR, F_QR                     &			              , QR, F_QR                     &
              , QI, F_QI                     &			              , QI, F_QI                     &
              , QS, F_QS                     &			              , QS, F_QS                     &
              , QG, F_QG                     &			              , QG, F_QG                     &
              , QNDROP, F_QNDROP    &				              , QNDROP, F_QNDROP    &
              ,ACSWUPT   ,ACSWUPTC            &			              ,ACSWUPT   ,ACSWUPTC            &
              ,ACSWDNT   ,ACSWDNTC            &			              ,ACSWDNT   ,ACSWDNTC            &
              ,ACSWUPB   ,ACSWUPBC            &			              ,ACSWUPB   ,ACSWUPBC            &
              ,ACSWDNB   ,ACSWDNBC            &			              ,ACSWDNB   ,ACSWDNBC            &
              ,ACLWUPT   ,ACLWUPTC            &			              ,ACLWUPT   ,ACLWUPTC            &
              ,ACLWDNT   ,ACLWDNTC            &			              ,ACLWDNT   ,ACLWDNTC            &
              ,ACLWUPB   ,ACLWUPBC            &			              ,ACLWUPB   ,ACLWUPBC            &
              ,ACLWDNB   ,ACLWDNBC            &			              ,ACLWDNB   ,ACLWDNBC            &
              ,SWUPT ,SWUPTC                  &			              ,SWUPT ,SWUPTC                  &
              ,SWDNT ,SWDNTC                  &			              ,SWDNT ,SWDNTC                  &
              ,SWUPB ,SWUPBC                  &			              ,SWUPB ,SWUPBC                  &
              ,SWDNB ,SWDNBC                  &			              ,SWDNB ,SWDNBC                  &
              ,LWUPT ,LWUPTC                  &			              ,LWUPT ,LWUPTC                  &
              ,LWDNT ,LWDNTC                  &			              ,LWDNT ,LWDNTC                  &
              ,LWUPB ,LWUPBC                  &			              ,LWUPB ,LWUPBC                  &
              ,LWDNB ,LWDNBC                  &			              ,LWDNB ,LWDNBC                  &
              ,LWCF                           &			              ,LWCF                           &
              ,SWCF                           &			              ,SWCF                           &
              ,OLR                            &			              ,OLR                            &
              ,aerodm, PINA, aodtot           &			              ,aerodm, PINA, aodtot           &
              ,OZMIXM, PIN                    &			              ,OZMIXM, PIN                    &
              ,M_PS_1, M_PS_2, AEROSOLC_1     &			              ,M_PS_1, M_PS_2, AEROSOLC_1     &
              ,AEROSOLC_2, M_HYBI0            &			              ,AEROSOLC_2, M_HYBI0            &
              ,ABSTOT, ABSNXT, EMSTOT         &			              ,ABSTOT, ABSNXT, EMSTOT         &
              ,CU_RAD_FEEDBACK                &		      |	              ,ICLOUD_CU                      &
              ,AER_RA_FEEDBACK                &			              ,AER_RA_FEEDBACK                &
              ,QC_ADJUST , QI_ADJUST          &		      |	              ,QC_CU , QI_CU                  &
              ,PM2_5_DRY, PM2_5_WATER         &			              ,PM2_5_DRY, PM2_5_WATER         &
              ,PM2_5_DRY_EC                   &			              ,PM2_5_DRY_EC                   &
              ,TAUAER300, TAUAER400 & ! jcb			              ,TAUAER300, TAUAER400 & ! jcb
              ,TAUAER600, TAUAER999 & ! jcb			              ,TAUAER600, TAUAER999 & ! jcb
              ,GAER300, GAER400, GAER600, GAER999 & ! jcb	              ,GAER300, GAER400, GAER600, GAER999 & ! jcb
              ,WAER300, WAER400, WAER600, WAER999 & ! jcb	              ,WAER300, WAER400, WAER600, WAER999 & ! jcb
              ,TAUAERlw1,  TAUAERlw2  &				              ,TAUAERlw1,  TAUAERlw2  &
              ,TAUAERlw3,  TAUAERlw4  &				              ,TAUAERlw3,  TAUAERlw4  &
              ,TAUAERlw5,  TAUAERlw6  &				              ,TAUAERlw5,  TAUAERlw6  &
              ,TAUAERlw7,  TAUAERlw8  &				              ,TAUAERlw7,  TAUAERlw8  &
              ,TAUAERlw9,  TAUAERlw10   &			              ,TAUAERlw9,  TAUAERlw10   &
              ,TAUAERlw11, TAUAERlw12   &			              ,TAUAERlw11, TAUAERlw12   &
              ,TAUAERlw13, TAUAERlw14   &			              ,TAUAERlw13, TAUAERlw14   &
              ,TAUAERlw15, TAUAERlw16  &			              ,TAUAERlw15, TAUAERlw16  &
              ,progn                                         	              ,progn                                         
              ,slope_rad,topo_shading     &			              ,slope_rad,topo_shading     &
              ,shadowmask,ht,dx,dy                 &		              ,shadowmask,ht,dx,dy                 &
							      >	              ,dxkm                                          
							      >	              ,diffuse_frac               &
              ,SWUPFLX,SWUPFLXC,SWDNFLX,SWDNFLXC             	              ,SWUPFLX,SWUPFLXC,SWDNFLX,SWDNFLXC             
              ,LWUPFLX,LWUPFLXC,LWDNFLX,LWDNFLXC             	              ,LWUPFLX,LWUPFLXC,LWDNFLX,LWDNFLXC             
              ,radtacttime                                   	              ,radtacttime                                   
              ,ALSWVISDIR, ALSWVISDIF, ALSWNIRDIR, ALSWNIRDIF	              ,ALSWVISDIR, ALSWVISDIF, ALSWNIRDIR, ALSWNIRDIF
              ,SWVISDIR, SWVISDIF, SWNIRDIR, SWNIRDIF        	              ,SWVISDIR, SWVISDIF, SWNIRDIR, SWNIRDIF        
              ,SF_SURFACE_PHYSICS, IS_CAMMGMP_USED           	              ,SF_SURFACE_PHYSICS, IS_CAMMGMP_USED           
              ,EXPLICIT_CONVECTION                           	              ,EXPLICIT_CONVECTION                           
              ,swddir,swddni,swddif                           |	              ,swddir,swddni,swddif                          
              ,swdown_ref,swddir_ref,coszen_ref,Gx,gg,Bx,bb   |	              ,swdown_ref,swddir_ref,coszen_ref,Gx,gg,Bx,bb  
							      >	              ,aer_type                                      
							      >	              ,aer_aod550_opt, aer_aod550_val                
							      >	              ,aer_angexp_opt, aer_angexp_val                
							      >	              ,aer_ssa_opt, aer_ssa_val                      
							      >	              ,aer_asy_opt, aer_asy_val                      
							      >	              ,aod5502d, angexp2d, aerssa2d, aerasy2d        
							      >	              ,aod5503d                                      
                                                             	                                                             


!------------------------------------------------------------	!------------------------------------------------------------

! !USES:							! !USES:
   USE module_state_description, ONLY : RRTMSCHEME, GFDLLWSCH	   USE module_state_description, ONLY : RRTMSCHEME, GFDLLWSCH
                                       ,RRTMG_LWSCHEME, RRTMG	                                       ,RRTMG_LWSCHEME, RRTMG
							      >	                                       ,RRTMG_LWSCHEME_FAST, 
                                       ,SWRADSCHEME, GSFCSWSC	                                       ,SWRADSCHEME, GSFCSWSC
                                       ,GFDLSWSCHEME, CAMLWSC	                                       ,GFDLSWSCHEME, CAMLWSC
                                       ,HELDSUAREZ           	                                       ,HELDSUAREZ           
#ifdef HWRF							#ifdef HWRF
                                       ,HWRFSWSCHEME, HWRFLWS	                                       ,HWRFSWSCHEME, HWRFLWS
#endif								#endif
                                       ,goddardlwscheme      	                                       ,goddardlwscheme      
                                       ,goddardswscheme, CAMM |	                                       ,goddardswscheme      
# if (EM_CORE == 1)						# if (EM_CORE == 1)
                                       ,CAMMGMPSCHEME        	                                       ,CAMMGMPSCHEME        
# endif								# endif
                                       ,FLGLWSCHEME, FLGSWSCH |	                                       ,FLGLWSCHEME, FLGSWSCH
                                       ,KFCUPSCHEME           <

   USE module_model_constants					   USE module_model_constants
#ifndef HWRF							#ifndef HWRF
   USE module_wrf_error , ONLY : wrf_err_message		   USE module_wrf_error , ONLY : wrf_err_message
#endif								#endif

! *** add new modules of schemes here				! *** add new modules of schemes here

   USE module_ra_sw         , ONLY : swrad			   USE module_ra_sw         , ONLY : swrad
   USE module_ra_gsfcsw     , ONLY : gsfcswrad			   USE module_ra_gsfcsw     , ONLY : gsfcswrad
   USE module_ra_rrtm       , ONLY : rrtmlwrad			   USE module_ra_rrtm       , ONLY : rrtmlwrad
   USE module_ra_rrtmg_lw   , ONLY : rrtmg_lwrad		   USE module_ra_rrtmg_lw   , ONLY : rrtmg_lwrad
   USE module_ra_rrtmg_sw   , ONLY : rrtmg_swrad		   USE module_ra_rrtmg_sw   , ONLY : rrtmg_swrad
							      >	   USE module_ra_rrtmg_lwf  , ONLY : rrtmg_lwrad_fast
							      >	   USE module_ra_rrtmg_swf  , ONLY : rrtmg_swrad_fast
   USE module_ra_cam        , ONLY : camrad			   USE module_ra_cam        , ONLY : camrad
   USE module_ra_gfdleta    , ONLY : etara			   USE module_ra_gfdleta    , ONLY : etara
#ifdef HWRF							#ifdef HWRF
   USE module_ra_hwrf						   USE module_ra_hwrf
#endif								#endif
   USE module_ra_hs         , ONLY : hsrad			   USE module_ra_hs         , ONLY : hsrad

   USE module_ra_goddard    , ONLY : goddardrad			   USE module_ra_goddard    , ONLY : goddardrad
   USE module_ra_flg        , ONLY : RAD_FLG			   USE module_ra_flg        , ONLY : RAD_FLG

							      >	   USE module_ra_aerosol    , ONLY : calc_aerosol_goddard_sw,
							      >	                                     calc_aerosol_rrtmg_sw
							      >
   !  This driver calls subroutines for the radiation paramet	   !  This driver calls subroutines for the radiation paramet
   !								   !
   !  short wave radiation choices:				   !  short wave radiation choices:
   !  1. swrad (19??)						   !  1. swrad (19??)
   !  4. rrtmg_sw - Added November 2008, MJIacono, AER, Inc.	   !  4. rrtmg_sw - Added November 2008, MJIacono, AER, Inc.
   !								   !
   !  long wave radiation choices:				   !  long wave radiation choices:
   !  1. rrtmlwrad						   !  1. rrtmlwrad
   !  4. rrtmg_lw - Added November 2008, MJIacono, AER, Inc.	   !  4. rrtmg_lw - Added November 2008, MJIacono, AER, Inc.
   !								   !
!------------------------------------------------------------	!------------------------------------------------------------
   IMPLICIT NONE						   IMPLICIT NONE
!<DESCRIPTION>							!<DESCRIPTION>
!								!
! Radiation_driver is the WRF mediation layer routine that pr	! Radiation_driver is the WRF mediation layer routine that pr
! to radiation physics packages in the WRF model layer. The r	! to radiation physics packages in the WRF model layer. The r
! physics packages to call are chosen by setting the namelist	! physics packages to call are chosen by setting the namelist
! (Rconfig entry in Registry) to the integer value assigned t	! (Rconfig entry in Registry) to the integer value assigned t
! particular package (package entry in Registry). For example	! particular package (package entry in Registry). For example
! namelist variable ra_lw_physics is set to 1, this correspon	! namelist variable ra_lw_physics is set to 1, this correspon
! Registry Package entry for swradscheme.  Note that the Pack	! Registry Package entry for swradscheme.  Note that the Pack
! names in the Registry are defined constants (frame/module_s	! names in the Registry are defined constants (frame/module_s
! in the CASE statements in this routine.			! in the CASE statements in this routine.
!								!
! Among the arguments is moist, a four-dimensional scalar arr	! Among the arguments is moist, a four-dimensional scalar arr
! a variable number of moisture tracers, depending on the phy	! a variable number of moisture tracers, depending on the phy
! configuration for the WRF run, as determined in the namelis	! configuration for the WRF run, as determined in the namelis
! highest numbered index of active moisture tracers the integ	! highest numbered index of active moisture tracers the integ
! n_moist (note: the number of tracers at run time is the qua	! n_moist (note: the number of tracers at run time is the qua
! <tt>n_moist - PARAM_FIRST_SCALAR + 1</tt> , not n_moist. In	! <tt>n_moist - PARAM_FIRST_SCALAR + 1</tt> , not n_moist. In
! may be indexed from moist by the Registry name of the trace	! may be indexed from moist by the Registry name of the trace
! with P_; for example P_QC is the index of cloud water. An i	! with P_; for example P_QC is the index of cloud water. An i
! represents a valid, active field only if the index is great	! represents a valid, active field only if the index is great
! or equal to PARAM_FIRST_SCALAR.  PARAM_FIRST_SCALAR and the	! or equal to PARAM_FIRST_SCALAR.  PARAM_FIRST_SCALAR and the
! indices for each tracer is defined in module_state_descript	! indices for each tracer is defined in module_state_descript
! set in <a href=set_scalar_indices_from_config.html>set_scal	! set in <a href=set_scalar_indices_from_config.html>set_scal
!								!
! Physics drivers in WRF 2.0 and higher, originally model-lay	! Physics drivers in WRF 2.0 and higher, originally model-lay
! routines, have been promoted to mediation layer routines an	! routines, have been promoted to mediation layer routines an
! contain OpenMP threaded loops over tiles.  Thus, physics dr	! contain OpenMP threaded loops over tiles.  Thus, physics dr
! are called from single-threaded regions in the solver. The 	! are called from single-threaded regions in the solver. The 
! routines that are called from the physics drivers are model	! routines that are called from the physics drivers are model
! routines and fully tile-callable and thread-safe.		! routines and fully tile-callable and thread-safe.
!</DESCRIPTION>							!</DESCRIPTION>
! 								! 
!============================================================	!============================================================
! Grid structure in physics part of WRF				! Grid structure in physics part of WRF
!------------------------------------------------------------	!------------------------------------------------------------
! The horizontal velocities used in the physics are unstagger	! The horizontal velocities used in the physics are unstagger
! relative to temperature/moisture variables. All predicted	! relative to temperature/moisture variables. All predicted
! variables are carried at half levels except w, which is at 	! variables are carried at half levels except w, which is at 
! levels. Some arrays with names (*8w) are at w (full) levels	! levels. Some arrays with names (*8w) are at w (full) levels
!								!
!------------------------------------------------------------	!------------------------------------------------------------
! In WRF, kms (smallest number) is the bottom level and kme (	! In WRF, kms (smallest number) is the bottom level and kme (
! number) is the top level.  In your scheme, if 1 is at the t	! number) is the top level.  In your scheme, if 1 is at the t
! then you have to reverse the order in the k direction.	! then you have to reverse the order in the k direction.
!								!
!         kme      -   half level (no data at this level)	!         kme      -   half level (no data at this level)
!         kme    ----- full level				!         kme    ----- full level
!         kme-1    -   half level				!         kme-1    -   half level
!         kme-1  ----- full level				!         kme-1  ----- full level
!         .							!         .
!         .							!         .
!         .							!         .
!         kms+2    -   half level				!         kms+2    -   half level
!         kms+2  ----- full level				!         kms+2  ----- full level
!         kms+1    -   half level				!         kms+1    -   half level
!         kms+1  ----- full level				!         kms+1  ----- full level
!         kms      -   half level				!         kms      -   half level
!         kms    ----- full level				!         kms    ----- full level
!								!
!============================================================	!============================================================
! Grid structure in physics part of WRF				! Grid structure in physics part of WRF
! 								! 
!-------------------------------------				!-------------------------------------
! The horizontal velocities used in the physics are unstagger	! The horizontal velocities used in the physics are unstagger
! relative to temperature/moisture variables. All predicted 	! relative to temperature/moisture variables. All predicted 
! variables are carried at half levels except w, which is at 	! variables are carried at half levels except w, which is at 
! levels. Some arrays with names (*8w) are at w (full) levels	! levels. Some arrays with names (*8w) are at w (full) levels
!								!
!============================================================	!============================================================
! Definitions							! Definitions
!-----------							!-----------
! Theta      potential temperature (K)				! Theta      potential temperature (K)
! Qv         water vapor mixing ratio (kg/kg)			! Qv         water vapor mixing ratio (kg/kg)
! Qc         cloud water mixing ratio (kg/kg)			! Qc         cloud water mixing ratio (kg/kg)
! Qr         rain water mixing ratio (kg/kg)			! Qr         rain water mixing ratio (kg/kg)
! Qi         cloud ice mixing ratio (kg/kg)			! Qi         cloud ice mixing ratio (kg/kg)
! Qs         snow mixing ratio (kg/kg)				! Qs         snow mixing ratio (kg/kg)
!------------------------------------------------------------	!------------------------------------------------------------
!-- PM2_5_DRY     Dry PM2.5 aerosol mass for all species (ug 	!-- PM2_5_DRY     Dry PM2.5 aerosol mass for all species (ug 
!-- PM2_5_WATER   PM2.5 water mass (ug m^-3)			!-- PM2_5_WATER   PM2.5 water mass (ug m^-3)
!-- PM2_5_DRY_EC  Dry PM2.5 elemental carbon aersol mass (ug 	!-- PM2_5_DRY_EC  Dry PM2.5 elemental carbon aersol mass (ug 
!-- RTHRATEN      Theta tendency 				!-- RTHRATEN      Theta tendency 
!                 due to radiation (K/s)			!                 due to radiation (K/s)
!-- RTHRATENLW    Theta tendency 				!-- RTHRATENLW    Theta tendency 
!                 due to long wave radiation (K/s)		!                 due to long wave radiation (K/s)
!-- RTHRATENSW    Theta temperature tendency 			!-- RTHRATENSW    Theta temperature tendency 
!                 due to short wave radiation (K/s)		!                 due to short wave radiation (K/s)
!-- dt            time step (s)					!-- dt            time step (s)
!-- itimestep     number of time steps				!-- itimestep     number of time steps
!-- GLW           downward long wave flux at ground surface (	!-- GLW           downward long wave flux at ground surface (
!-- GSW           net short wave flux at ground surface (W/m^	!-- GSW           net short wave flux at ground surface (W/m^
!-- SWDOWN        downward short wave flux at ground surface 	!-- SWDOWN        downward short wave flux at ground surface 
!-- SWDOWNC       clear-sky downward short wave flux at groun	!-- SWDOWNC       clear-sky downward short wave flux at groun
!-- RLWTOA        upward long wave at top of atmosphere (w/m2	!-- RLWTOA        upward long wave at top of atmosphere (w/m2
!-- RSWTOA        upward short wave at top of atmosphere (w/m	!-- RSWTOA        upward short wave at top of atmosphere (w/m
!-- XLAT          latitude, south is negative (degree)		!-- XLAT          latitude, south is negative (degree)
!-- XLONG         longitude, west is negative (degree)		!-- XLONG         longitude, west is negative (degree)
!-- ALBEDO                albedo (between 0 and 1)	      |	!-- ALBEDO        albedo (between 0 and 1)
!-- CLDFRA        cloud fraction (between 0 and 1)		!-- CLDFRA        cloud fraction (between 0 and 1)
							      >	!-- CLDFRA_DP     cloud fraction from deep cloud in a cumulus
							      >	!-- CLDFRA_SH     cloud fraction from shallow cloud in a cumu
!-- CLDFRA_MP_ALL cloud fraction from CAMMGMP microphysics sc	!-- CLDFRA_MP_ALL cloud fraction from CAMMGMP microphysics sc
!-- EMISS         surface emissivity (between 0 and 1)		!-- EMISS         surface emissivity (between 0 and 1)
!-- rho_phy       density (kg/m^3)				!-- rho_phy       density (kg/m^3)
!-- rr            dry air density (kg/m^3)			!-- rr            dry air density (kg/m^3)
!-- moist         moisture array (4D - last index is species)	!-- moist         moisture array (4D - last index is species)
!-- n_moist       number of moisture species			!-- n_moist       number of moisture species
!-- qndrop        Cloud droplet number (#/kg)			!-- qndrop        Cloud droplet number (#/kg)
!-- p8w           pressure at full levels (Pa)			!-- p8w           pressure at full levels (Pa)
!-- p_phy         pressure (Pa)					!-- p_phy         pressure (Pa)
!-- Pb            base-state pressure (Pa)			!-- Pb            base-state pressure (Pa)
!-- pi_phy        exner function (dimensionless)		!-- pi_phy        exner function (dimensionless)
!-- dz8w          dz between full levels (m)			!-- dz8w          dz between full levels (m)
!-- t_phy         temperature (K)				!-- t_phy         temperature (K)
!-- t8w           temperature at full levels (K)		!-- t8w           temperature at full levels (K)
!-- GMT           Greenwich Mean Time Hour of model start (ho	!-- GMT           Greenwich Mean Time Hour of model start (ho
!-- JULDAY        the initial day (Julian day)			!-- JULDAY        the initial day (Julian day)
!-- RADT          time for calling radiation (min)		!-- RADT          time for calling radiation (min)
!-- ra_call_offset -1 (old) means usually just before output,	!-- ra_call_offset -1 (old) means usually just before output,
!-- DEGRAD        conversion factor for 			!-- DEGRAD        conversion factor for 
!                 degrees to radians (pi/180.) (rad/deg)	!                 degrees to radians (pi/180.) (rad/deg)
!-- DPD           degrees per day for earth's 			!-- DPD           degrees per day for earth's 
!                 orbital position (deg/day)			!                 orbital position (deg/day)
!-- R_d           gas constant for dry air (J/kg/K)		!-- R_d           gas constant for dry air (J/kg/K)
!-- CP            heat capacity at constant pressure for dry 	!-- CP            heat capacity at constant pressure for dry 
!-- G             acceleration due to gravity (m/s^2)		!-- G             acceleration due to gravity (m/s^2)
!-- rvovrd        R_v divided by R_d (dimensionless)		!-- rvovrd        R_v divided by R_d (dimensionless)
!-- XTIME         time since simulation start (min)		!-- XTIME         time since simulation start (min)
!-- DECLIN        solar declination angle (rad)			!-- DECLIN        solar declination angle (rad)
!-- SOLCON        solar constant (W/m^2)			!-- SOLCON        solar constant (W/m^2)
!-- ids           start index for i in domain			!-- ids           start index for i in domain
!-- ide           end index for i in domain			!-- ide           end index for i in domain
!-- jds           start index for j in domain			!-- jds           start index for j in domain
!-- jde           end index for j in domain			!-- jde           end index for j in domain
!-- kds           start index for k in domain			!-- kds           start index for k in domain
!-- kde           end index for k in domain			!-- kde           end index for k in domain
!-- ims           start index for i in memory			!-- ims           start index for i in memory
!-- ime           end index for i in memory			!-- ime           end index for i in memory
!-- jms           start index for j in memory			!-- jms           start index for j in memory
!-- jme           end index for j in memory			!-- jme           end index for j in memory
!-- kms           start index for k in memory			!-- kms           start index for k in memory
!-- kme           end index for k in memory			!-- kme           end index for k in memory
!-- i_start       start indices for i in tile			!-- i_start       start indices for i in tile
!-- i_end         end indices for i in tile			!-- i_end         end indices for i in tile
!-- j_start       start indices for j in tile			!-- j_start       start indices for j in tile
!-- j_end         end indices for j in tile			!-- j_end         end indices for j in tile
!-- kts           start index for k in tile			!-- kts           start index for k in tile
!-- kte           end index for k in tile			!-- kte           end index for k in tile
!-- num_tiles     number of tiles				!-- num_tiles     number of tiles
!								!
!============================================================	!============================================================
!								!
   LOGICAL, OPTIONAL, INTENT(IN) :: explicit_convection		   LOGICAL, OPTIONAL, INTENT(IN) :: explicit_convection
   LOGICAL :: expl_conv						   LOGICAL :: expl_conv
   INTEGER,      INTENT(IN   )    ::   ids,ide, jds,jde, kds,	   INTEGER,      INTENT(IN   )    ::   ids,ide, jds,jde, kds,
                                       ims,ime, jms,jme, kms,	                                       ims,ime, jms,jme, kms,
                                                         kts,	                                                         kts,
                                       num_tiles		                                       num_tiles

   INTEGER, INTENT(IN)            :: lw_physics, sw_physics	   INTEGER, INTENT(IN)            :: lw_physics, sw_physics
   INTEGER, INTENT(IN)            :: cu_physics               |	   INTEGER, INTENT(IN)            :: o3input, aer_opt
   INTEGER, OPTIONAL, INTENT(IN)  :: o3input, aer_opt	      <
   INTEGER, INTENT(IN)            :: id				   INTEGER, INTENT(IN)            :: id
   integer, intent(in)            :: swint_opt			   integer, intent(in)            :: swint_opt

   INTEGER, DIMENSION(num_tiles), INTENT(IN) ::              	   INTEGER, DIMENSION(num_tiles), INTENT(IN) ::              
                i_start,i_end,j_start,j_end			                i_start,i_end,j_start,j_end

   INTEGER,      INTENT(IN   )    ::   STEPRA,ICLOUD,ra_call_	   INTEGER,      INTENT(IN   )    ::   STEPRA,ICLOUD,ra_call_
   INTEGER,      INTENT(IN   )    ::   alevsiz, no_src_types	   INTEGER,      INTENT(IN   )    ::   alevsiz, no_src_types
   INTEGER,      INTENT(IN   )    ::   levsiz, n_ozmixm		   INTEGER,      INTENT(IN   )    ::   levsiz, n_ozmixm
   INTEGER,      INTENT(IN   )    ::   paerlev, n_aerosolc, c	   INTEGER,      INTENT(IN   )    ::   paerlev, n_aerosolc, c
   REAL,      INTENT(IN   )       ::   cam_abs_freq_s		   REAL,      INTENT(IN   )       ::   cam_abs_freq_s

   LOGICAL,      INTENT(IN   )    ::   warm_rain		   LOGICAL,      INTENT(IN   )    ::   warm_rain
							      <
   !BSINGH - For WRFCuP scheme				      <
   LOGICAL,      INTENT(IN   )    ::   shallowcu_forced_ra    <
   LOGICAL                        ::   camExtra = .true.      <
   !BSINGH -ENDS					      <
   							      <
							      <
							      <
							      <
   LOGICAL,      INTENT(IN   )    ::   is_CAMMGMP_used !BSING	   LOGICAL,      INTENT(IN   )    ::   is_CAMMGMP_used !BSING

   REAL,      INTENT(IN   )       ::   RADT			   REAL,      INTENT(IN   )       ::   RADT

   REAL, DIMENSION( ims:ime, jms:jme ),                      	   REAL, DIMENSION( ims:ime, jms:jme ),                      
         INTENT(IN   )  ::                                 XL	         INTENT(IN   )  ::                                 XL
                                                            X	                                                            X
                                                             	                                                             
                                                          VEG	                                                          VEG
                                                            S	                                                            S
   REAL,  DIMENSION( ims:ime, levsiz, jms:jme, n_ozmixm ),  O	   REAL,  DIMENSION( ims:ime, levsiz, jms:jme, n_ozmixm ),  O
          INTENT(IN   ) ::                                  O	          INTENT(IN   ) ::                                  O
   REAL,  DIMENSION( ims:ime, alevsiz, jms:jme, no_src_types,	   REAL,  DIMENSION( ims:ime, alevsiz, jms:jme, no_src_types,
          INTENT(IN   ) ::                                  A	          INTENT(IN   ) ::                                  A
   REAL,  DIMENSION( ims:ime, kms:kme, jms:jme, no_src_types 	   REAL,  DIMENSION( ims:ime, kms:kme, jms:jme, no_src_types 
          INTENT(INOUT) ::                                  A	          INTENT(INOUT) ::                                  A
   REAL,  DIMENSION( ims:ime, jms:jme ), OPTIONAL,           	   REAL,  DIMENSION( ims:ime, jms:jme ), OPTIONAL,           
          INTENT(INOUT) ::                                  A	          INTENT(INOUT) ::                                  A

   REAL,  DIMENSION( ims:ime, levsiz, jms:jme, n_ozmixm ) :: 	   REAL,  DIMENSION( ims:ime, levsiz, jms:jme, n_ozmixm ) :: 

   REAL,  DIMENSION(levsiz), OPTIONAL, INTENT(IN )  ::     PI	   REAL,  DIMENSION(levsiz), OPTIONAL, INTENT(IN )  ::     PI
   REAL,  DIMENSION(alevsiz), OPTIONAL, INTENT(IN )  ::     P	   REAL,  DIMENSION(alevsiz), OPTIONAL, INTENT(IN )  ::     P

   REAL,  DIMENSION(ims:ime,jms:jme), OPTIONAL, INTENT(IN )  	   REAL,  DIMENSION(ims:ime,jms:jme), OPTIONAL, INTENT(IN )  
   REAL,  DIMENSION( ims:ime, paerlev, jms:jme, n_aerosolc ),	   REAL,  DIMENSION( ims:ime, paerlev, jms:jme, n_aerosolc ),
          INTENT(IN   ) ::                       aerosolc_1, 	          INTENT(IN   ) ::                       aerosolc_1, 
   REAL,  DIMENSION(paerlev), OPTIONAL, &			   REAL,  DIMENSION(paerlev), OPTIONAL, &
          INTENT(IN   ) ::                           m_hybi0	          INTENT(IN   ) ::                           m_hybi0

   REAL, DIMENSION( ims:ime, jms:jme ),                      	   REAL, DIMENSION( ims:ime, jms:jme ),                      
         INTENT(INOUT)  ::                                  H	         INTENT(INOUT)  ::                                  H
                                                            H	                                                            H
                                                           HT	                                                           HT
                                                           HB	                                                           HB
                                                           CU	                                                           CU

   !BSINGH - For WRFCuP scheme				      <
   REAL, DIMENSION( ims:ime, jms:jme ),                       <
        INTENT(INOUT)  ::                                     <
                                                           cu <
                                                           cu <
                                                           sh <
   !BSINGH -ENDS					      <
							      <
   INTEGER, INTENT(IN   )  ::   julyr				   INTEGER, INTENT(IN   )  ::   julyr
!								!
   REAL, DIMENSION( ims:ime, kms:kme, jms:jme ),             	   REAL, DIMENSION( ims:ime, kms:kme, jms:jme ),             
         INTENT(IN ) ::                                     d	         INTENT(IN ) ::                                     d
                                                             	                                                             
                                                             	                                                             
                                                             	                                                             
                                                             	                                                             
                                                             	                                                             
                                                             	                                                             
                                                             	                                                             
   !BSINGH - For WRFCuP scheme				      <
   REAL, DIMENSION( ims:ime, kms:kme, jms:jme ),              <
        INTENT(INOUT ) ::                            cldfra_c <
                                                       qc_ic_ <
                                                   qndrop_ic_ <
							      <
   LOGICAL, DIMENSION( ims:ime, jms:jme ), INTENT(IN) :: cupf <
   !BSINGH -ENDS					      <
							      <
!								!
   REAL, DIMENSION( ims:ime, kms:kme, jms:jme ), OPTIONAL ,  	   REAL, DIMENSION( ims:ime, kms:kme, jms:jme ), OPTIONAL ,  
         INTENT(IN ) ::  tauaer300,tauaer400,tauaer600,tauaer	         INTENT(IN ) ::  tauaer300,tauaer400,tauaer600,tauaer
                                 gaer300,gaer400,gaer600,gaer	                                 gaer300,gaer400,gaer600,gaer
                                 waer300,waer400,waer600,waer |	                                 waer300,waer400,waer600,waer
                                 qc_adjust, qi_adjust	      |
							      >	   REAL, DIMENSION( ims:ime, kms:kme, jms:jme ), OPTIONAL ,  
							      >	         INTENT(IN ) ::          qc_cu, qi_cu

   REAL, DIMENSION( ims:ime, kms:kme, jms:jme ), OPTIONAL ,  	   REAL, DIMENSION( ims:ime, kms:kme, jms:jme ), OPTIONAL ,  
         INTENT(IN ) ::  tauaerlw1,tauaerlw2,tauaerlw3,tauaer	         INTENT(IN ) ::  tauaerlw1,tauaerlw2,tauaerlw3,tauaer
                         tauaerlw5,tauaerlw6,tauaerlw7,tauaer	                         tauaerlw5,tauaerlw6,tauaerlw7,tauaer
                         tauaerlw9,tauaerlw10,tauaerlw11,taua	                         tauaerlw9,tauaerlw10,tauaerlw11,taua
                         tauaerlw13,tauaerlw14,tauaerlw15,tau	                         tauaerlw13,tauaerlw14,tauaerlw15,tau

   LOGICAL, INTENT(IN) :: cu_rad_feedback		      |	   INTEGER, INTENT(IN) :: icloud_cu

   INTEGER, INTENT(IN   ), OPTIONAL  ::   aer_ra_feedback	   INTEGER, INTENT(IN   ), OPTIONAL  ::   aer_ra_feedback

!jdfcz   INTEGER, OPTIONAL, INTENT(IN   )    :: progn,prescri	!jdfcz   INTEGER, OPTIONAL, INTENT(IN   )    :: progn,prescri
   INTEGER, OPTIONAL, INTENT(IN   )    :: progn			   INTEGER, OPTIONAL, INTENT(IN   )    :: progn
!								!
! variables for aerosols (only if running with chemistry)	! variables for aerosols (only if running with chemistry)
!								!
   REAL, DIMENSION( ims:ime, kms:kme, jms:jme ), OPTIONAL ,  	   REAL, DIMENSION( ims:ime, kms:kme, jms:jme ), OPTIONAL ,  
         INTENT(IN ) ::                                pm2_5_	         INTENT(IN ) ::                                pm2_5_
                                                     pm2_5_wa	                                                     pm2_5_wa
                                                    pm2_5_dry	                                                    pm2_5_dry
!								!
   REAL, DIMENSION( ims:ime, kms:kme, jms:jme ),             	   REAL, DIMENSION( ims:ime, kms:kme, jms:jme ),             
         INTENT(INOUT)  ::                              RTHRA	         INTENT(INOUT)  ::                              RTHRA
                                                      RTHRATE	                                                      RTHRATE
                                                      RTHRATE	                                                      RTHRATE

!  REAL, DIMENSION( ims:ime, kms:kme, jms:jme ), OPTIONAL ,  	!  REAL, DIMENSION( ims:ime, kms:kme, jms:jme ), OPTIONAL ,  
!        INTENT(INOUT)  ::                                  S	!        INTENT(INOUT)  ::                                  S
!                                                           S	!                                                           S
!                                                      SWUPCL	!                                                      SWUPCL
!                                                      SWDNCL	!                                                      SWDNCL
!                                                           L	!                                                           L
!                                                           L	!                                                           L
!                                                      LWUPCL	!                                                      LWUPCL
!                                                      LWDNCL	!                                                      LWDNCL

   REAL, DIMENSION( ims:ime, jms:jme ), OPTIONAL, INTENT(INOU	   REAL, DIMENSION( ims:ime, jms:jme ), OPTIONAL, INTENT(INOU
                      ACSWUPT,ACSWUPTC,ACSWDNT,ACSWDNTC,     	                      ACSWUPT,ACSWUPTC,ACSWDNT,ACSWDNTC,     
                      ACSWUPB,ACSWUPBC,ACSWDNB,ACSWDNBC,     	                      ACSWUPB,ACSWUPBC,ACSWDNB,ACSWDNBC,     
                      ACLWUPT,ACLWUPTC,ACLWDNT,ACLWDNTC,     	                      ACLWUPT,ACLWUPTC,ACLWDNT,ACLWDNTC,     
                      ACLWUPB,ACLWUPBC,ACLWDNB,ACLWDNBC		                      ACLWUPB,ACLWUPBC,ACLWDNB,ACLWDNBC

! TOA and surface, upward and downward, total and clear fluxe	! TOA and surface, upward and downward, total and clear fluxe
   REAL, DIMENSION( ims:ime, jms:jme ), OPTIONAL, INTENT(INOU	   REAL, DIMENSION( ims:ime, jms:jme ), OPTIONAL, INTENT(INOU
                        SWUPT,  SWUPTC,  SWDNT,  SWDNTC,     	                        SWUPT,  SWUPTC,  SWDNT,  SWDNTC,     
                        SWUPB,  SWUPBC,  SWDNB,  SWDNBC,     	                        SWUPB,  SWUPBC,  SWDNB,  SWDNBC,     
                        LWUPT,  LWUPTC,  LWDNT,  LWDNTC,     	                        LWUPT,  LWUPTC,  LWDNT,  LWDNTC,     
                        LWUPB,  LWUPBC,  LWDNB,  LWDNBC		                        LWUPB,  LWUPBC,  LWDNB,  LWDNBC

! Upward and downward, total and clear sky layer fluxes (W m-	! Upward and downward, total and clear sky layer fluxes (W m-
   REAL, DIMENSION( ims:ime, kms:kme+2, jms:jme ),           	   REAL, DIMENSION( ims:ime, kms:kme+2, jms:jme ),           
         OPTIONAL, INTENT(INOUT) ::                          	         OPTIONAL, INTENT(INOUT) ::                          
                               SWUPFLX,SWUPFLXC,SWDNFLX,SWDNF	                               SWUPFLX,SWUPFLXC,SWDNFLX,SWDNF
                               LWUPFLX,LWUPFLXC,LWDNFLX,LWDNF	                               LWUPFLX,LWUPFLXC,LWDNFLX,LWDNF

   REAL, DIMENSION( ims:ime, jms:jme ),          OPTIONAL ,  	   REAL, DIMENSION( ims:ime, jms:jme ),          OPTIONAL ,  
         INTENT(INOUT)  ::                                  S	         INTENT(INOUT)  ::                                  S
                                                            L	                                                            L
                                                             	                                                             
! ---- fds (06/2010) ssib alb components ------------		! ---- fds (06/2010) ssib alb components ------------
   REAL, DIMENSION( ims:ime, jms:jme ),          OPTIONAL ,  	   REAL, DIMENSION( ims:ime, jms:jme ),          OPTIONAL ,  
         INTENT(IN   )  ::                            ALSWVIS	         INTENT(IN   )  ::                            ALSWVIS
                                                      ALSWVIS	                                                      ALSWVIS
                                                      ALSWNIR	                                                      ALSWNIR
                                                      ALSWNIR	                                                      ALSWNIR
! ---- fds (06/2010) ssib swr components ------------		! ---- fds (06/2010) ssib swr components ------------
   REAL, DIMENSION( ims:ime, jms:jme ),          OPTIONAL ,  	   REAL, DIMENSION( ims:ime, jms:jme ),          OPTIONAL ,  
         INTENT(OUT  )  ::                              SWVIS	         INTENT(OUT  )  ::                              SWVIS
                                                        SWVIS	                                                        SWVIS
                                                        SWNIR	                                                        SWNIR
                                                        SWNIR	                                                        SWNIR
   INTEGER,    OPTIONAL, INTENT(IN   )    ::  sf_surface_phys	   INTEGER,    OPTIONAL, INTENT(IN   )    ::  sf_surface_phys
!								!
   REAL, DIMENSION( ims:ime, jms:jme ),                      	   REAL, DIMENSION( ims:ime, jms:jme ),                      
         INTENT(IN   )  ::                                  X	         INTENT(IN   )  ::                                  X
                                                           XL	                                                           XL
                                                          ALB	                                                          ALB
                                                           EM	                                                           EM
!								!
   REAL, DIMENSION( ims:ime, jms:jme ),                      	   REAL, DIMENSION( ims:ime, jms:jme ),                      
         INTENT(INOUT)  ::                                   	         INTENT(INOUT)  ::                                   
                                                             	                                                             

   REAL, DIMENSION( ims:ime, jms:jme ), INTENT(OUT)  ::   SWD	   REAL, DIMENSION( ims:ime, jms:jme ), INTENT(OUT)  ::   SWD

   ! -------------------------------------------------------- |	! -----------------------------------------------------------
   REAL, DIMENSION( ims:ime, jms:jme ),  INTENT(OUT) :: swddi	   REAL, DIMENSION( ims:ime, jms:jme ),  INTENT(OUT) :: swddi
                                                        swddn	                                                        swddn
                                                        swddi	                                                        swddi
   REAL, DIMENSION( ims:ime, jms:jme ),  INTENT(INOUT) :: Gx,	   REAL, DIMENSION( ims:ime, jms:jme ),  INTENT(INOUT) :: Gx,
                                                          swd	                                                          swd
                                                          swd	                                                          swd
                                                          cos	                                                          cos
   ! -------------------------------------------------------- |	! -----------------------------------------------------------
							      |	    INTEGER,                             INTENT(IN)    :: aer
							      >	                                                          aer
							      >	                                                          aer
							      >	                                                          aer
							      >	                                                          aer
							      >	    REAL,                                INTENT(IN)    :: aer
							      >	                                                          aer
							      >	                                                          aer
							      >	                                                          aer
							      >	    REAL, DIMENSION( ims:ime, jms:jme ),          OPTIONAL,  
							      >	          INTENT(INOUT)                                :: aod
							      >	                                                          ang
							      >	                                                          aer
							      >	                                                          aer
							      >	    REAL, DIMENSION( ims:ime, kms:kme, jms:jme ), OPTIONAL,  
							      >	          INTENT(OUT)                                  :: aod
!								!
   REAL, INTENT(IN  )   ::                                GMT	   REAL, INTENT(IN  )   ::                                GMT
                                                   julian, xt	                                                   julian, xt
   INTEGER, INTENT(IN  ),OPTIONAL ::                         	   INTEGER, INTENT(IN  ),OPTIONAL ::                         
!								!
   INTEGER, INTENT(IN  ) ::                    JULDAY, itimes	   INTEGER, INTENT(IN  ) ::                    JULDAY, itimes
   REAL, INTENT(IN ),OPTIONAL     ::                    CURR_	   REAL, INTENT(IN ),OPTIONAL     ::                    CURR_
   LOGICAL, INTENT(IN ),OPTIONAL  ::              ADAPT_STEP_	   LOGICAL, INTENT(IN ),OPTIONAL  ::              ADAPT_STEP_

   INTEGER,INTENT(IN)                                       :	   INTEGER,INTENT(IN)                                       :
   REAL, DIMENSION( ims:ime, jms:jme ),INTENT(OUT)          :	   REAL, DIMENSION( ims:ime, jms:jme ),INTENT(OUT)          :
                                                      CFRACH,	                                                      CFRACH,
                                                      CFRACL,	                                                      CFRACL,
                                                      CFRACM,	                                                      CFRACM,
                                                      CZMEAN 	                                                      CZMEAN 
   REAL, DIMENSION( ims:ime, jms:jme ),                      	   REAL, DIMENSION( ims:ime, jms:jme ),                      
         INTENT(INOUT)  ::                                   	         INTENT(INOUT)  ::                                   
                                                      RLWTOA,	                                                      RLWTOA,
                                                      RSWTOA,	                                                      RSWTOA,
                                                      ACFRST,	                                                      ACFRST,
                                                      ACFRCV 	                                                      ACFRCV 

   INTEGER,DIMENSION( ims:ime, jms:jme ),INTENT(INOUT)       	   INTEGER,DIMENSION( ims:ime, jms:jme ),INTENT(INOUT)       
                                                          NCF	                                                          NCF
                                                          NCF	                                                          NCF

! Optional, only for Goddard LW and SW				! Optional, only for Goddard LW and SW
   REAL, DIMENSION(IMS:IME, JMS:JME, 1:8)       :: ERBE_out  	   REAL, DIMENSION(IMS:IME, JMS:JME, 1:8)       :: ERBE_out  
   REAL, DIMENSION(IMS:IME, JMS:JME), OPTIONAL, INTENT(INOUT)	   REAL, DIMENSION(IMS:IME, JMS:JME), OPTIONAL, INTENT(INOUT)
                                               TLWDN, TLWUP, 	                                               TLWDN, TLWUP, 
                                               SLWDN, SLWUP, 	                                               SLWDN, SLWUP, 
                                               TSWDN, TSWUP, 	                                               TSWDN, TSWUP, 
                                               SSWDN, SSWUP  	                                               SSWDN, SSWUP  

							      >	! Added by ZCX for low and total cloud fraction
							      >	   REAL, DIMENSION( kms:kme ), OPTIONAL, INTENT(IN)   :: znu 
							      >	   REAL, DIMENSION( ims:ime, jms:jme ),  OPTIONAL, INTENT(INO
							      >	                                                         cldt
							      >
! Optional (only used by CAM lw scheme)				! Optional (only used by CAM lw scheme)

   REAL, DIMENSION( ims:ime, kms:kme, cam_abs_dim2, jms:jme )	   REAL, DIMENSION( ims:ime, kms:kme, cam_abs_dim2, jms:jme )
         INTENT(INOUT)  ::                                  a	         INTENT(INOUT)  ::                                  a
   REAL, DIMENSION( ims:ime, kms:kme, cam_abs_dim1, jms:jme )	   REAL, DIMENSION( ims:ime, kms:kme, cam_abs_dim1, jms:jme )
         INTENT(INOUT)  ::                                  a	         INTENT(INOUT)  ::                                  a
   REAL, DIMENSION( ims:ime, kms:kme, jms:jme ),             	   REAL, DIMENSION( ims:ime, kms:kme, jms:jme ),             
         INTENT(INOUT)  ::                                  e	         INTENT(INOUT)  ::                                  e

!								!
! Optional 							! Optional 
!								!
   REAL, DIMENSION( ims:ime, kms:kme, jms:jme ),             	   REAL, DIMENSION( ims:ime, kms:kme, jms:jme ),             
         OPTIONAL,                                           	         OPTIONAL,                                           
         INTENT(INOUT) ::                                 CLD |	         INTENT(INOUT) ::                                 CLD
							      >
							      >	   REAL, DIMENSION( ims:ime, kms:kme, jms:jme ),             
							      >	         OPTIONAL,                                           
							      >	         INTENT(INOUT) ::                              cldfra
							      >	                                                       cldfra

!..G. Thompson							!..G. Thompson
   REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN):: re_	   REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN):: re_
   INTEGER, INTENT(IN):: has_reqc, has_reqi, has_reqs		   INTEGER, INTENT(IN):: has_reqc, has_reqi, has_reqs

   REAL, DIMENSION( ims:ime, kms:kme, jms:jme ),             	   REAL, DIMENSION( ims:ime, kms:kme, jms:jme ),             
         OPTIONAL,                                           	         OPTIONAL,                                           
         INTENT(IN   ) ::                                    	         INTENT(IN   ) ::                                    
                                                          F_I	                                                          F_I
                                                         F_RA	                                                         F_RA
                                                      CLDFRA_ |	                                                      CLDFRA_
							      >
							      >	#if (EM_CORE == 1)
							      >	   REAL, DIMENSION( ims:ime, kms:kme, jms:jme ),             
							      >	         OPTIONAL,                                           
							      >	         INTENT(IN   ) ::                                    
                                                            L	                                                            L
                                                            I	                                                            I
							      >	#endif

   REAL, DIMENSION( ims:ime, jms:jme ),                      	   REAL, DIMENSION( ims:ime, jms:jme ),                      
         OPTIONAL,                                           	         OPTIONAL,                                           
         INTENT(OUT) ::                                   SWD	         INTENT(OUT) ::                                   SWD
!								!
   REAL, DIMENSION( ims:ime, kms:kme, jms:jme ),             	   REAL, DIMENSION( ims:ime, kms:kme, jms:jme ),             
         OPTIONAL,                                           	         OPTIONAL,                                           
         INTENT(INOUT ) ::                                   	         INTENT(INOUT ) ::                                   
                                                             	                                                             
                                        ,qv,qc,qr,qi,qs,qg,qn	                                        ,qv,qc,qr,qi,qs,qg,qn

   LOGICAL, OPTIONAL ::     f_qv,f_qc,f_qr,f_qi,f_qs,f_qg,f_q	   LOGICAL, OPTIONAL ::     f_qv,f_qc,f_qr,f_qi,f_qs,f_qg,f_q
!								!
   REAL, DIMENSION( ims:ime, kms:kme, jms:jme ),             	   REAL, DIMENSION( ims:ime, kms:kme, jms:jme ),             
         OPTIONAL,                                           	         OPTIONAL,                                           
         INTENT(INOUT)  ::                       taucldi,tauc	         INTENT(INOUT)  ::                       taucldi,tauc

							      >	     REAL, OPTIONAL, INTENT(IN) :: dxkm
							      >
! Variables for slope-dependent radiation			! Variables for slope-dependent radiation

     REAL, OPTIONAL, INTENT(IN) :: dx,dy			     REAL, OPTIONAL, INTENT(IN) :: dx,dy
     INTEGER, OPTIONAL, INTENT(IN) :: slope_rad,topo_shading	     INTEGER, OPTIONAL, INTENT(IN) :: slope_rad,topo_shading
     REAL, DIMENSION( ims:ime, jms:jme ), OPTIONAL, INTENT(IN	     REAL, DIMENSION( ims:ime, jms:jme ), OPTIONAL, INTENT(IN
     INTEGER, DIMENSION( ims:ime, jms:jme ), OPTIONAL, INTENT	     INTEGER, DIMENSION( ims:ime, jms:jme ), OPTIONAL, INTENT
							      >	     REAL, DIMENSION( ims:ime, jms:jme ), OPTIONAL, INTENT(OU

   REAL , OPTIONAL, INTENT(INOUT) ::    radtacttime ! Storing	   REAL , OPTIONAL, INTENT(INOUT) ::    radtacttime ! Storing
   REAL, DIMENSION( ims:ime, kms:kme, jms:jme ),             	   REAL, DIMENSION( ims:ime, kms:kme, jms:jme ),             
         OPTIONAL,                                           	         OPTIONAL,                                           
         INTENT(INOUT)  ::                       o3rad		         INTENT(INOUT)  ::                       o3rad

							      >	   ! vert nesting
							      >	   REAL, OPTIONAL , INTENT(IN   ) :: p_top
							      >	   REAL                           :: p_top_dummy
							      >
! LOCAL  VAR							! LOCAL  VAR

   REAL, DIMENSION( ims:ime, jms:jme ) ::             GLAT,GL	   REAL, DIMENSION( ims:ime, jms:jme ) ::             GLAT,GL
   REAL, DIMENSION( ims:ime, kms:kme, jms:jme ) ::    CEMISS	   REAL, DIMENSION( ims:ime, kms:kme, jms:jme ) ::    CEMISS
   REAL, DIMENSION( ims:ime, jms:jme ) ::             coszr	   REAL, DIMENSION( ims:ime, jms:jme ) ::             coszr
   REAL, DIMENSION( ims:ime, levsiz, jms:jme )  ::    ozmixt	   REAL, DIMENSION( ims:ime, levsiz, jms:jme )  ::    ozmixt
   REAL, DIMENSION( ims:ime, alevsiz, jms:jme, 1:no_src_types	   REAL, DIMENSION( ims:ime, alevsiz, jms:jme, 1:no_src_types

   REAL    ::    DECLIN,SOLCON,XXLAT,TLOCTM,XT24, CEN_LAT	   REAL    ::    DECLIN,SOLCON,XXLAT,TLOCTM,XT24, CEN_LAT
   INTEGER ::    i,j,k,its,ite,jts,jte,ij			   INTEGER ::    i,j,k,its,ite,jts,jte,ij
   INTEGER ::    STEPABS					   INTEGER ::    STEPABS
   LOGICAL ::    gfdl_lw,gfdl_sw				   LOGICAL ::    gfdl_lw,gfdl_sw
   LOGICAL ::    doabsems					   LOGICAL ::    doabsems
   LOGICAL, EXTERNAL :: wrf_dm_on_monitor			   LOGICAL, EXTERNAL :: wrf_dm_on_monitor
   INTEGER ::    s						   INTEGER ::    s

   REAL    ::    OBECL,SINOB,SXLONG,ARG,DECDEG,              	   REAL    ::    OBECL,SINOB,SXLONG,ARG,DECDEG,              
                 DJUL,RJUL,ECCFAC				                 DJUL,RJUL,ECCFAC
   REAL, DIMENSION( ims:ime, kms:kme, jms:jme ) :: qi_temp,qc	   REAL, DIMENSION( ims:ime, kms:kme, jms:jme ) :: qi_temp,qc
   REAL, DIMENSION( ims:ime, kms:kme, jms:jme ) :: qi_save,qc	   REAL, DIMENSION( ims:ime, kms:kme, jms:jme ) :: qi_save,qc
							      >	   REAL, DIMENSION( ims:ime, kms:kme, jms:jme ) :: qs_save
							      >
							      >	   REAL    ::    gridkm

   REAL    ::    next_rad_time				      |	   REAL    ::    next_rad_time, DTaccum
   LOGICAL ::    run_param , doing_adapt_dt , decided		   LOGICAL ::    run_param , doing_adapt_dt , decided
   LOGICAL ::    flg_lw, flg_sw					   LOGICAL ::    flg_lw, flg_sw
							      >	!ZCX
							      >	   REAL    ::    cldji,cldlji
							      >	!ckay
							      >	   REAL, DIMENSION( ims:ime, kms:kme, jms:jme ) ::    cldfra_
!------------------------------------------------------------	!------------------------------------------------------------
! solar related variables are added to declaration		! solar related variables are added to declaration
!-------------------------------------------------		!-------------------------------------------------
   REAL, OPTIONAL, INTENT(OUT) :: DECLINX,SOLCONX		   REAL, OPTIONAL, INTENT(OUT) :: DECLINX,SOLCONX
   REAL, OPTIONAL, DIMENSION( ims:ime, jms:jme), INTENT(OUT) 	   REAL, OPTIONAL, DIMENSION( ims:ime, jms:jme), INTENT(OUT) 
   REAL, OPTIONAL, DIMENSION( ims:ime, jms:jme), INTENT(OUT) 	   REAL, OPTIONAL, DIMENSION( ims:ime, jms:jme), INTENT(OUT) 
!------------------------------------------------------------	!------------------------------------------------------------

   ! jararias, 2013/08/10				      |	! jararias, 2013/08/10
   real :: swdown_0,swddir_0,coszen_0,ioh,kt,airmass,kd	      |	   real :: ioh,kt,airmass,kd
   real, dimension(ims:ime,jms:jme) :: coszen_loc,hrang_loc	   real, dimension(ims:ime,jms:jme) :: coszen_loc,hrang_loc
							      >	! jararias 2013/11
							      >	   real, dimension(:,:,:,:), allocatable :: tauaer_sw, ssaaer
							      >

#ifdef HWRF							#ifdef HWRF
   CHARACTER(len=265) :: wrf_err_message			   CHARACTER(len=265) :: wrf_err_message
#endif								#endif

   ! This allows radiation schemes (mainly HWRF) to correctly	   ! This allows radiation schemes (mainly HWRF) to correctly
   ! interface with the convection scheme when convection is 	   ! interface with the convection scheme when convection is 
   ! enabled in some domains:					   ! enabled in some domains:
   if(present(explicit_convection)) then			   if(present(explicit_convection)) then
      expl_conv=explicit_convection				      expl_conv=explicit_convection
   else								   else
      expl_conv=.true. ! backward compatibility for ARW		      expl_conv=.true. ! backward compatibility for ARW
   endif							   endif

							      >	   IF ( ICLOUD == 3 ) THEN
							      >	      IF (PRESENT(dxkm)) then
							      >	         gridkm = 1.414*SQRT(dxkm*dxkm + dy*0.001*dy*0.001)
							      >	      ELSE IF (PRESENT(dx)) then
							      >	         gridkm = SQRT(dx*0.001*dx*0.001 + dy*0.001*dy*0.001)
							      >	      endif
							      >
							      >	      if (itimestep .LE. 100) then
							      >	        WRITE ( wrf_err_message , * ) 'Grid spacing in km ', 
							      >	        CALL wrf_debug (100, wrf_err_message)
							      >	      endif
							      >	   END IF
							      >
   CALL wrf_debug (1, 'Top of Radiation Driver')		   CALL wrf_debug (1, 'Top of Radiation Driver')
!  WRITE ( wrf_err_message , * ) 'itimestep = ',itimestep,', 	!  WRITE ( wrf_err_message , * ) 'itimestep = ',itimestep,', 
!  CALL wrf_debug (1, wrf_err_message )				!  CALL wrf_debug (1, wrf_err_message )
   if (lw_physics .eq. 0 .and. sw_physics .eq. 0)         ret	   if (lw_physics .eq. 0 .and. sw_physics .eq. 0)         ret

							      >	! amontornes-bcodina (2014-05-02) :: improving the namelist s
							      >	!  if (lw_physics .ne. FLGLWSCHEME .and. sw_physics .eq. FLGS
							      >	!      call wrf_error_fatal('SW and LW schemes are in conflic
							      >	!  end if
							      >	!  if (lw_physics .eq. FLGLWSCHEME .and. sw_physics .ne. FLGS
							      >	!      call wrf_error_fatal('SW and LW schemes are in conflic
							      >	!  end if
							      >
! ra_call_offset = -1 gives old method where radiation may be	! ra_call_offset = -1 gives old method where radiation may be
! ra_call_offset =  0 gives new method where radiation may be	! ra_call_offset =  0 gives new method where radiation may be
!                     and is also consistent with removal of 	!                     and is also consistent with removal of 
! also need to account for stepra=1 which always has zero mod	! also need to account for stepra=1 which always has zero mod

   doing_adapt_dt = .FALSE.					   doing_adapt_dt = .FALSE.
   IF ( PRESENT(adapt_step_flag) ) THEN				   IF ( PRESENT(adapt_step_flag) ) THEN
      IF ( adapt_step_flag ) THEN				      IF ( adapt_step_flag ) THEN
         doing_adapt_dt = .TRUE.				         doing_adapt_dt = .TRUE.
         IF ( radtacttime .eq. 0. ) THEN			         IF ( radtacttime .eq. 0. ) THEN
            radtacttime = CURR_SECS + radt*60.			            radtacttime = CURR_SECS + radt*60.
         END IF							         END IF
      END IF							      END IF
   END IF							   END IF

!  Do we run through this scheme or not?			!  Do we run through this scheme or not?

!    Test 1:  If this is the initial model time, then yes.	!    Test 1:  If this is the initial model time, then yes.
!                ITIMESTEP=1					!                ITIMESTEP=1
!    Test 2:  If the user asked for the radiation to be run e	!    Test 2:  If the user asked for the radiation to be run e
!                RADT=0 or STEPRA=1				!                RADT=0 or STEPRA=1
!    Test 3:  If not adaptive dt, and this is on the requeste	!    Test 3:  If not adaptive dt, and this is on the requeste
!                MOD(ITIMESTEP,STEPRA)=0 (or 1, depending on 	!                MOD(ITIMESTEP,STEPRA)=0 (or 1, depending on 
!    Test 4:  If using adaptive dt and the current time is pa	!    Test 4:  If using adaptive dt and the current time is pa
!                CURR_SECS >= RADTACTTIME			!                CURR_SECS >= RADTACTTIME

!  If we do run through the scheme, we set the flag run_param	!  If we do run through the scheme, we set the flag run_param
!  to TRUE.  The decided flag says that one of these tests wa	!  to TRUE.  The decided flag says that one of these tests wa
!  We only proceed to other tests if the previous tests all h	!  We only proceed to other tests if the previous tests all h

!  If we set run_param to TRUE and this is adaptive time step	!  If we set run_param to TRUE and this is adaptive time step
!  radiation run.						!  radiation run.

   run_param = .FALSE.						   run_param = .FALSE.
   decided = .FALSE.						   decided = .FALSE.
   IF ( ( .NOT. decided ) .AND. &				   IF ( ( .NOT. decided ) .AND. &
        ( itimestep .EQ. 1 ) ) THEN				        ( itimestep .EQ. 1 ) ) THEN
      run_param   = .TRUE.					      run_param   = .TRUE.
      decided     = .TRUE.					      decided     = .TRUE.
   END IF							   END IF

   IF ( ( .NOT. decided ) .AND. &				   IF ( ( .NOT. decided ) .AND. &
        ( ( radt .EQ. 0. ) .OR. ( stepra .EQ. 1 ) ) ) THEN	        ( ( radt .EQ. 0. ) .OR. ( stepra .EQ. 1 ) ) ) THEN
      run_param   = .TRUE.					      run_param   = .TRUE.
      decided     = .TRUE.					      decided     = .TRUE.
   END IF							   END IF

   IF ( ( .NOT. decided ) .AND. &				   IF ( ( .NOT. decided ) .AND. &
        ( .NOT. doing_adapt_dt ) .AND. &			        ( .NOT. doing_adapt_dt ) .AND. &
        ( MOD(itimestep,stepra) .EQ. 1+ra_call_offset ) ) THE	        ( MOD(itimestep,stepra) .EQ. 1+ra_call_offset ) ) THE
      run_param   = .TRUE.					      run_param   = .TRUE.
      decided     = .TRUE.					      decided     = .TRUE.
   END IF							   END IF

   IF ( ( .NOT. decided ) .AND. &				   IF ( ( .NOT. decided ) .AND. &
        ( doing_adapt_dt ) .AND. &				        ( doing_adapt_dt ) .AND. &
        ( curr_secs .GE. radtacttime ) ) THEN			        ( curr_secs .GE. radtacttime ) ) THEN
      run_param   = .TRUE.					      run_param   = .TRUE.
      decided     = .TRUE.					      decided     = .TRUE.
      radtacttime = curr_secs + radt*60				      radtacttime = curr_secs + radt*60
   END IF							   END IF

   if(swint_opt.eq.1) then					   if(swint_opt.eq.1) then
      DO ij = 1 , num_tiles					      DO ij = 1 , num_tiles
         its = i_start(ij)					         its = i_start(ij)
         ite = i_end(ij)					         ite = i_end(ij)
         jts = j_start(ij)					         jts = j_start(ij)
         jte = j_end(ij)					         jte = j_end(ij)
         CALL radconst(XTIME,DECLIN,SOLCON,JULIAN,           	         CALL radconst(XTIME,DECLIN,SOLCON,JULIAN,           
                       DEGRAD,DPD                            	                       DEGRAD,DPD                            
         call calc_coszen(ims,ime,jms,jme,its,ite,jts,jte, &	         call calc_coszen(ims,ime,jms,jme,its,ite,jts,jte, &
                          julian,xtime,gmt,declin,degrad,  &	                          julian,xtime,gmt,declin,degrad,  &
                          xlong,xlat,coszen_loc,hrang_loc)	                          xlong,xlat,coszen_loc,hrang_loc)
      end do							      end do
   end if							   end if

   Radiation_step: IF ( run_param ) then			   Radiation_step: IF ( run_param ) then

! CAM-specific additional radiation frequency - cam_abs_freq_	! CAM-specific additional radiation frequency - cam_abs_freq_
     STEPABS = nint(cam_abs_freq_s/(dt*STEPRA))*STEPRA		     STEPABS = nint(cam_abs_freq_s/(dt*STEPRA))*STEPRA
     IF (itimestep .eq. 1 .or. mod(itimestep,STEPABS) .eq. 1 	     IF (itimestep .eq. 1 .or. mod(itimestep,STEPABS) .eq. 1 
                                        .or. STEPABS .eq. 1 )	                                        .or. STEPABS .eq. 1 )
       doabsems = .true.					       doabsems = .true.
     ELSE							     ELSE
       doabsems = .false.					       doabsems = .false.
     ENDIF							     ENDIF
   IF (PRESENT(adapt_step_flag)) THEN				   IF (PRESENT(adapt_step_flag)) THEN
     IF ((adapt_step_flag)) THEN				     IF ((adapt_step_flag)) THEN
       IF ( (itimestep .EQ. 1) .OR. (cam_abs_freq_s .EQ. 0) .	       IF ( (itimestep .EQ. 1) .OR. (cam_abs_freq_s .EQ. 0) .
           ( CURR_SECS + dt >= ( INT( CURR_SECS / ( cam_abs_f	           ( CURR_SECS + dt >= ( INT( CURR_SECS / ( cam_abs_f
         doabsems = .true.					         doabsems = .true.
       ELSE							       ELSE
         doabsems = .false.					         doabsems = .false.
       ENDIF							       ENDIF
     ENDIF							     ENDIF
   ENDIF							   ENDIF

   gfdl_lw = .false.						   gfdl_lw = .false.
   gfdl_sw = .false.						   gfdl_sw = .false.

							      >	! Allocate aerosol arrays used by aer_opt = 2 option
							      >	   IF ( PRESENT( AOD5502D ) ) THEN
							      >	     ! jararias, 2013/11
							      >	     IF ( aer_opt .EQ. 2 ) THEN
							      >	        swrad_aerosol_select: select case(sw_physics)
							      >
							      >	           case(GODDARDSWSCHEME)
							      >	              allocate(tauaer_sw(ims:ime, kms:kme, jms:jme, 1
							      >	              allocate(ssaaer_sw(ims:ime, kms:kme, jms:jme, 1
							      >	              allocate(asyaer_sw(ims:ime, kms:kme, jms:jme, 1
							      >
							      >	           case(RRTMG_SWSCHEME,RRTMG_SWSCHEME_FAST)
							      >	              allocate(tauaer_sw(ims:ime, kms:kme, jms:jme, 1
							      >	              allocate(ssaaer_sw(ims:ime, kms:kme, jms:jme, 1
							      >	              allocate(asyaer_sw(ims:ime, kms:kme, jms:jme, 1
							      >
							      >	        end select swrad_aerosol_select
							      >	     ELSE
							      >	        swrad_aerosol_select_stub: select case(sw_physics)
							      >
							      >	           case(GODDARDSWSCHEME)
							      >	              allocate(tauaer_sw(1, 1, 1, 1))
							      >	              allocate(ssaaer_sw(1, 1, 1, 1))
							      >	              allocate(asyaer_sw(1, 1, 1, 1))
							      >
							      >	           case(RRTMG_SWSCHEME,RRTMG_SWSCHEME_FAST)
							      >	              allocate(tauaer_sw(1, 1, 1, 1))
							      >	              allocate(ssaaer_sw(1, 1, 1, 1))
							      >	              allocate(asyaer_sw(1, 1, 1, 1))

							      >	        end select swrad_aerosol_select_stub
							      >	     ENDIF
							      >	   ENDIF
							      >
							      >	!---------------
							      >	! Calculate constant for short wave radiation
! moved up and out of OMP loop because it only needs to be co	! moved up and out of OMP loop because it only needs to be co
! and because it is not entirely thread-safe (XT24, TOLOCTM a	! and because it is not entirely thread-safe (XT24, TOLOCTM a
! their thread-privacy)  JM 20100217				! their thread-privacy)  JM 20100217
   DO ij = 1 , num_tiles					   DO ij = 1 , num_tiles
     its = i_start(ij)						     its = i_start(ij)
     ite = i_end(ij)						     ite = i_end(ij)
     jts = j_start(ij)						     jts = j_start(ij)
     jte = j_end(ij)						     jte = j_end(ij)
     CALL radconst(XTIME,DECLIN,SOLCON,JULIAN,               	     CALL radconst(XTIME,DECLIN,SOLCON,JULIAN,               
                   DEGRAD,DPD                                	                   DEGRAD,DPD                                

     IF(PRESENT(declinx).AND.PRESENT(solconx))THEN		     IF(PRESENT(declinx).AND.PRESENT(solconx))THEN
! saved to state arrays used in surface driver			! saved to state arrays used in surface driver
       declinx=declin						       declinx=declin
       solconx=solcon						       solconx=solcon
     ENDIF							     ENDIF

     IF(PRESENT(coszen).AND.PRESENT(hrang))THEN		      |	! added coszen subroutine : jararias, 2013/08/10
       ! added coszen subroutine : jararias, 2013/08/10	      |	!   outputs: coszen, hrang
       !   outputs: coszen, hrang			      |	     call calc_coszen(ims,ime,jms,jme,its,ite,jts,jte,  &
       call calc_coszen(ims,ime,jms,jme,its,ite,jts,jte,  &   |	                      julian,xtime+radt*0.5,gmt, &
                        julian,xtime+radt*0.5,gmt, &	      |	                      declin,degrad,xlong,xlat,coszen,hrang)
                        declin,degrad,xlong,xlat,coszen,hrang <
!! state arrays of hrang and coszen used in surface driver    <
!       XT24=MOD(XTIME+RADT*0.5,1440.)			      <
!       DO j=jts,jte					      <
!       DO i=its,ite					      <
!          TLOCTM=GMT+XT24/60.+XLONG(I,J)/15.		      <
!          HRANG(I,J)=15.*(TLOCTM-12.)*DEGRAD		      <
!          XXLAT=XLAT(I,J)*DEGRAD			      <
!          COSZEN(I,J)=SIN(XXLAT)*SIN(DECLIN)+COS(XXLAT)*COS( <
!       ENDDO						      <
!       ENDDO						      <
     ENDIF						      <
							      <
   ENDDO							   ENDDO

!---------------					      <
   !$OMP PARALLEL DO   &					   !$OMP PARALLEL DO   &
   !$OMP PRIVATE ( ij ,i,j,k,its,ite,jts,jte)			   !$OMP PRIVATE ( ij ,i,j,k,its,ite,jts,jte)

   DO ij = 1 , num_tiles					   DO ij = 1 , num_tiles
     its = i_start(ij)						     its = i_start(ij)
     ite = i_end(ij)						     ite = i_end(ij)
     jts = j_start(ij)						     jts = j_start(ij)
     jte = j_end(ij)						     jte = j_end(ij)

! initialize data						! initialize data

     if ((itimestep.eq.1).and.(swint_opt.eq.1)) then		     if ((itimestep.eq.1).and.(swint_opt.eq.1)) then
        do j=jts,jte						        do j=jts,jte
           do i=its,ite						           do i=its,ite
              Bx(i,j)=0.					              Bx(i,j)=0.
              bb(i,j)=0.					              bb(i,j)=0.
              Gx(i,j)=0.					              Gx(i,j)=0.
              gg(i,j)=0.					              gg(i,j)=0.
           end do						           end do
        end do							        end do
     end if							     end if

     DO j=jts,jte						     DO j=jts,jte
     DO i=its,ite						     DO i=its,ite
        GSW(I,J)=0.						        GSW(I,J)=0.
        GLW(I,J)=0.						        GLW(I,J)=0.
        SWDOWN(I,J)=0.						        SWDOWN(I,J)=0.
        swddir(i,j)=0.  ! jararias, 2013/08/10			        swddir(i,j)=0.  ! jararias, 2013/08/10
        swddni(i,j)=0.  ! jararias, 2013/08/10			        swddni(i,j)=0.  ! jararias, 2013/08/10
        swddif(i,j)=0.  ! jararias, 2013/08/10			        swddif(i,j)=0.  ! jararias, 2013/08/10
        GLAT(I,J)=XLAT(I,J)*DEGRAD				        GLAT(I,J)=XLAT(I,J)*DEGRAD
        GLON(I,J)=XLONG(I,J)*DEGRAD				        GLON(I,J)=XLONG(I,J)*DEGRAD
     ENDDO							     ENDDO
     ENDDO							     ENDDO

     DO j=jts,jte						     DO j=jts,jte
     DO k=kts,kte+1						     DO k=kts,kte+1
     DO i=its,ite						     DO i=its,ite
        RTHRATEN(I,K,J)=0.					        RTHRATEN(I,K,J)=0.
        RTHRATENLW(I,K,J)=0.					        RTHRATENLW(I,K,J)=0.
        RTHRATENSW(I,K,J)=0.					        RTHRATENSW(I,K,J)=0.
!        SWUP(I,K,J) = 0.0					!        SWUP(I,K,J) = 0.0
!        SWDN(I,K,J) = 0.0					!        SWDN(I,K,J) = 0.0
!        SWUPCLEAR(I,K,J) = 0.0					!        SWUPCLEAR(I,K,J) = 0.0
!        SWDNCLEAR(I,K,J) = 0.0					!        SWDNCLEAR(I,K,J) = 0.0
!        LWUP(I,K,J) = 0.0					!        LWUP(I,K,J) = 0.0
!        LWDN(I,K,J) = 0.0					!        LWDN(I,K,J) = 0.0
!        LWUPCLEAR(I,K,J) = 0.0					!        LWUPCLEAR(I,K,J) = 0.0
!        LWDNCLEAR(I,K,J) = 0.0					!        LWDNCLEAR(I,K,J) = 0.0
        CEMISS(I,K,J)=0.0					        CEMISS(I,K,J)=0.0
     ENDDO							     ENDDO
     ENDDO							     ENDDO
     ENDDO							     ENDDO

     IF ( PRESENT( SWUPFLX ) ) THEN				     IF ( PRESENT( SWUPFLX ) ) THEN
        DO j=jts,jte						        DO j=jts,jte
        DO k=kts,kte+2						        DO k=kts,kte+2
        DO i=its,ite						        DO i=its,ite
           SWUPFLX(I,K,J) = 0.0					           SWUPFLX(I,K,J) = 0.0
           SWDNFLX(I,K,J) = 0.0					           SWDNFLX(I,K,J) = 0.0
           SWUPFLXC(I,K,J) = 0.0				           SWUPFLXC(I,K,J) = 0.0
           SWDNFLXC(I,K,J) = 0.0				           SWDNFLXC(I,K,J) = 0.0
           LWUPFLX(I,K,J) = 0.0					           LWUPFLX(I,K,J) = 0.0
           LWDNFLX(I,K,J) = 0.0					           LWDNFLX(I,K,J) = 0.0
           LWUPFLXC(I,K,J) = 0.0				           LWUPFLXC(I,K,J) = 0.0
           LWDNFLXC(I,K,J) = 0.0				           LWDNFLXC(I,K,J) = 0.0
        ENDDO							        ENDDO
        ENDDO							        ENDDO
        ENDDO							        ENDDO
     ENDIF							     ENDIF

! temporarily modify hydrometeors (currently only done for GD	! temporarily modify hydrometeors (currently only done for GD
!								!
       IF ( PRESENT( qc ) .AND. PRESENT( qc_adjust ) .AND. cu |	       IF ( PRESENT( qc ) .AND. PRESENT( qc_cu ) .AND. icloud
          DO j=jts,jte						          DO j=jts,jte
          DO k=kts,kte						          DO k=kts,kte
          DO i=its,ite						          DO i=its,ite
            qc_save(i,k,j) = qc(i,k,j)				            qc_save(i,k,j) = qc(i,k,j)
            qc(i,k,j) = qc(i,k,j) + qc_adjust(i,k,j)	      |	            qc(i,k,j) = qc(i,k,j) + qc_cu(i,k,j)
          ENDDO							          ENDDO
          ENDDO							          ENDDO
          ENDDO							          ENDDO
       ENDIF							       ENDIF
       IF ( PRESENT( qi ) .AND. PRESENT( qi_adjust ) .AND. cu |	       IF ( PRESENT( qi ) .AND. PRESENT( qi_cu ) .AND. icloud
          DO j=jts,jte						          DO j=jts,jte
          DO k=kts,kte						          DO k=kts,kte
          DO i=its,ite						          DO i=its,ite
            qi_save(i,k,j) = qi(i,k,j)				            qi_save(i,k,j) = qi(i,k,j)
            qi(i,k,j) = qi(i,k,j) + qi_adjust(i,k,j)	      |	            qi(i,k,j) = qi(i,k,j) + qi_cu(i,k,j)
          ENDDO							          ENDDO
          ENDDO							          ENDDO
          ENDDO							          ENDDO
       ENDIF							       ENDIF

! Fill temporary water variable depending on micro package (t	! Fill temporary water variable depending on micro package (t
     if(PRESENT(qc) .and. PRESENT(F_QC)) then			     if(PRESENT(qc) .and. PRESENT(F_QC)) then
        DO j=jts,jte						        DO j=jts,jte
        DO k=kts,kte						        DO k=kts,kte
        DO i=its,ite						        DO i=its,ite
           qc_temp(I,K,J)=qc(I,K,J)				           qc_temp(I,K,J)=qc(I,K,J)
        ENDDO							        ENDDO
        ENDDO							        ENDDO
        ENDDO							        ENDDO
     else							     else
        DO j=jts,jte						        DO j=jts,jte
        DO k=kts,kte						        DO k=kts,kte
        DO i=its,ite						        DO i=its,ite
           qc_temp(I,K,J)=0.					           qc_temp(I,K,J)=0.
        ENDDO							        ENDDO
        ENDDO							        ENDDO
        ENDDO							        ENDDO
     endif							     endif
! Remove this - to match NAM operational (affects GFDL and HW	! Remove this - to match NAM operational (affects GFDL and HW
!     if(PRESENT(qr) .and. PRESENT(F_QR)) then		      |	!    if(PRESENT(qr) .and. PRESENT(F_QR)) then
!        DO j=jts,jte					      |	!       DO j=jts,jte
!        DO k=kts,kte					      |	!       DO k=kts,kte
!        DO i=its,ite					      |	!       DO i=its,ite
!           qc_temp(I,K,J) = qc_temp(I,K,J) + qr(I,K,J)	      |	!          qc_temp(I,K,J) = qc_temp(I,K,J) + qr(I,K,J)
!        ENDDO						      |	!       ENDDO
!        ENDDO						      |	!       ENDDO
!        ENDDO						      |	!       ENDDO
!     endif						      |	!    endif
							      <
							      <
!---------------					      <
! Calculate constant for short wave radiation		      <
							      <
     lwrad_cldfra_select: SELECT CASE(lw_physics)	      <
							      <
        CASE (GFDLLWSCHEME)				      <

!-- Do nothing, since cloud fractions (with partial cloudines |	! Choose how to compute cloud fraction (since 3.6)
!-- are defined in GFDL LW/SW schemes and do not need to be i |	! Initialize to zero 
							      >	     DO j=jts,jte
							      >	     DO k=kts,kte
							      >	     DO i=its,ite
							      >	        CLDFRA(i,k,j) = 0.
							      >	     END DO
							      >	     END DO
							      >	     END DO

        CASE (CAMLWSCHEME)				      |	     IF ( ICLOUD == 1 ) THEN

     IF ( PRESENT ( CLDFRA ) .AND.                           	     IF ( PRESENT ( CLDFRA ) .AND.                           
          PRESENT(F_QC) .AND. PRESENT ( F_QI ) ) THEN		          PRESENT(F_QC) .AND. PRESENT ( F_QI ) ) THEN
! Call to cloud fraction routine based on Randall 1994 (Hong 	! Call to cloud fraction routine based on Randall 1994 (Hong 

   CALL cal_cldfra2(CLDFRA,qv,qc,qi,qs,                     & |	        CALL wrf_debug (1, 'CALL cldfra1')
							      >	        CALL cal_cldfra1(CLDFRA,qv,qc,qi,qs,               &
                   F_QV,F_QC,F_QI,F_QS,t,p,                &	                   F_QV,F_QC,F_QI,F_QS,t,p,                &
                   F_ICE_PHY,F_RAIN_PHY,                   &	                   F_ICE_PHY,F_RAIN_PHY,                   &
                   !BSINGH - For WRFCuP scheme		      <
                   cubot,cutop,shall,cupflag,cldfra_cup,   &  <
                   cu_physics,shallowcu_forced_ra,         &  <
                   !BSINGH - ENDS			      <
                   ids,ide, jds,jde, kds,kde,              &	                   ids,ide, jds,jde, kds,kde,              &
                   ims,ime, jms,jme, kms,kme,              &	                   ims,ime, jms,jme, kms,kme,              &
                   its,ite, jts,jte, kts,kte               )	                   its,ite, jts,jte, kts,kte               )

     ENDIF						      |	        IF ( PRESENT ( CLDFRA_DP ) ) THEN
							      |	! this is for Kain-Fritsch scheme
        CASE (RRTMG_LWSCHEME)				      |	          IF ( icloud_cu .EQ. 2 ) THEN
							      |	             CALL wrf_debug (1, 'use kf cldfra')
     IF ( PRESENT ( CLDFRA ) .AND.                            |	             DO j = jts,jte
          PRESENT(F_QC) .AND. PRESENT ( F_QI ) ) THEN	      |	             DO k = kts,kte
! Call to cloud fraction routine based on Randall 1994 (Hong  |	             DO i = its,ite
							      |	                cldfra_cu(i,k,j)=cldfra_dp(i,k,j)+cldfra_sh(i
        CALL cal_cldfra2(CLDFRA,qv,qc,qi,qs,               &  |	                CLDFRA(i,k,j)=(1.-cldfra_cu(i,k,j))*CLDFRA(i,
                   F_QV,F_QC,F_QI,F_QS,t,p,                &  |	                CLDFRA(i,k,j)=CLDFRA(i,k,j)+cldfra_cu(i,k,j) 
                   F_ICE_PHY,F_RAIN_PHY,                   &  |	                CLDFRA(i,k,j)=AMIN1(1.0,CLDFRA(i,k,j))
                   !BSINGH - For WRFCuP scheme		      |	                qc_save(i,k,j)=qc(i,k,j)
                   cubot,cutop,shall,cupflag,cldfra_cup,   &  |	                qc(i,k,j) = qc(i,k,j)+qc_cu(i,k,j)*cldfra_cu(
                   cu_physics,shallowcu_forced_ra,         &  |	                qi_save(i,k,j)=qi(i,k,j)
                   !BSINGH - ENDS			      |	                qi(i,k,j) = qi(i,k,j)+qi_cu(i,k,j)*cldfra_cu(
                   ids,ide, jds,jde, kds,kde,              &  |	             ENDDO
                   ims,ime, jms,jme, kms,kme,              &  |	             ENDDO
                   its,ite, jts,jte, kts,kte               )  |	             ENDDO
							      >	          ENDIF
							      >	        ENDIF

        IF ( PRESENT (cldfra_mp_all) ) THEN			        IF ( PRESENT (cldfra_mp_all) ) THEN
          IF (is_CAMMGMP_used) THEN				          IF (is_CAMMGMP_used) THEN
            !BSINGH: cloud fraction from CAMMGMP is being use	            !BSINGH: cloud fraction from CAMMGMP is being use
							      >	        CALL wrf_debug (1, 'use cammgmp')
            IF (itimestep .NE. 1) THEN				            IF (itimestep .NE. 1) THEN
               DO j=jts,jte					               DO j=jts,jte
               DO k=kts,kte					               DO k=kts,kte
               DO i=its,ite					               DO i=its,ite
                  CLDFRA(i,k,j) = CLDFRA_MP_ALL(I,K,J) !PMA	                  CLDFRA(i,k,j) = CLDFRA_MP_ALL(I,K,J) !PMA
                  if (CLDFRA(i,k,j) .lt. 0.01) CLDFRA(i,k,j) 	                  if (CLDFRA(i,k,j) .lt. 0.01) CLDFRA(i,k,j) 
               ENDDO						               ENDDO
               ENDDO						               ENDDO
               ENDDO						               ENDDO
            ENDIF 						            ENDIF 
          ENDIF							          ENDIF
        ENDIF							        ENDIF
     ENDIF							     ENDIF
 								 
        CASE DEFAULT					      |	     ELSE IF ( ICLOUD == 2 ) THEN

     IF ( PRESENT ( CLDFRA ) .AND.                           	     IF ( PRESENT ( CLDFRA ) .AND.                           
          PRESENT(F_QC) .AND. PRESENT ( F_QI ) ) THEN		          PRESENT(F_QC) .AND. PRESENT ( F_QI ) ) THEN
       CALL cal_cldfra(CLDFRA,qc,qi,F_QC,F_QI,                |	       CALL wrf_debug (1, 'CALL cldfra2')
                       !BSINGH - For WRFCuP scheme	      |	       CALL cal_cldfra2(CLDFRA,qc,qi,F_QC,F_QI,              
                       cu_physics,shallowcu_forced_ra,        <
                       cubot,cutop,shall,cupflag,cldfra_cup,  <
                       !BSINGH -ENDS			      <
                       ids,ide, jds,jde, kds,kde,            	                       ids,ide, jds,jde, kds,kde,            
                       ims,ime, jms,jme, kms,kme,            	                       ims,ime, jms,jme, kms,kme,            
                       its,ite, jts,jte, kts,kte             	                       its,ite, jts,jte, kts,kte             
     ENDIF							     ENDIF

     END SELECT lwrad_cldfra_select    			      |	!+---+-------------------------------------------------------
							      >	!..New cloud fraction scheme added by G. Thompson (2014Oct31)
							      >	!+---+-------------------------------------------------------
							      >
							      >	      ELSEIF (ICLOUD == 3) THEN
							      >	        IF (PRESENT(CLDFRA) .AND.                            
							      >	                           PRESENT(F_QC) .AND. PRESENT ( F_QI
							      >
							      >	           DO j = jts,jte
							      >	           DO k = kts,kte
							      >	           DO i = its,ite
							      >	              qc_save(i,k,j) = qc(i,k,j)
							      >	              qi_save(i,k,j) = qi(i,k,j)
							      >	           ENDDO
							      >	           ENDDO
							      >	           ENDDO
							      >	           IF (PRESENT(F_QS)) THEN
							      >	              DO j = jts,jte
							      >	              DO k = kts,kte
							      >	              DO i = its,ite
							      >	                 qs_save(i,k,j) = qs(i,k,j)
							      >	              ENDDO
							      >	              ENDDO
							      >	              ENDDO
							      >	           ELSE
							      >	              DO j = jts,jte
							      >	              DO k = kts,kte
							      >	              DO i = its,ite
							      >	                 qs_save(i,k,j) = 0.0
							      >	              ENDDO
							      >	              ENDDO
							      >	              ENDDO
							      >	           ENDIF
							      >
							      >	           CALL wrf_debug (150, 'DEBUG: using gthompsn cloud 
							      >	           CALL cal_cldfra3(CLDFRA, qv, qc, qi, qs,          
							      >	     &                 p,t,rho, XLAND, gridkm,               
							      >	     &                 ids,ide, jds,jde, kds,kde,            
							      >	     &                 ims,ime, jms,jme, kms,kme,            
							      >	     &                 its,ite, jts,jte, kts,kte)
							      >
							      >	        ENDIF
							      >
							      >	     END IF

! ww: Interpolating climatological ozone and aerosol to model	! ww: Interpolating climatological ozone and aerosol to model
!     Adapted from camrad code					!     Adapted from camrad code
     IF ( PRESENT( O3RAD ) ) THEN				     IF ( PRESENT( O3RAD ) ) THEN
     IF ( o3input .EQ. 2 .AND. id .EQ. 1 ) THEN			     IF ( o3input .EQ. 2 .AND. id .EQ. 1 ) THEN
!       ! Find the current month (adapted from Cavallo)		!       ! Find the current month (adapted from Cavallo)
!       CALL cam_time_interp( ozmixm, pin, levsiz, date_str, 	!       CALL cam_time_interp( ozmixm, pin, levsiz, date_str, 
!                             ids , ide , jds , jde , kds , k	!                             ids , ide , jds , jde , kds , k
!                             ims , ime , jms , jme , kms , k	!                             ims , ime , jms , jme , kms , k
!                             its , ite , jts , jte , kts , k	!                             its , ite , jts , jte , kts , k
! this is the CAM version					! this is the CAM version
! interpolate to model time-step				! interpolate to model time-step
        call ozn_time_int(julday,julian,ozmixm,ozmixt,levsiz,	        call ozn_time_int(julday,julian,ozmixm,ozmixt,levsiz,
                              ids , ide , jds , jde , kds , k	                              ids , ide , jds , jde , kds , k
                              ims , ime , jms , jme , kms , k	                              ims , ime , jms , jme , kms , k
                              its , ite , jts , jte , kts , k	                              its , ite , jts , jte , kts , k

! interpolate to model model levels				! interpolate to model model levels
        call ozn_p_int(p ,pin, levsiz, ozmixt, o3rad, &		        call ozn_p_int(p ,pin, levsiz, ozmixt, o3rad, &
                              ids , ide , jds , jde , kds , k	                              ids , ide , jds , jde , kds , k
                              ims , ime , jms , jme , kms , k	                              ims , ime , jms , jme , kms , k
                              its , ite , jts , jte , kts , k	                              its , ite , jts , jte , kts , k
     ENDIF							     ENDIF
     ENDIF							     ENDIF

     IF ( PRESENT( AEROD ) ) THEN				     IF ( PRESENT( AEROD ) ) THEN
     IF ( aer_opt .EQ. 1 .AND. id .EQ. 1 ) THEN			     IF ( aer_opt .EQ. 1 .AND. id .EQ. 1 ) THEN
        call aer_time_int(julday,julian,aerodm,aerodt,alevsiz	        call aer_time_int(julday,julian,aerodm,aerodt,alevsiz
                              ids , ide , jds , jde , kds , k	                              ids , ide , jds , jde , kds , k
                              ims , ime , jms , jme , kms , k	                              ims , ime , jms , jme , kms , k
                              its , ite , jts , jte , kts , k	                              its , ite , jts , jte , kts , k

        call aer_p_int(p ,pina, alevsiz, aerodt, aerod, no_sr	        call aer_p_int(p ,pina, alevsiz, aerodt, aerod, no_sr
                              ids , ide , jds , jde , kds , k	                              ids , ide , jds , jde , kds , k
                              ims , ime , jms , jme , kms , k	                              ims , ime , jms , jme , kms , k
                              its , ite , jts , jte , kts , k	                              its , ite , jts , jte , kts , k
     ENDIF							     ENDIF
     ENDIF							     ENDIF

     lwrad_select: SELECT CASE(lw_physics)			     lwrad_select: SELECT CASE(lw_physics)

        CASE (RRTMSCHEME)					        CASE (RRTMSCHEME)
             CALL wrf_debug (100, 'CALL rrtm')			             CALL wrf_debug (100, 'CALL rrtm')

							      >	             IF ( PRESENT(p_top) ) THEN
							      >	                p_top_dummy = p_top
							      >	             ELSE
							      >	                p_top_dummy = -1. ! not used by NMM
							      >	             END IF
             CALL RRTMLWRAD(                                 	             CALL RRTMLWRAD(                                 
                  RTHRATEN=RTHRATEN,GLW=GLW,OLR=RLWTOA,EMISS= |	                  P_TOP=p_top_dummy                          
							      >	                 ,RTHRATEN=RTHRATEN,GLW=GLW,OLR=RLWTOA,EMISS=
                 ,QV3D=QV                                    	                 ,QV3D=QV                                    
                 ,QC3D=QC                                    	                 ,QC3D=QC                                    
                 ,QR3D=QR                                    	                 ,QR3D=QR                                    
                 ,QI3D=QI                                    	                 ,QI3D=QI                                    
                 ,QS3D=QS                                    	                 ,QS3D=QS                                    
                 ,QG3D=QG                                    	                 ,QG3D=QG                                    
                 ,P8W=p8w,P3D=p,PI3D=pi,DZ8W=dz8w,TSK=tsk,T3D	                 ,P8W=p8w,P3D=p,PI3D=pi,DZ8W=dz8w,TSK=tsk,T3D
                 ,T8W=t8w,RHO3D=rho, CLDFRA3D=CLDFRA,R=R_d,G=	                 ,T8W=t8w,RHO3D=rho, CLDFRA3D=CLDFRA,R=R_d,G=
                 ,F_QV=F_QV,F_QC=F_QC,F_QR=F_QR              	                 ,F_QV=F_QV,F_QC=F_QC,F_QR=F_QR              
                 ,F_QI=F_QI,F_QS=F_QS,F_QG=F_QG              	                 ,F_QI=F_QI,F_QS=F_QS,F_QG=F_QG              
                 ,ICLOUD=icloud,WARM_RAIN=warm_rain          	                 ,ICLOUD=icloud,WARM_RAIN=warm_rain          
!ccc Added for time-varying trace gases.			!ccc Added for time-varying trace gases.
                 ,YR=YR,JULIAN=JULIAN                        	                 ,YR=YR,JULIAN=JULIAN                        
!ccc								!ccc
                 ,IDS=ids,IDE=ide, JDS=jds,JDE=jde, KDS=kds,K	                 ,IDS=ids,IDE=ide, JDS=jds,JDE=jde, KDS=kds,K
                 ,IMS=ims,IME=ime, JMS=jms,JME=jme, KMS=kms,K	                 ,IMS=ims,IME=ime, JMS=jms,JME=jme, KMS=kms,K
                 ,ITS=its,ITE=ite, JTS=jts,JTE=jte, KTS=kts,K	                 ,ITS=its,ITE=ite, JTS=jts,JTE=jte, KTS=kts,K
                                                             	                                                             

        CASE (goddardlwscheme)					        CASE (goddardlwscheme)

             CALL wrf_debug (100, 'CALL goddard longwave radi	             CALL wrf_debug (100, 'CALL goddard longwave radi
             IF (itimestep.eq.1) then				             IF (itimestep.eq.1) then
                call wrf_message('running goddard lw radiatio	                call wrf_message('running goddard lw radiatio
             ENDIF						             ENDIF
             CALL goddardrad(sw_or_lw='lw'                   	             CALL goddardrad(sw_or_lw='lw'                   
                    ,rthraten=rthraten,gsf=glw,xlat=xlat,xlon	                    ,rthraten=rthraten,gsf=glw,xlat=xlat,xlon
                    ,alb=albedo,t3d=t,p3d=p,p8w3d=p8w,pi3d=pi	                    ,alb=albedo,t3d=t,p3d=p,p8w3d=p8w,pi3d=pi
                    ,dz8w=dz8w,rho_phy=rho,emiss=emiss       	                    ,dz8w=dz8w,rho_phy=rho,emiss=emiss       
                    ,cldfra3d=cldfra                         	                    ,cldfra3d=cldfra                         
                    ,gmt=gmt,cp=cp,g=g,t8w=t8w               	                    ,gmt=gmt,cp=cp,g=g,t8w=t8w               
                    ,julday=julday,xtime=xtime               	                    ,julday=julday,xtime=xtime               
                    ,declin=declin,solcon=solcon             	                    ,declin=declin,solcon=solcon             
                    , center_lat = cen_lat                   	                    , center_lat = cen_lat                   
                    ,radfrq=radt,degrad=degrad               	                    ,radfrq=radt,degrad=degrad               
                    ,taucldi=taucldi,taucldc=taucldc         	                    ,taucldi=taucldi,taucldc=taucldc         
                    ,warm_rain=warm_rain                     	                    ,warm_rain=warm_rain                     
                    ,ids=ids,ide=ide, jds=jds,jde=jde, kds=kd	                    ,ids=ids,ide=ide, jds=jds,jde=jde, kds=kd
                    ,ims=ims,ime=ime, jms=jms,jme=jme, kms=km	                    ,ims=ims,ime=ime, jms=jms,jme=jme, kms=km
                    ,its=its,ite=ite, jts=jts,jte=jte, kts=kt	                    ,its=its,ite=ite, jts=jts,jte=jte, kts=kt
!                    ,cosz_urb2d=cosz_urb2d ,omg_urb2d=omg_ur	!                    ,cosz_urb2d=cosz_urb2d ,omg_urb2d=omg_ur
                    ,qv3d=qv                                 	                    ,qv3d=qv                                 
                    ,qc3d=qc                                 	                    ,qc3d=qc                                 
                    ,qr3d=qr                                 	                    ,qr3d=qr                                 
                    ,qi3d=qi                                 	                    ,qi3d=qi                                 
                    ,qs3d=qs                                 	                    ,qs3d=qs                                 
                    ,qg3d=qg                                 	                    ,qg3d=qg                                 
                    ,f_qv=f_qv,f_qc=f_qc,f_qr=f_qr           	                    ,f_qv=f_qv,f_qc=f_qc,f_qr=f_qr           
                    ,f_qi=f_qi,f_qs=f_qs,f_qg=f_qg           	                    ,f_qi=f_qi,f_qs=f_qs,f_qg=f_qg           
                    ,erbe_out=erbe_out                       	                    ,erbe_out=erbe_out                       
							      >	                    ,aer_opt=aer_opt                         
                                                             	                                                             

        CASE (GFDLLWSCHEME)					        CASE (GFDLLWSCHEME)

             CALL wrf_debug (100, 'CALL gfdllw')		             CALL wrf_debug (100, 'CALL gfdllw')

             IF ( PRESENT(F_QV) .AND. PRESENT(F_QC) .AND.    	             IF ( PRESENT(F_QV) .AND. PRESENT(F_QC) .AND.    
                  PRESENT(F_QS) .AND. PRESENT(qs)   .AND.    	                  PRESENT(F_QS) .AND. PRESENT(qs)   .AND.    
                  PRESENT(qv)   .AND. PRESENT(qc)   ) THEN	                  PRESENT(qv)   .AND. PRESENT(qc)   ) THEN
               IF ( F_QV .AND. F_QC .AND. F_QS) THEN		               IF ( F_QV .AND. F_QC .AND. F_QS) THEN
                 gfdl_lw  = .true.				                 gfdl_lw  = .true.
                 CALL ETARA(                                 	                 CALL ETARA(                                 
                  DT=dt,XLAND=xland                          	                  DT=dt,XLAND=xland                          
                 ,P8W=p8w,DZ8W=dz8w,RHO_PHY=rho,P_PHY=p,T=t  	                 ,P8W=p8w,DZ8W=dz8w,RHO_PHY=rho,P_PHY=p,T=t  
                 ,QV=qv,QW=qc_temp,QI=qi,QS=qs               	                 ,QV=qv,QW=qc_temp,QI=qi,QS=qs               
                 ,TSK2D=tsk,GLW=GLW,RSWIN=SWDOWN,GSW=GSW     	                 ,TSK2D=tsk,GLW=GLW,RSWIN=SWDOWN,GSW=GSW     
                 ,RSWINC=SWDOWNC,CLDFRA=CLDFRA,PI3D=pi       	                 ,RSWINC=SWDOWNC,CLDFRA=CLDFRA,PI3D=pi       
                 ,GLAT=glat,GLON=glon,HTOP=htop,HBOT=hbot    	                 ,GLAT=glat,GLON=glon,HTOP=htop,HBOT=hbot    
                 ,HBOTR=hbotr, HTOPR=htopr                   	                 ,HBOTR=hbotr, HTOPR=htopr                   
                 ,ALBEDO=albedo,CUPPT=cuppt                  	                 ,ALBEDO=albedo,CUPPT=cuppt                  
                 ,VEGFRA=vegfra,SNOW=snow,G=g,GMT=gmt        	                 ,VEGFRA=vegfra,SNOW=snow,G=g,GMT=gmt        
                 ,NSTEPRA=stepra,NPHS=nphs,ITIMESTEP=itimeste	                 ,NSTEPRA=stepra,NPHS=nphs,ITIMESTEP=itimeste
                 ,XTIME=xtime,JULIAN=julian                  	                 ,XTIME=xtime,JULIAN=julian                  
                 ,JULYR=julyr,JULDAY=julday                  	                 ,JULYR=julyr,JULDAY=julday                  
                 ,GFDL_LW=gfdl_lw,GFDL_SW=gfdl_sw            	                 ,GFDL_LW=gfdl_lw,GFDL_SW=gfdl_sw            
                 ,CFRACL=cfracl,CFRACM=cfracm,CFRACH=cfrach  	                 ,CFRACL=cfracl,CFRACM=cfracm,CFRACH=cfrach  
                 ,ACFRST=acfrst,NCFRST=ncfrst                	                 ,ACFRST=acfrst,NCFRST=ncfrst                
                 ,ACFRCV=acfrcv,NCFRCV=ncfrcv                	                 ,ACFRCV=acfrcv,NCFRCV=ncfrcv                
                 ,RSWTOA=rswtoa,RLWTOA=rlwtoa,CZMEAN=czmean  	                 ,RSWTOA=rswtoa,RLWTOA=rlwtoa,CZMEAN=czmean  
                 ,THRATEN=rthraten,THRATENLW=rthratenlw      	                 ,THRATEN=rthraten,THRATENLW=rthratenlw      
                 ,THRATENSW=rthratensw                       	                 ,THRATENSW=rthratensw                       
                 ,IDS=ids,IDE=ide, JDS=jds,JDE=jde, KDS=kds,K	                 ,IDS=ids,IDE=ide, JDS=jds,JDE=jde, KDS=kds,K
                 ,IMS=ims,IME=ime, JMS=jms,JME=jme, KMS=kms,K	                 ,IMS=ims,IME=ime, JMS=jms,JME=jme, KMS=kms,K
                 ,ITS=its,ITE=ite, JTS=jts,JTE=jte, KTS=kts,K	                 ,ITS=its,ITE=ite, JTS=jts,JTE=jte, KTS=kts,K
                                                             	                                                             
               ELSE						               ELSE
                 CALL wrf_error_fatal('Can not call ETARA (1a	                 CALL wrf_error_fatal('Can not call ETARA (1a
               ENDIF						               ENDIF
             ELSE						             ELSE
               CALL wrf_error_fatal('Can not call ETARA (1b).	               CALL wrf_error_fatal('Can not call ETARA (1b).
             ENDIF						             ENDIF

#ifdef HWRF							#ifdef HWRF
       CASE (HWRFLWSCHEME)					       CASE (HWRFLWSCHEME)

             CALL wrf_debug (100, 'CALL hwrflw')		             CALL wrf_debug (100, 'CALL hwrflw')

             gfdl_lw  = .true.					             gfdl_lw  = .true.

               CALL HWRFRA(explicit_convection=expl_conv, &	               CALL HWRFRA(explicit_convection=expl_conv, &
                    DT=dt,thraten=RTHRATEN,thratenlw=RTHRATEN	                    DT=dt,thraten=RTHRATEN,thratenlw=RTHRATEN
                        XLAND=xland,P8w=p8w,DZ8w=dz8w,RHO_PHY	                        XLAND=xland,P8w=p8w,DZ8w=dz8w,RHO_PHY
                        QV=qv,QW=qc_temp,QI=Qi,              	                        QV=qv,QW=qc_temp,QI=Qi,              
                        TSK2D=tsk,GLW=GLW,GSW=GSW,           	                        TSK2D=tsk,GLW=GLW,GSW=GSW,           
                        TOTSWDN=swdown,TOTLWDN=glw,RSWTOA=rsw	                        TOTSWDN=swdown,TOTLWDN=glw,RSWTOA=rsw
                        GLAT=glat,GLON=glon,HTOP=htop,HBOT=hb	                        GLAT=glat,GLON=glon,HTOP=htop,HBOT=hb
                        VEGFRA=vegfra,SNOW=snow,G=g,GMT=gmt, 	                        VEGFRA=vegfra,SNOW=snow,G=g,GMT=gmt, 
                        NSTEPRA=stepra,NPHS=nphs,itimestep=it	                        NSTEPRA=stepra,NPHS=nphs,itimestep=it
                        julyr=julyr,julday=julday,gfdl_lw=gfd	                        julyr=julyr,julday=julday,gfdl_lw=gfd
                        CFRACL=cfracl,CFRACM=cfracm,CFRACH=cf	                        CFRACL=cfracl,CFRACM=cfracm,CFRACH=cf
                        ACFRST=acfrst,NCFRST=ncfrst,ACFRCV=ac	                        ACFRST=acfrst,NCFRST=ncfrst,ACFRCV=ac
                        ids=ids,ide=ide, jds=jds,jde=jde, kds	                        ids=ids,ide=ide, jds=jds,jde=jde, kds
                        ims=ims,ime=ime, jms=jms,jme=jme, kms	                        ims=ims,ime=ime, jms=jms,jme=jme, kms
                        its=its,ite=ite, jts=jts,jte=jte, kts	                        its=its,ite=ite, jts=jts,jte=jte, kts


#endif								#endif

        CASE (CAMLWSCHEME)					        CASE (CAMLWSCHEME)

             CALL wrf_debug(100, 'CALL camrad lw')		             CALL wrf_debug(100, 'CALL camrad lw')

             IF ( PRESENT( OZMIXM ) .AND. PRESENT( PIN ) .AND	             IF ( PRESENT( OZMIXM ) .AND. PRESENT( PIN ) .AND
                  PRESENT(M_PS_1) .AND. PRESENT(M_PS_2) .AND.	                  PRESENT(M_PS_1) .AND. PRESENT(M_PS_2) .AND.
                  PRESENT(M_HYBI0) .AND. PRESENT(AEROSOLC_1) 	                  PRESENT(M_HYBI0) .AND. PRESENT(AEROSOLC_1) 
                  .AND. PRESENT(AEROSOLC_2).AND. PRESENT(ALSW	                  .AND. PRESENT(AEROSOLC_2).AND. PRESENT(ALSW
!lm call camrad twice, once with o3 mixrats from chem, once w <
CALL CAMRAD(RTHRATENLW=RTHRATEN,RTHRATENSW=RTHRATENSW,    &   <
                     dolw=.true.,dosw=.false.,                <
                     SWUPT=SWUPT,SWUPTC=SWUPTC,               <
                     SWDNT=SWDNT,SWDNTC=SWDNTC,               <
                     LWUPT=LWUPT,LWUPTC=LWUPTC,               <
                     LWDNT=LWDNT,LWDNTC=LWDNTC,               <
                     SWUPB=SWUPB,SWUPBC=SWUPBC,               <
                     SWDNB=SWDNB,SWDNBC=SWDNBC,               <
                     LWUPB=LWUPB,LWUPBC=LWUPBC,               <
                     LWDNB=LWDNB,LWDNBC=LWDNBC,               <
                     SWCF=SWCF,LWCF=LWCF,OLR=RLWTOA,CEMISS=CE <
                     TAUCLDC=TAUCLDC,TAUCLDI=TAUCLDI,COSZR=CO <
                     GSW=GSW,GLW=GLW,XLAT=XLAT,XLONG=XLONG,   <
                     ALBEDO=ALBEDO,t_phy=t,TSK=TSK,EMISS=EMIS <
                    ,QV3D=qv                                  <
                    ,QC3D=qc                                  <
                    ,QR3D=qr                                  <
                    ,QI3D=qi                                  <
                    ,QS3D=qs                                  <
                    ,QG3D=qg                                  <
                    ,ALSWVISDIR=alswvisdir ,ALSWVISDIF=alswvi <
                    ,ALSWNIRDIR=alswnirdir ,ALSWNIRDIF=alswni <
                    ,SWVISDIR=swvisdir ,SWVISDIF=swvisdif     <
                    ,SWNIRDIR=swnirdir ,SWNIRDIF=swnirdif     <
                    ,SF_SURFACE_PHYSICS=sf_surface_physics    <
                    ,F_QV=f_qv,F_QC=f_qc,F_QR=f_qr            <
                    ,F_QI=f_qi,F_QS=f_qs,F_QG=f_qg            <
                    ,f_ice_phy=f_ice_phy,f_rain_phy=f_rain_ph <
                    ,p_phy=p,p8w=p8w,z=z,pi_phy=pi,rho_phy=rh <
                     dz8w=dz8w,                               <
                     CLDFRA=CLDFRA,XLAND=XLAND,XICE=XICE,SNOW <
                     ozmixm=ozmixm,pin0=pin,levsiz=levsiz,    <
                     num_months=n_ozmixm,                     <
                     m_psp=m_ps_1,m_psn=m_ps_2,aerosolcp=aero <
                     aerosolcn=aerosolc_2,m_hybi0=m_hybi0,    <
                     paerlev=paerlev, naer_c=n_aerosolc,      <
                     cam_abs_dim1=cam_abs_dim1, cam_abs_dim2= <
                     GMT=GMT,JULDAY=JULDAY,JULIAN=JULIAN,YR=Y <
                     SOLCON=SOLCON,RADT=RADT,DEGRAD=DEGRAD,n_ <
                     ,abstot_3d=abstot,absnxt_3d=absnxt,emsto <
                     ,doabsems=doabsems                       <
                     !BSINGH - For WRFCuP scheme	      <
                     ,CU_PHYSICS=cu_physics                   <
                     ,SHALLOWCU_FORCED_RA=shallowcu_forced_ra <
                     ,SHALL=shall, CUBOT=cubot, CUTOP=cutop   <
                     ,CLDFRA_CUP=cldfra_cup                   <
                     !BSINGH - ENDS			      <
                     ,IDS=ids,IDE=ide, JDS=jds,JDE=jde, KDS=k <
                     ,IMS=ims,IME=ime, JMS=jms,JME=jme, KMS=k <
                     ,ITS=its,ITE=ite, JTS=jts,JTE=jte, KTS=k <
                     )					      <
!lm							      <
             CALL CAMRAD(RTHRATENLW=RTHRATEN,RTHRATENSW=RTHRA	             CALL CAMRAD(RTHRATENLW=RTHRATEN,RTHRATENSW=RTHRA
                     dolw=.true.,dosw=.false.,               	                     dolw=.true.,dosw=.false.,               
                     SWUPT=SWUPT,SWUPTC=SWUPTC,              	                     SWUPT=SWUPT,SWUPTC=SWUPTC,              
                     SWDNT=SWDNT,SWDNTC=SWDNTC,              	                     SWDNT=SWDNT,SWDNTC=SWDNTC,              
                     LWUPT=LWUPT,LWUPTC=LWUPTC,              	                     LWUPT=LWUPT,LWUPTC=LWUPTC,              
                     LWDNT=LWDNT,LWDNTC=LWDNTC,              	                     LWDNT=LWDNT,LWDNTC=LWDNTC,              
                     SWUPB=SWUPB,SWUPBC=SWUPBC,              	                     SWUPB=SWUPB,SWUPBC=SWUPBC,              
                     SWDNB=SWDNB,SWDNBC=SWDNBC,              	                     SWDNB=SWDNB,SWDNBC=SWDNBC,              
                     LWUPB=LWUPB,LWUPBC=LWUPBC,              	                     LWUPB=LWUPB,LWUPBC=LWUPBC,              
                     LWDNB=LWDNB,LWDNBC=LWDNBC,              	                     LWDNB=LWDNB,LWDNBC=LWDNBC,              
                     SWCF=SWCF,LWCF=LWCF,OLR=RLWTOA,CEMISS=CE	                     SWCF=SWCF,LWCF=LWCF,OLR=RLWTOA,CEMISS=CE
                     TAUCLDC=TAUCLDC,TAUCLDI=TAUCLDI,COSZR=CO	                     TAUCLDC=TAUCLDC,TAUCLDI=TAUCLDI,COSZR=CO
                     GSW=GSW,GLW=GLW,XLAT=XLAT,XLONG=XLONG,  	                     GSW=GSW,GLW=GLW,XLAT=XLAT,XLONG=XLONG,  
                     ALBEDO=ALBEDO,t_phy=t,TSK=TSK,EMISS=EMIS	                     ALBEDO=ALBEDO,t_phy=t,TSK=TSK,EMISS=EMIS
                    ,QV3D=qv                                 	                    ,QV3D=qv                                 
                    ,QC3D=qc                                 	                    ,QC3D=qc                                 
                    ,QR3D=qr                                 	                    ,QR3D=qr                                 
                    ,QI3D=qi                                 	                    ,QI3D=qi                                 
                    ,QS3D=qs                                 	                    ,QS3D=qs                                 
                    ,QG3D=qg                                 	                    ,QG3D=qg                                 
                    ,ALSWVISDIR=alswvisdir ,ALSWVISDIF=alswvi	                    ,ALSWVISDIR=alswvisdir ,ALSWVISDIF=alswvi
                    ,ALSWNIRDIR=alswnirdir ,ALSWNIRDIF=alswni	                    ,ALSWNIRDIR=alswnirdir ,ALSWNIRDIF=alswni
                    ,SWVISDIR=swvisdir ,SWVISDIF=swvisdif    	                    ,SWVISDIR=swvisdir ,SWVISDIF=swvisdif    
                    ,SWNIRDIR=swnirdir ,SWNIRDIF=swnirdif    	                    ,SWNIRDIR=swnirdir ,SWNIRDIF=swnirdif    
                    ,SF_SURFACE_PHYSICS=sf_surface_physics   	                    ,SF_SURFACE_PHYSICS=sf_surface_physics   
							      >	                    ,SWDDIR=swddir,SWDDIF=swddif,SWDDNI=swddn
                    ,F_QV=f_qv,F_QC=f_qc,F_QR=f_qr           	                    ,F_QV=f_qv,F_QC=f_qc,F_QR=f_qr           
                    ,F_QI=f_qi,F_QS=f_qs,F_QG=f_qg           	                    ,F_QI=f_qi,F_QS=f_qs,F_QG=f_qg           
                    ,f_ice_phy=f_ice_phy,f_rain_phy=f_rain_ph	                    ,f_ice_phy=f_ice_phy,f_rain_phy=f_rain_ph
                    ,p_phy=p,p8w=p8w,z=z,pi_phy=pi,rho_phy=rh	                    ,p_phy=p,p8w=p8w,z=z,pi_phy=pi,rho_phy=rh
                     dz8w=dz8w,                              	                     dz8w=dz8w,                              
                     CLDFRA=CLDFRA,XLAND=XLAND,XICE=XICE,SNOW	                     CLDFRA=CLDFRA,XLAND=XLAND,XICE=XICE,SNOW
                     ozmixm=ozmixm,pin0=pin,levsiz=levsiz,   	                     ozmixm=ozmixm,pin0=pin,levsiz=levsiz,   
                     num_months=n_ozmixm,                    	                     num_months=n_ozmixm,                    
                     m_psp=m_ps_1,m_psn=m_ps_2,aerosolcp=aero	                     m_psp=m_ps_1,m_psn=m_ps_2,aerosolcp=aero
                     aerosolcn=aerosolc_2,m_hybi0=m_hybi0,   	                     aerosolcn=aerosolc_2,m_hybi0=m_hybi0,   
                     paerlev=paerlev, naer_c=n_aerosolc,     	                     paerlev=paerlev, naer_c=n_aerosolc,     
                     cam_abs_dim1=cam_abs_dim1, cam_abs_dim2=	                     cam_abs_dim1=cam_abs_dim1, cam_abs_dim2=
                     GMT=GMT,JULDAY=JULDAY,JULIAN=JULIAN,YR=Y	                     GMT=GMT,JULDAY=JULDAY,JULIAN=JULIAN,YR=Y
                     SOLCON=SOLCON,RADT=RADT,DEGRAD=DEGRAD,n_	                     SOLCON=SOLCON,RADT=RADT,DEGRAD=DEGRAD,n_
                     ,abstot_3d=abstot,absnxt_3d=absnxt,emsto |	                   ,abstot_3d=abstot,absnxt_3d=absnxt,emstot_
                     ,doabsems=doabsems                       |	                   ,doabsems=doabsems                        
                     !BSINGH - For WRFCuP scheme	      |	                 ,IDS=ids,IDE=ide, JDS=jds,JDE=jde, KDS=kds,K
                     ,CU_PHYSICS=cu_physics                   |	                 ,IMS=ims,IME=ime, JMS=jms,JME=jme, KMS=kms,K
                     ,SHALLOWCU_FORCED_RA=shallowcu_forced_ra |	                 ,ITS=its,ITE=ite, JTS=jts,JTE=jte, KTS=kts,K
                     ,SHALL=shall, CUBOT=cubot, CUTOP=cutop   |	                 ,coszen=coszen                              
                     ,CLDFRA_CUP=cldfra_cup                   <
                     !BSINGH - ENDS			      <
                     ,IDS=ids,IDE=ide, JDS=jds,JDE=jde, KDS=k <
                     ,IMS=ims,IME=ime, JMS=jms,JME=jme, KMS=k <
                     ,ITS=its,ITE=ite, JTS=jts,JTE=jte, KTS=k <
                     )					      <
             ELSE						             ELSE
                CALL wrf_error_fatal ( 'arguments not present	                CALL wrf_error_fatal ( 'arguments not present
             ENDIF						             ENDIF

        CASE (RRTMG_LWSCHEME)					        CASE (RRTMG_LWSCHEME)
             CALL wrf_debug (100, 'CALL rrtmg_lw')		             CALL wrf_debug (100, 'CALL rrtmg_lw')
							      <
             CALL RRTMG_LWRAD(                               	             CALL RRTMG_LWRAD(                               
                  RTHRATENLW=RTHRATEN,                       	                  RTHRATENLW=RTHRATEN,                       
                  LWUPT=LWUPT,LWUPTC=LWUPTC,                 	                  LWUPT=LWUPT,LWUPTC=LWUPTC,                 
                  LWDNT=LWDNT,LWDNTC=LWDNTC,                 	                  LWDNT=LWDNT,LWDNTC=LWDNTC,                 
                  LWUPB=LWUPB,LWUPBC=LWUPBC,                 	                  LWUPB=LWUPB,LWUPBC=LWUPBC,                 
                  LWDNB=LWDNB,LWDNBC=LWDNBC,                 	                  LWDNB=LWDNB,LWDNBC=LWDNBC,                 
                  GLW=GLW,OLR=RLWTOA,LWCF=LWCF,              	                  GLW=GLW,OLR=RLWTOA,LWCF=LWCF,              
                  EMISS=EMISS,                               	                  EMISS=EMISS,                               
                  P8W=p8w,P3D=p,PI3D=pi,DZ8W=dz8w,TSK=tsk,T3D	                  P8W=p8w,P3D=p,PI3D=pi,DZ8W=dz8w,TSK=tsk,T3D
                  T8W=t8w,RHO3D=rho,R=R_d,G=G,               	                  T8W=t8w,RHO3D=rho,R=R_d,G=G,               
                  ICLOUD=icloud,WARM_RAIN=warm_rain,CLDFRA3D=	                  ICLOUD=icloud,WARM_RAIN=warm_rain,CLDFRA3D=
                  LRADIUS=lradius, IRADIUS=iradius,           |	#if (EM_CORE == 1)
                  IS_CAMMGMP_USED=is_cammgmp_used,            |	                  LRADIUS=lradius, IRADIUS=iradius,          
							      >	#endif
							      >	                  IS_CAMMGMP_USED=is_cammgmp_used,           
							      >
							      >	!ckay
							      >	!                 CLDFRA_KF3D=cldfra_KF,QC_KF3D=qc_KF,QI_KF3D
                  F_ICE_PHY=F_ICE_PHY,F_RAIN_PHY=F_RAIN_PHY, 	                  F_ICE_PHY=F_ICE_PHY,F_RAIN_PHY=F_RAIN_PHY, 
                  XLAND=XLAND,XICE=XICE,SNOW=SNOW,           	                  XLAND=XLAND,XICE=XICE,SNOW=SNOW,           
                  QV3D=QV,QC3D=QC,QR3D=QR,                   	                  QV3D=QV,QC3D=QC,QR3D=QR,                   
                  QI3D=QI,QS3D=QS,QG3D=QG,                   	                  QI3D=QI,QS3D=QS,QG3D=QG,                   
                  O3INPUT=O3INPUT,O33D=O3RAD,                	                  O3INPUT=O3INPUT,O33D=O3RAD,                
                  F_QV=F_QV,F_QC=F_QC,F_QR=F_QR,             	                  F_QV=F_QV,F_QC=F_QC,F_QR=F_QR,             
                  F_QI=F_QI,F_QS=F_QS,F_QG=F_QG,             	                  F_QI=F_QI,F_QS=F_QS,F_QG=F_QG,             
                  RE_CLOUD=re_cloud,RE_ICE=re_ice,RE_SNOW=re_	                  RE_CLOUD=re_cloud,RE_ICE=re_ice,RE_SNOW=re_
                  has_reqc=has_reqc,has_reqi=has_reqi,has_req	                  has_reqc=has_reqc,has_reqi=has_reqi,has_req
#ifdef WRF_CHEM						      |	#if ( WRF_CHEM == 1 )
                  TAUAERLW1=tauaerlw1,TAUAERLW2=tauaerlw2,   	                  TAUAERLW1=tauaerlw1,TAUAERLW2=tauaerlw2,   
                  TAUAERLW3=tauaerlw3,TAUAERLW4=tauaerlw4,   	                  TAUAERLW3=tauaerlw3,TAUAERLW4=tauaerlw4,   
                  TAUAERLW5=tauaerlw5,TAUAERLW6=tauaerlw6,   	                  TAUAERLW5=tauaerlw5,TAUAERLW6=tauaerlw6,   
                  TAUAERLW7=tauaerlw7,TAUAERLW8=tauaerlw8,   	                  TAUAERLW7=tauaerlw7,TAUAERLW8=tauaerlw8,   
                  TAUAERLW9=tauaerlw9,TAUAERLW10=tauaerlw10,  |	                  TAUAERLW9=tauaerlw9,TAUAERLW10=tauaerlw10, 
                  TAUAERLW11=tauaerlw11,TAUAERLW12=tauaerlw12 |	                  TAUAERLW11=tauaerlw11,TAUAERLW12=tauaerlw12
                  TAUAERLW13=tauaerlw13,TAUAERLW14=tauaerlw14 |	                  TAUAERLW13=tauaerlw13,TAUAERLW14=tauaerlw14
                  TAUAERLW15=tauaerlw15,TAUAERLW16=tauaerlw16 |	                  TAUAERLW15=tauaerlw15,TAUAERLW16=tauaerlw16
                  aer_ra_feedback=aer_ra_feedback,           	                  aer_ra_feedback=aer_ra_feedback,           
!jdfcz            progn=progn,prescribe=prescribe,           	!jdfcz            progn=progn,prescribe=prescribe,           
                  progn=progn,                                |	                  progn=progn,                               
							      >	#endif
							      >	                  QNDROP3D=qndrop,F_QNDROP=f_qndrop,         
							      >	!ccc Added for time-varying trace gases.
							      >	                  YR=YR,JULIAN=JULIAN,                       
							      >	!ccc
							      >	                  IDS=ids,IDE=ide, JDS=jds,JDE=jde, KDS=kds,K
							      >	                  IMS=ims,IME=ime, JMS=jms,JME=jme, KMS=kms,K
							      >	                  ITS=its,ITE=ite, JTS=jts,JTE=jte, KTS=kts,K
							      >	                  LWUPFLX=LWUPFLX,LWUPFLXC=LWUPFLXC,         
							      >	                  LWDNFLX=LWDNFLX,LWDNFLXC=LWDNFLXC          
							      >	                                                             
							      >
							      >	        CASE (RRTMG_LWSCHEME_FAST)
							      >	             CALL wrf_debug (100, 'CALL rrtmg_lw')
							      >
							      >	             CALL RRTMG_LWRAD_FAST(                          
							      >	                  RTHRATENLW=RTHRATEN,                       
							      >	                  LWUPT=LWUPT,LWUPTC=LWUPTC,                 
							      >	                  LWDNT=LWDNT,LWDNTC=LWDNTC,                 
							      >	                  LWUPB=LWUPB,LWUPBC=LWUPBC,                 
							      >	                  LWDNB=LWDNB,LWDNBC=LWDNBC,                 
							      >	                  GLW=GLW,OLR=RLWTOA,LWCF=LWCF,              
							      >	                  EMISS=EMISS,                               
							      >	                  P8W=p8w,P3D=p,PI3D=pi,DZ8W=dz8w,TSK=tsk,T3D
							      >	                  T8W=t8w,RHO3D=rho,R=R_d,G=G,               
							      >	                  ICLOUD=icloud,WARM_RAIN=warm_rain,CLDFRA3D=
							      >	#if (EM_CORE == 1)
							      >	                  LRADIUS=lradius, IRADIUS=iradius,          
							      >	#endif
							      >	                  IS_CAMMGMP_USED=is_cammgmp_used,           
							      >
							      >	!ckay
							      >	!                 CLDFRA_KF3D=cldfra_KF,QC_KF3D=qc_KF,QI_KF3D
							      >	                  F_ICE_PHY=F_ICE_PHY,F_RAIN_PHY=F_RAIN_PHY, 
							      >	                  XLAND=XLAND,XICE=XICE,SNOW=SNOW,           
							      >	                  QV3D=QV,QC3D=QC,QR3D=QR,                   
							      >	                  QI3D=QI,QS3D=QS,QG3D=QG,                   
							      >	                  O3INPUT=O3INPUT,O33D=O3RAD,                
							      >	                  F_QV=F_QV,F_QC=F_QC,F_QR=F_QR,             
							      >	                  F_QI=F_QI,F_QS=F_QS,F_QG=F_QG,             
							      >	                  RE_CLOUD=re_cloud,RE_ICE=re_ice,RE_SNOW=re_
							      >	                  has_reqc=has_reqc,has_reqi=has_reqi,has_req
							      >	#if ( WRF_CHEM == 1 )
							      >	                  TAUAERLW1=tauaerlw1,TAUAERLW2=tauaerlw2,   
							      >	                  TAUAERLW3=tauaerlw3,TAUAERLW4=tauaerlw4,   
							      >	                  TAUAERLW5=tauaerlw5,TAUAERLW6=tauaerlw6,   
							      >	                  TAUAERLW7=tauaerlw7,TAUAERLW8=tauaerlw8,   
							      >	                  TAUAERLW9=tauaerlw9,TAUAERLW10=tauaerlw10, 
							      >	                  TAUAERLW11=tauaerlw11,TAUAERLW12=tauaerlw12
							      >	                  TAUAERLW13=tauaerlw13,TAUAERLW14=tauaerlw14
							      >	                  TAUAERLW15=tauaerlw15,TAUAERLW16=tauaerlw16
							      >	                  aer_ra_feedback=aer_ra_feedback,           
							      >	!jdfcz            progn=progn,prescribe=prescribe,           
							      >	                  progn=progn,                               
#endif								#endif
                  QNDROP3D=qndrop,F_QNDROP=f_qndrop,         	                  QNDROP3D=qndrop,F_QNDROP=f_qndrop,         
!ccc Added for time-varying trace gases.			!ccc Added for time-varying trace gases.
                  YR=YR,JULIAN=JULIAN,                       	                  YR=YR,JULIAN=JULIAN,                       
!ccc								!ccc
                  IDS=ids,IDE=ide, JDS=jds,JDE=jde, KDS=kds,K	                  IDS=ids,IDE=ide, JDS=jds,JDE=jde, KDS=kds,K
                  IMS=ims,IME=ime, JMS=jms,JME=jme, KMS=kms,K	                  IMS=ims,IME=ime, JMS=jms,JME=jme, KMS=kms,K
                  ITS=its,ITE=ite, JTS=jts,JTE=jte, KTS=kts,K	                  ITS=its,ITE=ite, JTS=jts,JTE=jte, KTS=kts,K
                  LWUPFLX=LWUPFLX,LWUPFLXC=LWUPFLXC,         	                  LWUPFLX=LWUPFLX,LWUPFLXC=LWUPFLXC,         
                  LWDNFLX=LWDNFLX,LWDNFLXC=LWDNFLXC          	                  LWDNFLX=LWDNFLX,LWDNFLXC=LWDNFLXC          
                                                             	                                                             

        CASE (HELDSUAREZ)					        CASE (HELDSUAREZ)
             CALL wrf_debug (100, 'CALL heldsuarez')		             CALL wrf_debug (100, 'CALL heldsuarez')

             CALL HSRAD(RTHRATEN,p8w,p,pi,dz8w,t,          &	             CALL HSRAD(RTHRATEN,p8w,p,pi,dz8w,t,          &
                     t8w, rho, R_d,G,CP, dt, xlat, degrad, &	                     t8w, rho, R_d,G,CP, dt, xlat, degrad, &
                     ids,ide, jds,jde, kds,kde,            &	                     ids,ide, jds,jde, kds,kde,            &
                     ims,ime, jms,jme, kms,kme,            &	                     ims,ime, jms,jme, kms,kme,            &
                     its,ite, jts,jte, kts,kte            )	                     its,ite, jts,jte, kts,kte            )

! -- add by Jin Kong 10/2011					! -- add by Jin Kong 10/2011
        CASE (FLGLWSCHEME)					        CASE (FLGLWSCHEME)
          CALL wrf_debug (100, 'CALL Fu-Liou-Gu')		          CALL wrf_debug (100, 'CALL Fu-Liou-Gu')
          flg_lw  = .true.					          flg_lw  = .true.
!test Jin Kong 11/01/2011 for ozone				!test Jin Kong 11/01/2011 for ozone
          ozflg = 0.						          ozflg = 0.
!test over							!test over
          CALL RAD_FLG(                               &		          CALL RAD_FLG(                               &
               peven=p8w,podd=p,t8w=t8w,degrees=t     &		               peven=p8w,podd=p,t8w=t8w,degrees=t     &
              ,pi3d=pi,o3=ozflg                       &		              ,pi3d=pi,o3=ozflg                       &
              ,G=G,CP=CP                              &		              ,G=G,CP=CP                              &
              ,albedo=ALBEDO,tskin=tsk                &		              ,albedo=ALBEDO,tskin=tsk                &
              ,h2o=QV,cld_iccld=QI,cld_wlcld=QC       &		              ,h2o=QV,cld_iccld=QI,cld_wlcld=QC       &
              ,cld_prwc=QR,cld_pgwc=QG,cld_snow=QS    &		              ,cld_prwc=QR,cld_pgwc=QG,cld_snow=QS    &
              ,F_QV=F_QV,F_QC=F_QC,F_QR=F_QR          &		              ,F_QV=F_QV,F_QC=F_QC,F_QR=F_QR          &
              ,F_QI=F_QI,F_QS=F_QS,F_QG=F_QG          &		              ,F_QI=F_QI,F_QS=F_QS,F_QG=F_QG          &
              ,warm_rain=warm_rain                    &		              ,warm_rain=warm_rain                    &
              ,cloudstrf=CLDFRA                       &		              ,cloudstrf=CLDFRA                       &
              ,emiss=EMISS                            &		              ,emiss=EMISS                            &
              ,air_den=rho                            &		              ,air_den=rho                            &
              ,dz3d=dz8w                              &		              ,dz3d=dz8w                              &
              ,SOLCON=SOLCON                          &		              ,SOLCON=SOLCON                          &
              ,declin=DECLIN                          &		              ,declin=DECLIN                          &
              ,xtime=xtime, xlong=xlong, xlat=xlat    &		              ,xtime=xtime, xlong=xlong, xlat=xlat    &
              ,JULDAY=JULDAY                          &		              ,JULDAY=JULDAY                          &
              ,gmt=gmt, radt=radt, degrad=degrad      &		              ,gmt=gmt, radt=radt, degrad=degrad      &
              ,dtcolumn=dt                            &		              ,dtcolumn=dt                            &
              ,ids=ids,ide=ide,jds=jds,jde=jde        &		              ,ids=ids,ide=ide,jds=jds,jde=jde        &
              ,kds=kds,kde=kde                        &     	              ,kds=kds,kde=kde                        &     
              ,ims=ims,idim=ime,jms=jms,jdim=jme      &		              ,ims=ims,idim=ime,jms=jms,jdim=jme      &
              ,kms=kms,kmax=kme                       &		              ,kms=kms,kmax=kme                       &
              ,its=its,ite=ite,jts=jts,jte=jte        &		              ,its=its,ite=ite,jts=jts,jte=jte        &
              ,kts=kts,kte=kte                        &		              ,kts=kts,kte=kte                        &
		      ,uswtop=RSWTOA,ulwtop=RLWTOA            |		      ,uswtop=RSWTOA,ulwtop=RLWTOA            &
		      ,NETSWBOT=GSW,DLWBOT=GLW                |		      ,NETSWBOT=GSW,DLWBOT=GLW                &
		      ,DSWBOT=SWDOWN,deltat=RTHRATEN          |		      ,DSWBOT=SWDOWN,deltat=RTHRATEN          &
		      ,dtshort=RTHRATENSW,dtlongwv=RTHRATENLW |		      ,dtshort=RTHRATENSW,dtlongwv=RTHRATENLW &
							      >	              ,SWDDIR=swddir,SWDDIF=swddif,SWDDNI=swddni &  !
              )							              )

          CALL wrf_debug(100, 'a4 Fu_Liou-Gu')			          CALL wrf_debug(100, 'a4 Fu_Liou-Gu')
! -- end 							! -- end 

							      <
        CASE DEFAULT						        CASE DEFAULT
  								  
             WRITE( wrf_err_message , * ) 'The longwave optio	             WRITE( wrf_err_message , * ) 'The longwave optio
             CALL wrf_error_fatal ( wrf_err_message )		             CALL wrf_error_fatal ( wrf_err_message )
           							           
     END SELECT lwrad_select    				     END SELECT lwrad_select    

     IF (lw_physics .gt. 0 .and. .not.gfdl_lw) THEN		     IF (lw_physics .gt. 0 .and. .not.gfdl_lw) THEN
        DO j=jts,jte						        DO j=jts,jte
        DO k=kts,kte						        DO k=kts,kte
        DO i=its,ite						        DO i=its,ite
           RTHRATENLW(I,K,J)=RTHRATEN(I,K,J)			           RTHRATENLW(I,K,J)=RTHRATEN(I,K,J)
! OLR ALSO WILL CONTAIN OUTGOING LONGWAVE FOR RRTM (NMM HAS N	! OLR ALSO WILL CONTAIN OUTGOING LONGWAVE FOR RRTM (NMM HAS N
           IF(PRESENT(OLR) .AND. K .EQ. 1)OLR(I,J)=RLWTOA(I,J	           IF(PRESENT(OLR) .AND. K .EQ. 1)OLR(I,J)=RLWTOA(I,J
        ENDDO							        ENDDO
        ENDDO							        ENDDO
        ENDDO							        ENDDO
     ENDIF							     ENDIF

     IF (lw_physics .eq. goddardlwscheme) THEN			     IF (lw_physics .eq. goddardlwscheme) THEN
          IF ( PRESENT (tlwdn) ) THEN				          IF ( PRESENT (tlwdn) ) THEN
        DO j=jts,jte						        DO j=jts,jte
        DO i=its,ite						        DO i=its,ite
           tlwdn(i,j) = erbe_out(i,j,1)    ! TOA LW downwelli	           tlwdn(i,j) = erbe_out(i,j,1)    ! TOA LW downwelli
           tlwup(i,j) = erbe_out(i,j,2)    ! TOA LW upwelling	           tlwup(i,j) = erbe_out(i,j,2)    ! TOA LW upwelling
           slwdn(i,j) = erbe_out(i,j,3)    ! surface LW downw	           slwdn(i,j) = erbe_out(i,j,3)    ! surface LW downw
           slwup(i,j) = erbe_out(i,j,4)    ! surface LW upwel	           slwup(i,j) = erbe_out(i,j,4)    ! surface LW upwel
        ENDDO    						        ENDDO    
        ENDDO    						        ENDDO    
          ENDIF							          ENDIF
     ENDIF       						     ENDIF       

!							      |	     IF ( PRESENT( AOD5502D ) ) THEN
     swrad_cldfra_select: SELECT CASE(sw_physics)	      |	     ! jararias, 2013/11
							      |	     IF ( aer_opt .EQ. 2 ) THEN
        CASE (CAMSWSCHEME)				      |	     swrad_aerosol_select2: select case(sw_physics)
							      >	        case(GODDARDSWSCHEME)
							      >	           call wrf_debug(100, 'call calc_aerosol_goddard_sw'
							      >	           call calc_aerosol_goddard_sw(ht,dz8w,p,t,qv,aer_ty
							      >	                                        aer_ssa_opt,aer_asy_o
							      >	                                        aer_ssa_val,aer_asy_v
							      >	                                        aerasy2d,ims,ime,jms,
							      >	                                        tauaer_sw,ssaaer_sw,a
							      >	           do j=jts,jte
							      >	              do i=its,ite
							      >	                 do k=kts,kte
							      >	                    aod5503d(i,k,j)=tauaer_sw(i,k,j,8) ! band
							      >	                 end do
							      >	              end do
							      >	           end do

     IF ( PRESENT ( CLDFRA ) .AND.                            |	        case(RRTMG_SWSCHEME,RRTMG_SWSCHEME_FAST)
          PRESENT(F_QC) .AND. PRESENT ( F_QI ) ) THEN	      |	           call wrf_debug(100, 'call calc_aerosol_rrtmg_sw')
! Call to cloud fraction routine based on Randall 1994 (Hong  |	           call calc_aerosol_rrtmg_sw(ht,dz8w,p,t,qv,aer_type
							      >	                                      aer_ssa_opt,aer_asy_opt
							      >	                                      aer_ssa_val,aer_asy_val
							      >	                                      aerasy2d,ims,ime,jms,jm
							      >	                                      tauaer_sw,ssaaer_sw,asy
							      >	           do j=jts,jte
							      >	              do i=its,ite
							      >	                 do k=kts,kte
							      >	                    aod5503d(i,k,j)=tauaer_sw(i,k,j,10) ! ban
							      >	                 end do
							      >	              end do
							      >	           end do

   CALL cal_cldfra2(CLDFRA,qv,qc,qi,qs,                     & |	        case default
                   F_QV,F_QC,F_QI,F_QS,t,p,                &  |	     end select swrad_aerosol_select2
                   F_ICE_PHY,F_RAIN_PHY,                   &  <
                   !BSINGH - For WRFCuP scheme		      <
                   cubot,cutop,shall,cupflag,cldfra_cup,   &  <
                   cu_physics,shallowcu_forced_ra,         &  <
                   !BSINGH -ENDS			      <
                   ids,ide, jds,jde, kds,kde,              &  <
                   ims,ime, jms,jme, kms,kme,              &  <
                   its,ite, jts,jte, kts,kte               )  <
     ENDIF							     ENDIF
 							      <
        CASE (RRTMG_SWSCHEME)				      <
							      <
     IF ( PRESENT ( CLDFRA ) .AND.                            <
          PRESENT(F_QC) .AND. PRESENT ( F_QI ) ) THEN	      <
! Call to cloud fraction routine based on Randall 1994 (Hong  <
							      <
        CALL cal_cldfra2(CLDFRA,qv,qc,qi,qs,               &  <
                   F_QV,F_QC,F_QI,F_QS,t,p,                &  <
                   F_ICE_PHY,F_RAIN_PHY,                   &  <
                   !BSINGH - For WRFCuP scheme		      <
                   cubot,cutop,shall,cupflag,cldfra_cup,   &  <
                   cu_physics,shallowcu_forced_ra,         &  <
                   !BSINGH -ENDS			      <
                   ids,ide, jds,jde, kds,kde,              &  <
                   ims,ime, jms,jme, kms,kme,              &  <
                   its,ite, jts,jte, kts,kte               )  <
     ENDIF							     ENDIF

        CASE DEFAULT					      <
							      <
     END SELECT swrad_cldfra_select    			      <
							      <
     swrad_select: SELECT CASE(sw_physics)			     swrad_select: SELECT CASE(sw_physics)

        CASE (SWRADSCHEME)					        CASE (SWRADSCHEME)
             CALL wrf_debug(100, 'CALL swrad')			             CALL wrf_debug(100, 'CALL swrad')
             CALL SWRAD(                                     	             CALL SWRAD(                                     
                     DT=dt,RTHRATEN=rthraten,GSW=gsw         	                     DT=dt,RTHRATEN=rthraten,GSW=gsw         
                    ,XLAT=xlat,XLONG=xlong,ALBEDO=albedo     	                    ,XLAT=xlat,XLONG=xlong,ALBEDO=albedo     
#ifdef WRF_CHEM						      |	#if ( WRF_CHEM == 1 )
                    ,PM2_5_DRY=pm2_5_dry,PM2_5_WATER=pm2_5_wa	                    ,PM2_5_DRY=pm2_5_dry,PM2_5_WATER=pm2_5_wa
                    ,PM2_5_DRY_EC=pm2_5_dry_ec               	                    ,PM2_5_DRY_EC=pm2_5_dry_ec               
#endif								#endif
                    ,RHO_PHY=rho,T3D=t                       	                    ,RHO_PHY=rho,T3D=t                       
                    ,P3D=p,PI3D=pi,DZ8W=dz8w,GMT=gmt         	                    ,P3D=p,PI3D=pi,DZ8W=dz8w,GMT=gmt         
                    ,R=r_d,CP=cp,G=g,JULDAY=julday           	                    ,R=r_d,CP=cp,G=g,JULDAY=julday           
                    ,XTIME=xtime,DECLIN=declin,SOLCON=solcon 	                    ,XTIME=xtime,DECLIN=declin,SOLCON=solcon 
                    ,RADFRQ=radt,ICLOUD=icloud,DEGRAD=degrad 	                    ,RADFRQ=radt,ICLOUD=icloud,DEGRAD=degrad 
                    ,warm_rain=warm_rain                     	                    ,warm_rain=warm_rain                     
                    ,IDS=ids,IDE=ide, JDS=jds,JDE=jde, KDS=kd	                    ,IDS=ids,IDE=ide, JDS=jds,JDE=jde, KDS=kd
                    ,IMS=ims,IME=ime, JMS=jms,JME=jme, KMS=km	                    ,IMS=ims,IME=ime, JMS=jms,JME=jme, KMS=km
                    ,ITS=its,ITE=ite, JTS=jts,JTE=jte, KTS=kt	                    ,ITS=its,ITE=ite, JTS=jts,JTE=jte, KTS=kt
                    ,QV3D=qv                                 	                    ,QV3D=qv                                 
                    ,QC3D=qc                                 	                    ,QC3D=qc                                 
                    ,QR3D=qr                                 	                    ,QR3D=qr                                 
                    ,QI3D=qi                                 	                    ,QI3D=qi                                 
                    ,QS3D=qs                                 	                    ,QS3D=qs                                 
                    ,QG3D=qg                                 	                    ,QG3D=qg                                 
                    ,F_QV=f_qv,F_QC=f_qc,F_QR=f_qr           	                    ,F_QV=f_qv,F_QC=f_qc,F_QR=f_qr           
                    ,F_QI=f_qi,F_QS=f_qs,F_QG=f_qg           	                    ,F_QI=f_qi,F_QS=f_qs,F_QG=f_qg           
                    ,coszen=coszen,julian=julian             	                    ,coszen=coszen,julian=julian             

        CASE (GSFCSWSCHEME)					        CASE (GSFCSWSCHEME)
             CALL wrf_debug(100, 'CALL gsfcswrad')		             CALL wrf_debug(100, 'CALL gsfcswrad')
             CALL GSFCSWRAD(                                 	             CALL GSFCSWRAD(                                 
                     RTHRATEN=rthraten,GSW=gsw,XLAT=xlat,XLON |	                     RTHRATEN=rthraten,GSW=gsw               
                    ,ALB=albedo,T3D=t,P3D=p,P8W3D=p8w,pi3D=pi	                    ,ALB=albedo,T3D=t,P3D=p,P8W3D=p8w,pi3D=pi
                    ,DZ8W=dz8w,RHO_PHY=rho                   	                    ,DZ8W=dz8w,RHO_PHY=rho                   
                    ,CLDFRA3D=cldfra,RSWTOA=rswtoa           	                    ,CLDFRA3D=cldfra,RSWTOA=rswtoa           
                    ,GMT=gmt,CP=cp,G=g                        |	                    ,CP=cp,G=g                               
                    ,JULDAY=julday,XTIME=xtime                |	                    ,JULDAY=julday                           
                    ,DECLIN=declin,SOLCON=solcon              |	                    ,SOLCON=solcon                           
                    ,RADFRQ=radt,DEGRAD=degrad                |	!                    ,RADFRQ=radt,DEGRAD=degrad              
                    ,TAUCLDI=taucldi,TAUCLDC=taucldc         	                    ,TAUCLDI=taucldi,TAUCLDC=taucldc         
                    ,WARM_RAIN=warm_rain                     	                    ,WARM_RAIN=warm_rain                     
#ifdef WRF_CHEM						      |
							      >	#if ( WRF_CHEM == 1 )
                    ,TAUAER300=tauaer300,TAUAER400=tauaer400 	                    ,TAUAER300=tauaer300,TAUAER400=tauaer400 
                    ,TAUAER600=tauaer600,TAUAER999=tauaer999 	                    ,TAUAER600=tauaer600,TAUAER999=tauaer999 
                    ,GAER300=gaer300,GAER400=gaer400         	                    ,GAER300=gaer300,GAER400=gaer400         
                    ,GAER600=gaer600,GAER999=gaer999         	                    ,GAER600=gaer600,GAER999=gaer999         
                    ,WAER300=waer300,WAER400=waer400         	                    ,WAER300=waer300,WAER400=waer400         
                    ,WAER600=waer600,WAER999=waer999         	                    ,WAER600=waer600,WAER999=waer999         
                    ,aer_ra_feedback=aer_ra_feedback         	                    ,aer_ra_feedback=aer_ra_feedback         
#endif								#endif
                    ,IDS=ids,IDE=ide, JDS=jds,JDE=jde, KDS=kd	                    ,IDS=ids,IDE=ide, JDS=jds,JDE=jde, KDS=kd
                    ,IMS=ims,IME=ime, JMS=jms,JME=jme, KMS=km	                    ,IMS=ims,IME=ime, JMS=jms,JME=jme, KMS=km
                    ,ITS=its,ITE=ite, JTS=jts,JTE=jte, KTS=kt	                    ,ITS=its,ITE=ite, JTS=jts,JTE=jte, KTS=kt
                    ,QV3D=qv                                 	                    ,QV3D=qv                                 
                    ,QC3D=qc                                 	                    ,QC3D=qc                                 
                    ,QR3D=qr                                 	                    ,QR3D=qr                                 
                    ,QI3D=qi                                 	                    ,QI3D=qi                                 
                    ,QS3D=qs                                 	                    ,QS3D=qs                                 
                    ,QG3D=qg                                 	                    ,QG3D=qg                                 
                    ,QNDROP3D=qndrop                         	                    ,QNDROP3D=qndrop                         
                    ,F_QV=f_qv,F_QC=f_qc,F_QR=f_qr           	                    ,F_QV=f_qv,F_QC=f_qc,F_QR=f_qr           
                    ,F_QI=f_qi,F_QS=f_qs,F_QG=f_qg           	                    ,F_QI=f_qi,F_QS=f_qs,F_QG=f_qg           
                    ,F_QNDROP=f_qndrop                       	                    ,F_QNDROP=f_qndrop                       
							      >	                    ,COSZEN=coszen                           
                                                             	                                                             

        CASE (goddardswscheme)					        CASE (goddardswscheme)

             CALL wrf_debug(100, 'CALL goddard shortwave radi	             CALL wrf_debug(100, 'CALL goddard shortwave radi
             IF (itimestep.eq.1) then				             IF (itimestep.eq.1) then
                call wrf_message('running goddard sw radiatio	                call wrf_message('running goddard sw radiatio
             ENDIF						             ENDIF
             CALL goddardrad(sw_or_lw='sw'                   	             CALL goddardrad(sw_or_lw='sw'                   
                    ,rthraten=rthraten,gsf=gsw,xlat=xlat,xlon	                    ,rthraten=rthraten,gsf=gsw,xlat=xlat,xlon
                    ,alb=albedo,t3d=t,p3d=p,p8w3d=p8w,pi3d=pi	                    ,alb=albedo,t3d=t,p3d=p,p8w3d=p8w,pi3d=pi
                    ,dz8w=dz8w,rho_phy=rho,emiss=emiss       	                    ,dz8w=dz8w,rho_phy=rho,emiss=emiss       
                    ,cldfra3d=cldfra                         	                    ,cldfra3d=cldfra                         
                    ,gmt=gmt,cp=cp,g=g,t8w=t8w               	                    ,gmt=gmt,cp=cp,g=g,t8w=t8w               
                    ,julday=julday,xtime=xtime               	                    ,julday=julday,xtime=xtime               
                    ,declin=declin,solcon=solcon             	                    ,declin=declin,solcon=solcon             
                    ,center_lat = cen_lat                    	                    ,center_lat = cen_lat                    
                    ,radfrq=radt,degrad=degrad               	                    ,radfrq=radt,degrad=degrad               
                    ,taucldi=taucldi,taucldc=taucldc         	                    ,taucldi=taucldi,taucldc=taucldc         
                    ,warm_rain=warm_rain                     	                    ,warm_rain=warm_rain                     
                    ,ids=ids,ide=ide, jds=jds,jde=jde, kds=kd	                    ,ids=ids,ide=ide, jds=jds,jde=jde, kds=kd
                    ,ims=ims,ime=ime, jms=jms,jme=jme, kms=km	                    ,ims=ims,ime=ime, jms=jms,jme=jme, kms=km
                    ,its=its,ite=ite, jts=jts,jte=jte, kts=kt	                    ,its=its,ite=ite, jts=jts,jte=jte, kts=kt
!                    ,cosz_urb2d=cosz_urb2d ,omg_urb2d=omg_ur	!                    ,cosz_urb2d=cosz_urb2d ,omg_urb2d=omg_ur
                    ,qv3d=qv                                 	                    ,qv3d=qv                                 
                    ,qc3d=qc                                 	                    ,qc3d=qc                                 
                    ,qr3d=qr                                 	                    ,qr3d=qr                                 
                    ,qi3d=qi                                 	                    ,qi3d=qi                                 
                    ,qs3d=qs                                 	                    ,qs3d=qs                                 
                    ,qg3d=qg                                 	                    ,qg3d=qg                                 
                    ,f_qv=f_qv,f_qc=f_qc,f_qr=f_qr           	                    ,f_qv=f_qv,f_qc=f_qc,f_qr=f_qr           
                    ,f_qi=f_qi,f_qs=f_qs,f_qg=f_qg           	                    ,f_qi=f_qi,f_qs=f_qs,f_qg=f_qg           
                    ,erbe_out=erbe_out                       	                    ,erbe_out=erbe_out                       
                    ,swddir=swddir,swddni=swddni,swddif=swddi	                    ,swddir=swddir,swddni=swddni,swddif=swddi
                    ,coszen=coszen,julian=julian             	                    ,coszen=coszen,julian=julian             
							      >	                    ,tauaer3d_sw=tauaer_sw                   
							      >	                    ,ssaaer3d_sw=ssaaer_sw                   
							      >	                    ,asyaer3d_sw=asyaer_sw                   
							      >	                    ,aer_opt=aer_opt                         
                                                             	                                                             

        CASE (CAMSWSCHEME)					        CASE (CAMSWSCHEME)
             CALL wrf_debug(100, 'CALL camrad sw')		             CALL wrf_debug(100, 'CALL camrad sw')
             IF ( PRESENT( OZMIXM ) .AND. PRESENT( PIN ) .AND	             IF ( PRESENT( OZMIXM ) .AND. PRESENT( PIN ) .AND
                  PRESENT(M_PS_1) .AND. PRESENT(M_PS_2) .AND.	                  PRESENT(M_PS_1) .AND. PRESENT(M_PS_2) .AND.
                  PRESENT(M_HYBI0) .AND. PRESENT(AEROSOLC_1) 	                  PRESENT(M_HYBI0) .AND. PRESENT(AEROSOLC_1) 
                  .AND. PRESENT(AEROSOLC_2) .AND. PRESENT(ALS	                  .AND. PRESENT(AEROSOLC_2) .AND. PRESENT(ALS
             CALL CAMRAD(RTHRATENLW=RTHRATEN,RTHRATENSW=RTHRA	             CALL CAMRAD(RTHRATENLW=RTHRATEN,RTHRATENSW=RTHRA
                     dolw=.false.,dosw=.true.,               	                     dolw=.false.,dosw=.true.,               
                     SWUPT=SWUPT,SWUPTC=SWUPTC,              	                     SWUPT=SWUPT,SWUPTC=SWUPTC,              
                     SWDNT=SWDNT,SWDNTC=SWDNTC,              	                     SWDNT=SWDNT,SWDNTC=SWDNTC,              
                     LWUPT=LWUPT,LWUPTC=LWUPTC,              	                     LWUPT=LWUPT,LWUPTC=LWUPTC,              
                     LWDNT=LWDNT,LWDNTC=LWDNTC,              	                     LWDNT=LWDNT,LWDNTC=LWDNTC,              
                     SWUPB=SWUPB,SWUPBC=SWUPBC,              	                     SWUPB=SWUPB,SWUPBC=SWUPBC,              
                     SWDNB=SWDNB,SWDNBC=SWDNBC,              	                     SWDNB=SWDNB,SWDNBC=SWDNBC,              
                     LWUPB=LWUPB,LWUPBC=LWUPBC,              	                     LWUPB=LWUPB,LWUPBC=LWUPBC,              
                     LWDNB=LWDNB,LWDNBC=LWDNBC,              	                     LWDNB=LWDNB,LWDNBC=LWDNBC,              
                     SWCF=SWCF,LWCF=LWCF,OLR=RLWTOA,CEMISS=CE	                     SWCF=SWCF,LWCF=LWCF,OLR=RLWTOA,CEMISS=CE
                     TAUCLDC=TAUCLDC,TAUCLDI=TAUCLDI,COSZR=CO	                     TAUCLDC=TAUCLDC,TAUCLDI=TAUCLDI,COSZR=CO
                     GSW=GSW,GLW=GLW,XLAT=XLAT,XLONG=XLONG,  	                     GSW=GSW,GLW=GLW,XLAT=XLAT,XLONG=XLONG,  
                     ALBEDO=ALBEDO,t_phy=t,TSK=TSK,EMISS=EMIS	                     ALBEDO=ALBEDO,t_phy=t,TSK=TSK,EMISS=EMIS
                    ,QV3D=qv                                 	                    ,QV3D=qv                                 
                    ,QC3D=qc                                 	                    ,QC3D=qc                                 
                    ,QR3D=qr                                 	                    ,QR3D=qr                                 
                    ,QI3D=qi                                 	                    ,QI3D=qi                                 
                    ,QS3D=qs                                 	                    ,QS3D=qs                                 
                    ,QG3D=qg                                 	                    ,QG3D=qg                                 
                    ,ALSWVISDIR=alswvisdir ,ALSWVISDIF=alswvi	                    ,ALSWVISDIR=alswvisdir ,ALSWVISDIF=alswvi
                    ,ALSWNIRDIR=alswnirdir ,ALSWNIRDIF=alswni	                    ,ALSWNIRDIR=alswnirdir ,ALSWNIRDIF=alswni
                    ,SWVISDIR=swvisdir ,SWVISDIF=swvisdif    	                    ,SWVISDIR=swvisdir ,SWVISDIF=swvisdif    
                    ,SWNIRDIR=swnirdir ,SWNIRDIF=swnirdif    	                    ,SWNIRDIR=swnirdir ,SWNIRDIF=swnirdif    
                    ,SF_SURFACE_PHYSICS=sf_surface_physics   	                    ,SF_SURFACE_PHYSICS=sf_surface_physics   
							      >	                    ,SWDDIR=swddir,SWDDIF=swddif,SWDDNI=swddn
                    ,F_QV=f_qv,F_QC=f_qc,F_QR=f_qr           	                    ,F_QV=f_qv,F_QC=f_qc,F_QR=f_qr           
                    ,F_QI=f_qi,F_QS=f_qs,F_QG=f_qg           	                    ,F_QI=f_qi,F_QS=f_qs,F_QG=f_qg           
                    ,f_ice_phy=f_ice_phy,f_rain_phy=f_rain_ph	                    ,f_ice_phy=f_ice_phy,f_rain_phy=f_rain_ph
                    ,p_phy=p,p8w=p8w,z=z,pi_phy=pi,rho_phy=rh	                    ,p_phy=p,p8w=p8w,z=z,pi_phy=pi,rho_phy=rh
                     dz8w=dz8w,                              	                     dz8w=dz8w,                              
                     CLDFRA=CLDFRA,XLAND=XLAND,XICE=XICE,SNOW	                     CLDFRA=CLDFRA,XLAND=XLAND,XICE=XICE,SNOW
                     ozmixm=ozmixm,pin0=pin,levsiz=levsiz,   	                     ozmixm=ozmixm,pin0=pin,levsiz=levsiz,   
                     num_months=n_ozmixm,                    	                     num_months=n_ozmixm,                    
                     m_psp=m_ps_1,m_psn=m_ps_2,aerosolcp=aero	                     m_psp=m_ps_1,m_psn=m_ps_2,aerosolcp=aero
                     aerosolcn=aerosolc_2,m_hybi0=m_hybi0,   	                     aerosolcn=aerosolc_2,m_hybi0=m_hybi0,   
                     paerlev=paerlev, naer_c=n_aerosolc,     	                     paerlev=paerlev, naer_c=n_aerosolc,     
                     cam_abs_dim1=cam_abs_dim1, cam_abs_dim2=	                     cam_abs_dim1=cam_abs_dim1, cam_abs_dim2=
                     GMT=GMT,JULDAY=JULDAY,JULIAN=JULIAN,YR=Y	                     GMT=GMT,JULDAY=JULDAY,JULIAN=JULIAN,YR=Y
                     SOLCON=SOLCON,RADT=RADT,DEGRAD=DEGRAD,n_	                     SOLCON=SOLCON,RADT=RADT,DEGRAD=DEGRAD,n_
                   ,abstot_3d=abstot,absnxt_3d=absnxt,emstot_	                   ,abstot_3d=abstot,absnxt_3d=absnxt,emstot_
                   ,doabsems=doabsems                         |	                   ,doabsems=doabsems                        
                   !BSINGH - For WRFCuP scheme		      <
                   ,CU_PHYSICS=cu_physics                     <
                   ,SHALLOWCU_FORCED_RA=shallowcu_forced_ra   <
                   ,SHALL=shall, CUBOT=cubot, CUTOP=cutop     <
                   ,CLDFRA_CUP=cldfra_cup                     <
                   !BSINGH  - ENDS			      <
                 ,IDS=ids,IDE=ide, JDS=jds,JDE=jde, KDS=kds,K	                 ,IDS=ids,IDE=ide, JDS=jds,JDE=jde, KDS=kds,K
                 ,IMS=ims,IME=ime, JMS=jms,JME=jme, KMS=kms,K	                 ,IMS=ims,IME=ime, JMS=jms,JME=jme, KMS=kms,K
                 ,ITS=its,ITE=ite, JTS=jts,JTE=jte, KTS=kts,K	                 ,ITS=its,ITE=ite, JTS=jts,JTE=jte, KTS=kts,K
                                                              |	                 ,coszen=coszen                              
             ELSE						             ELSE
                CALL wrf_error_fatal ( 'arguments not present	                CALL wrf_error_fatal ( 'arguments not present
             ENDIF						             ENDIF
             DO j=jts,jte					             DO j=jts,jte
             DO k=kts,kte					             DO k=kts,kte
             DO i=its,ite					             DO i=its,ite
                RTHRATEN(I,K,J)=RTHRATEN(I,K,J)+RTHRATENSW(I,	                RTHRATEN(I,K,J)=RTHRATEN(I,K,J)+RTHRATENSW(I,
             ENDDO						             ENDDO
             ENDDO						             ENDDO
             ENDDO						             ENDDO

        CASE (RRTMG_SWSCHEME)					        CASE (RRTMG_SWSCHEME)
             CALL wrf_debug(100, 'CALL rrtmg_sw')		             CALL wrf_debug(100, 'CALL rrtmg_sw')
             CALL RRTMG_SWRAD(                               	             CALL RRTMG_SWRAD(                               
                     RTHRATENSW=RTHRATENSW,                  	                     RTHRATENSW=RTHRATENSW,                  
                     SWUPT=SWUPT,SWUPTC=SWUPTC,              	                     SWUPT=SWUPT,SWUPTC=SWUPTC,              
                     SWDNT=SWDNT,SWDNTC=SWDNTC,              	                     SWDNT=SWDNT,SWDNTC=SWDNTC,              
                     SWUPB=SWUPB,SWUPBC=SWUPBC,              	                     SWUPB=SWUPB,SWUPBC=SWUPBC,              
                     SWDNB=SWDNB,SWDNBC=SWDNBC,              	                     SWDNB=SWDNB,SWDNBC=SWDNBC,              
                     SWCF=SWCF,GSW=GSW,                      	                     SWCF=SWCF,GSW=GSW,                      
                     XTIME=XTIME,GMT=GMT,XLAT=XLAT,XLONG=XLON	                     XTIME=XTIME,GMT=GMT,XLAT=XLAT,XLONG=XLON
                     RADT=RADT,DEGRAD=DEGRAD,DECLIN=DECLIN,  	                     RADT=RADT,DEGRAD=DEGRAD,DECLIN=DECLIN,  
                     COSZR=COSZR,JULDAY=JULDAY,SOLCON=SOLCON,	                     COSZR=COSZR,JULDAY=JULDAY,SOLCON=SOLCON,
                     ALBEDO=ALBEDO,t3d=t,t8w=t8w,TSK=TSK,    	                     ALBEDO=ALBEDO,t3d=t,t8w=t8w,TSK=TSK,    
                     p3d=p,p8w=p8w,pi3d=pi,rho3d=rho,        	                     p3d=p,p8w=p8w,pi3d=pi,rho3d=rho,        
                     dz8w=dz8w,CLDFRA3D=CLDFRA,              	                     dz8w=dz8w,CLDFRA3D=CLDFRA,              
                     LRADIUS=lradius, IRADIUS=iradius,        |	#if (EM_CORE == 1)
                     IS_CAMMGMP_USED=is_cammgmp_used,         |	                     LRADIUS=lradius, IRADIUS=iradius,       
                     R=R_D,G=G,                               |	#endif
							      >	                     IS_CAMMGMP_USED=is_cammgmp_used,        
							      >	                     R=R_D,G=G,              &
							      >	!ckay
							      >	!                    CLDFRA_KF3D=cldfra_KF,QC_KF3D=qc_KF,QI_K
							      >	                     ICLOUD=icloud,WARM_RAIN=warm_rain,      
							      >	                     F_ICE_PHY=F_ICE_PHY,F_RAIN_PHY=F_RAIN_PH
							      >	                     XLAND=XLAND,XICE=XICE,SNOW=SNOW,        
							      >	                     QV3D=qv,QC3D=qc,QR3D=qr,                
							      >	                     QI3D=qi,QS3D=qs,QG3D=qg,                
							      >	                     O3INPUT=O3INPUT,O33D=O3RAD,             
							      >	                     AER_OPT=AER_OPT,aerod=aerod,no_src=no_sr
							      >	                     ALSWVISDIR=alswvisdir ,ALSWVISDIF=alswvi
							      >	                     ALSWNIRDIR=alswnirdir ,ALSWNIRDIF=alswni
							      >	                     SWVISDIR=swvisdir ,SWVISDIF=swvisdif,   
							      >	                     SWNIRDIR=swnirdir ,SWNIRDIF=swnirdif,   
							      >	                     SF_SURFACE_PHYSICS=sf_surface_physics,  
							      >	                     F_QV=f_qv,F_QC=f_qc,F_QR=f_qr,          
							      >	                     F_QI=f_qi,F_QS=f_qs,F_QG=f_qg,          
							      >	                     RE_CLOUD=re_cloud,RE_ICE=re_ice,RE_SNOW=
							      >	                     has_reqc=has_reqc,has_reqi=has_reqi,has_
							      >	#if ( WRF_CHEM == 1 )
							      >	                     TAUAER300=tauaer300,TAUAER400=tauaer400,
							      >	                     TAUAER600=tauaer600,TAUAER999=tauaer999,
							      >	                     GAER300=gaer300,GAER400=gaer400,        
							      >	                     GAER600=gaer600,GAER999=gaer999,        
							      >	                     WAER300=waer300,WAER400=waer400,        
							      >	                     WAER600=waer600,WAER999=waer999,        
							      >	                     aer_ra_feedback=aer_ra_feedback,        
							      >	!jdfcz               progn=progn,prescribe=prescribe,        
							      >	                     progn=progn,                            
							      >	#endif
							      >	                     QNDROP3D=qndrop,F_QNDROP=f_qndrop,      
							      >	                     IDS=ids,IDE=ide, JDS=jds,JDE=jde, KDS=kd
							      >	                     IMS=ims,IME=ime, JMS=jms,JME=jme, KMS=km
							      >	                     ITS=its,ITE=ite, JTS=jts,JTE=jte, KTS=kt
							      >	                     SWUPFLX=SWUPFLX,SWUPFLXC=SWUPFLXC,      
							      >	                     SWDNFLX=SWDNFLX,SWDNFLXC=SWDNFLXC,      
							      >	                     tauaer3d_sw=tauaer_sw,                  
							      >	                     ssaaer3d_sw=ssaaer_sw,                  
							      >	                     asyaer3d_sw=asyaer_sw,                  
							      >	                     swddir=swddir,swddni=swddni,swddif=swddi
							      >	                     xcoszen=coszen,julian=julian            
							      >
							      >	             DO j=jts,jte
							      >	             DO k=kts,kte
							      >	             DO i=its,ite
							      >	                RTHRATEN(I,K,J)=RTHRATEN(I,K,J)+RTHRATENSW(I,
							      >	             ENDDO
							      >	             ENDDO
							      >	             ENDDO
							      >
							      >	        CASE (RRTMG_SWSCHEME_FAST)
							      >	             CALL wrf_debug(100, 'CALL rrtmg_sw_fast')
							      >	             CALL RRTMG_SWRAD_FAST(                          
							      >	                     RTHRATENSW=RTHRATENSW,                  
							      >	                     SWUPT=SWUPT,SWUPTC=SWUPTC,              
							      >	                     SWDNT=SWDNT,SWDNTC=SWDNTC,              
							      >	                     SWUPB=SWUPB,SWUPBC=SWUPBC,              
							      >	                     SWDNB=SWDNB,SWDNBC=SWDNBC,              
							      >	                     SWCF=SWCF,GSW=GSW,                      
							      >	                     XTIME=XTIME,GMT=GMT,XLAT=XLAT,XLONG=XLON
							      >	                     RADT=RADT,DEGRAD=DEGRAD,DECLIN=DECLIN,  
							      >	                     COSZR=COSZR,JULDAY=JULDAY,SOLCON=SOLCON,
							      >	                     ALBEDO=ALBEDO,t3d=t,t8w=t8w,TSK=TSK,    
							      >	                     p3d=p,p8w=p8w,pi3d=pi,rho3d=rho,        
							      >	                     dz8w=dz8w,CLDFRA3D=CLDFRA,              
							      >	#if (EM_CORE == 1)
							      >	                     LRADIUS=lradius, IRADIUS=iradius,       
							      >	#endif
							      >	                     IS_CAMMGMP_USED=is_cammgmp_used,        
							      >	                     R=R_D,G=G,              &
							      >	!ckay
							      >	!                    CLDFRA_KF3D=cldfra_KF,QC_KF3D=qc_KF,QI_K
                     ICLOUD=icloud,WARM_RAIN=warm_rain,      	                     ICLOUD=icloud,WARM_RAIN=warm_rain,      
                     F_ICE_PHY=F_ICE_PHY,F_RAIN_PHY=F_RAIN_PH	                     F_ICE_PHY=F_ICE_PHY,F_RAIN_PHY=F_RAIN_PH
                     XLAND=XLAND,XICE=XICE,SNOW=SNOW,        	                     XLAND=XLAND,XICE=XICE,SNOW=SNOW,        
                     QV3D=qv,QC3D=qc,QR3D=qr,                	                     QV3D=qv,QC3D=qc,QR3D=qr,                
                     QI3D=qi,QS3D=qs,QG3D=qg,                	                     QI3D=qi,QS3D=qs,QG3D=qg,                
                     O3INPUT=O3INPUT,O33D=O3RAD,             	                     O3INPUT=O3INPUT,O33D=O3RAD,             
                     AER_OPT=AER_OPT,aerod=aerod,no_src=no_sr	                     AER_OPT=AER_OPT,aerod=aerod,no_src=no_sr
                     ALSWVISDIR=alswvisdir ,ALSWVISDIF=alswvi	                     ALSWVISDIR=alswvisdir ,ALSWVISDIF=alswvi
                     ALSWNIRDIR=alswnirdir ,ALSWNIRDIF=alswni	                     ALSWNIRDIR=alswnirdir ,ALSWNIRDIF=alswni
                     SWVISDIR=swvisdir ,SWVISDIF=swvisdif,   	                     SWVISDIR=swvisdir ,SWVISDIF=swvisdif,   
                     SWNIRDIR=swnirdir ,SWNIRDIF=swnirdif,   	                     SWNIRDIR=swnirdir ,SWNIRDIF=swnirdif,   
                     SF_SURFACE_PHYSICS=sf_surface_physics,  	                     SF_SURFACE_PHYSICS=sf_surface_physics,  
                     F_QV=f_qv,F_QC=f_qc,F_QR=f_qr,          	                     F_QV=f_qv,F_QC=f_qc,F_QR=f_qr,          
                     F_QI=f_qi,F_QS=f_qs,F_QG=f_qg,          	                     F_QI=f_qi,F_QS=f_qs,F_QG=f_qg,          
                     RE_CLOUD=re_cloud,RE_ICE=re_ice,RE_SNOW=	                     RE_CLOUD=re_cloud,RE_ICE=re_ice,RE_SNOW=
                     has_reqc=has_reqc,has_reqi=has_reqi,has_	                     has_reqc=has_reqc,has_reqi=has_reqi,has_
#ifdef WRF_CHEM						      |	#if ( WRF_CHEM == 1 )
                     TAUAER300=tauaer300,TAUAER400=tauaer400,	                     TAUAER300=tauaer300,TAUAER400=tauaer400,
                     TAUAER600=tauaer600,TAUAER999=tauaer999,	                     TAUAER600=tauaer600,TAUAER999=tauaer999,
                     GAER300=gaer300,GAER400=gaer400,        	                     GAER300=gaer300,GAER400=gaer400,        
                     GAER600=gaer600,GAER999=gaer999,        	                     GAER600=gaer600,GAER999=gaer999,        
                     WAER300=waer300,WAER400=waer400,        	                     WAER300=waer300,WAER400=waer400,        
                     WAER600=waer600,WAER999=waer999,        	                     WAER600=waer600,WAER999=waer999,        
                     aer_ra_feedback=aer_ra_feedback,        	                     aer_ra_feedback=aer_ra_feedback,        
!jdfcz               progn=progn,prescribe=prescribe,        	!jdfcz               progn=progn,prescribe=prescribe,        
                     progn=progn,                            	                     progn=progn,                            
#endif								#endif
                     QNDROP3D=qndrop,F_QNDROP=f_qndrop,      	                     QNDROP3D=qndrop,F_QNDROP=f_qndrop,      
                     IDS=ids,IDE=ide, JDS=jds,JDE=jde, KDS=kd	                     IDS=ids,IDE=ide, JDS=jds,JDE=jde, KDS=kd
                     IMS=ims,IME=ime, JMS=jms,JME=jme, KMS=km	                     IMS=ims,IME=ime, JMS=jms,JME=jme, KMS=km
                     ITS=its,ITE=ite, JTS=jts,JTE=jte, KTS=kt	                     ITS=its,ITE=ite, JTS=jts,JTE=jte, KTS=kt
                     SWUPFLX=SWUPFLX,SWUPFLXC=SWUPFLXC,      	                     SWUPFLX=SWUPFLX,SWUPFLXC=SWUPFLXC,      
                     SWDNFLX=SWDNFLX,SWDNFLXC=SWDNFLXC,      	                     SWDNFLX=SWDNFLX,SWDNFLXC=SWDNFLXC,      
                     swddir=swddir,swddni=swddni,swddif=swddi |	                     tauaer3d_sw=tauaer_sw,                  
                     xcoszen=coszen,julian=julian             |	                     ssaaer3d_sw=ssaaer_sw,                  
							      >	                     asyaer3d_sw=asyaer_sw,                  
							      >	                     swddir=swddir,swddni=swddni,swddif=swddi
							      >	                     xcoszen=coszen,julian=julian            

             DO j=jts,jte					             DO j=jts,jte
             DO k=kts,kte					             DO k=kts,kte
             DO i=its,ite					             DO i=its,ite
                RTHRATEN(I,K,J)=RTHRATEN(I,K,J)+RTHRATENSW(I,	                RTHRATEN(I,K,J)=RTHRATEN(I,K,J)+RTHRATENSW(I,
             ENDDO						             ENDDO
             ENDDO						             ENDDO
             ENDDO						             ENDDO

        CASE (GFDLSWSCHEME)					        CASE (GFDLSWSCHEME)

             CALL wrf_debug (100, 'CALL gfdlsw')		             CALL wrf_debug (100, 'CALL gfdlsw')

             IF ( PRESENT(F_QV) .AND. PRESENT(F_QC) .AND.    	             IF ( PRESENT(F_QV) .AND. PRESENT(F_QC) .AND.    
                  PRESENT(F_QS) .AND. PRESENT(qs)   .AND.    	                  PRESENT(F_QS) .AND. PRESENT(qs)   .AND.    
                  PRESENT(qv)   .AND. PRESENT(qc) ) THEN	                  PRESENT(qv)   .AND. PRESENT(qc) ) THEN
               IF ( F_QV .AND. F_QC .AND. F_QS ) THEN		               IF ( F_QV .AND. F_QC .AND. F_QS ) THEN
                 gfdl_sw = .true.				                 gfdl_sw = .true.
                 CALL ETARA(                                 	                 CALL ETARA(                                 
                  DT=dt,XLAND=xland                          	                  DT=dt,XLAND=xland                          
                 ,P8W=p8w,DZ8W=dz8w,RHO_PHY=rho,P_PHY=p,T=t  	                 ,P8W=p8w,DZ8W=dz8w,RHO_PHY=rho,P_PHY=p,T=t  
                 ,QV=qv,QW=qc_temp,QI=qi,QS=qs               	                 ,QV=qv,QW=qc_temp,QI=qi,QS=qs               
                 ,TSK2D=tsk,GLW=GLW,RSWIN=SWDOWN,GSW=GSW     	                 ,TSK2D=tsk,GLW=GLW,RSWIN=SWDOWN,GSW=GSW     
                 ,RSWINC=SWDOWNC,CLDFRA=CLDFRA,PI3D=pi       	                 ,RSWINC=SWDOWNC,CLDFRA=CLDFRA,PI3D=pi       
                 ,GLAT=glat,GLON=glon,HTOP=htop,HBOT=hbot    	                 ,GLAT=glat,GLON=glon,HTOP=htop,HBOT=hbot    
                 ,HBOTR=hbotr, HTOPR=htopr                   	                 ,HBOTR=hbotr, HTOPR=htopr                   
                 ,ALBEDO=albedo,CUPPT=cuppt                  	                 ,ALBEDO=albedo,CUPPT=cuppt                  
                 ,VEGFRA=vegfra,SNOW=snow,G=g,GMT=gmt        	                 ,VEGFRA=vegfra,SNOW=snow,G=g,GMT=gmt        
                 ,NSTEPRA=stepra,NPHS=nphs,ITIMESTEP=itimeste	                 ,NSTEPRA=stepra,NPHS=nphs,ITIMESTEP=itimeste
                 ,XTIME=xtime,JULIAN=julian                  	                 ,XTIME=xtime,JULIAN=julian                  
                 ,JULYR=julyr,JULDAY=julday                  	                 ,JULYR=julyr,JULDAY=julday                  
                 ,GFDL_LW=gfdl_lw,GFDL_SW=gfdl_sw            	                 ,GFDL_LW=gfdl_lw,GFDL_SW=gfdl_sw            
                 ,CFRACL=cfracl,CFRACM=cfracm,CFRACH=cfrach  	                 ,CFRACL=cfracl,CFRACM=cfracm,CFRACH=cfrach  
                 ,ACFRST=acfrst,NCFRST=ncfrst                	                 ,ACFRST=acfrst,NCFRST=ncfrst                
                 ,ACFRCV=acfrcv,NCFRCV=ncfrcv                	                 ,ACFRCV=acfrcv,NCFRCV=ncfrcv                
                 ,RSWTOA=rswtoa,RLWTOA=rlwtoa,CZMEAN=czmean  	                 ,RSWTOA=rswtoa,RLWTOA=rlwtoa,CZMEAN=czmean  
                 ,THRATEN=rthraten,THRATENLW=rthratenlw      	                 ,THRATEN=rthraten,THRATENLW=rthratenlw      
                 ,THRATENSW=rthratensw                       	                 ,THRATENSW=rthratensw                       
                 ,IDS=ids,IDE=ide, JDS=jds,JDE=jde, KDS=kds,K	                 ,IDS=ids,IDE=ide, JDS=jds,JDE=jde, KDS=kds,K
                 ,IMS=ims,IME=ime, JMS=jms,JME=jme, KMS=kms,K	                 ,IMS=ims,IME=ime, JMS=jms,JME=jme, KMS=kms,K
                 ,ITS=its,ITE=ite, JTS=jts,JTE=jte, KTS=kts,K	                 ,ITS=its,ITE=ite, JTS=jts,JTE=jte, KTS=kts,K
                                                             	                                                             
               ELSE						               ELSE
                 CALL wrf_error_fatal('Can not call ETARA (2a	                 CALL wrf_error_fatal('Can not call ETARA (2a
               ENDIF						               ENDIF
             ELSE						             ELSE
               CALL wrf_error_fatal('Can not call ETARA (2b).	               CALL wrf_error_fatal('Can not call ETARA (2b).
             ENDIF						             ENDIF

#ifdef HWRF							#ifdef HWRF
      CASE (HWRFSWSCHEME)					      CASE (HWRFSWSCHEME)

             CALL wrf_debug (100, 'CALL hwrfsw')		             CALL wrf_debug (100, 'CALL hwrfsw')

             gfdl_sw = .true.					             gfdl_sw = .true.
               CALL HWRFRA(explicit_convection=expl_conv, &	               CALL HWRFRA(explicit_convection=expl_conv, &
                        DT=dt,thraten=RTHRATEN,thratenlw=RTHR	                        DT=dt,thraten=RTHRATEN,thratenlw=RTHR
                        XLAND=xland,P8w=p8w,DZ8w=dz8w,RHO_PHY	                        XLAND=xland,P8w=p8w,DZ8w=dz8w,RHO_PHY
                        QV=qv,QW=qc_temp,QI=Qi,              	                        QV=qv,QW=qc_temp,QI=Qi,              
                        TSK2D=tsk,GLW=GLW,GSW=GSW,           	                        TSK2D=tsk,GLW=GLW,GSW=GSW,           
                        TOTSWDN=swdown,TOTLWDN=glw,RSWTOA=rsw	                        TOTSWDN=swdown,TOTLWDN=glw,RSWTOA=rsw
                        GLAT=glat,GLON=glon,HTOP=htop,HBOT=hb	                        GLAT=glat,GLON=glon,HTOP=htop,HBOT=hb
                        VEGFRA=vegfra,SNOW=snow,G=g,GMT=gmt, 	                        VEGFRA=vegfra,SNOW=snow,G=g,GMT=gmt, 
                        NSTEPRA=stepra,NPHS=nphs,itimestep=it	                        NSTEPRA=stepra,NPHS=nphs,itimestep=it
                        julyr=julyr,julday=julday,gfdl_lw=gfd	                        julyr=julyr,julday=julday,gfdl_lw=gfd
                        CFRACL=cfracl,CFRACM=cfracm,CFRACH=cf	                        CFRACL=cfracl,CFRACM=cfracm,CFRACH=cf
                        ACFRST=acfrst,NCFRST=ncfrst,ACFRCV=ac	                        ACFRST=acfrst,NCFRST=ncfrst,ACFRCV=ac
                        ids=ids,ide=ide, jds=jds,jde=jde, kds	                        ids=ids,ide=ide, jds=jds,jde=jde, kds
                        ims=ims,ime=ime, jms=jms,jme=jme, kms	                        ims=ims,ime=ime, jms=jms,jme=jme, kms
                        its=its,ite=ite, jts=jts,jte=jte, kts	                        its=its,ite=ite, jts=jts,jte=jte, kts
#endif								#endif

        CASE (0)						        CASE (0)

           ! Here in case we don't want to call a sw radiatio	           ! Here in case we don't want to call a sw radiatio
           ! For example, the Held-Suarez idealized test case	           ! For example, the Held-Suarez idealized test case
           IF (lw_physics /= HELDSUAREZ) THEN			           IF (lw_physics /= HELDSUAREZ) THEN
             WRITE( wrf_err_message , * ) &			             WRITE( wrf_err_message , * ) &
'You have selected a longwave radiation option, but not a sho	'You have selected a longwave radiation option, but not a sho
             CALL wrf_error_fatal ( wrf_err_message )		             CALL wrf_error_fatal ( wrf_err_message )
           END IF						           END IF

! -- add by Jin Kong 10/2011					! -- add by Jin Kong 10/2011
!--- the following FLGSWSCHEME is for testing only		!--- the following FLGSWSCHEME is for testing only
        CASE (FLGSWSCHEME)					        CASE (FLGSWSCHEME)
          flg_sw = .true.					          flg_sw = .true.
!--- No need to do anything since the short and long wave is 	!--- No need to do anything since the short and long wave is 
! -- end 							! -- end 

        CASE DEFAULT						        CASE DEFAULT

             WRITE( wrf_err_message , * ) 'The shortwave opti	             WRITE( wrf_err_message , * ) 'The shortwave opti
             CALL wrf_error_fatal ( wrf_err_message )		             CALL wrf_error_fatal ( wrf_err_message )

     END SELECT swrad_select    				     END SELECT swrad_select    

     IF (sw_physics .eq. goddardswscheme) THEN			     IF (sw_physics .eq. goddardswscheme) THEN
          IF ( PRESENT (tswdn) ) THEN				          IF ( PRESENT (tswdn) ) THEN
        DO j=jts,jte						        DO j=jts,jte
        DO i=its,ite						        DO i=its,ite
           tswdn(i,j) = erbe_out(i,j,5)    ! TOA SW downwelli	           tswdn(i,j) = erbe_out(i,j,5)    ! TOA SW downwelli
           tswup(i,j) = erbe_out(i,j,6)    ! TOA SW upwelling	           tswup(i,j) = erbe_out(i,j,6)    ! TOA SW upwelling
           sswdn(i,j) = erbe_out(i,j,7)    ! surface SW downw	           sswdn(i,j) = erbe_out(i,j,7)    ! surface SW downw
           sswup(i,j) = erbe_out(i,j,8)    ! surface SW upwel	           sswup(i,j) = erbe_out(i,j,8)    ! surface SW upwel
        ENDDO							        ENDDO
        ENDDO							        ENDDO
          ENDIF							          ENDIF
     ENDIF							     ENDIF

     IF (sw_physics .gt. 0 .and. .not.gfdl_sw) THEN		     IF (sw_physics .gt. 0 .and. .not.gfdl_sw) THEN
        DO j=jts,jte						        DO j=jts,jte
        DO k=kts,kte						        DO k=kts,kte
        DO i=its,ite						        DO i=its,ite
           RTHRATENSW(I,K,J)=RTHRATEN(I,K,J)-RTHRATENLW(I,K,J	           RTHRATENSW(I,K,J)=RTHRATEN(I,K,J)-RTHRATENLW(I,K,J
        ENDDO							        ENDDO
        ENDDO							        ENDDO
        ENDDO							        ENDDO

        DO j=jts,jte						        DO j=jts,jte
        DO i=its,ite						        DO i=its,ite
           SWDOWN(I,J)=GSW(I,J)/(1.-ALBEDO(I,J))		           SWDOWN(I,J)=GSW(I,J)/(1.-ALBEDO(I,J))
        ENDDO							        ENDDO
        ENDDO							        ENDDO
     ENDIF							     ENDIF

     ! jararias, 14/08/2013				      |	! jararias, 14/08/2013
     !BSINGH -  Avoid this calculation for KFCUP SCHEME also  |	     ! surface direct and diffuse SW fluxes computation. Only
     !          while computing airmass. We will avoid this c |	     ! Backup method in case sw scheme in use does not provid
     if ((sw_physics .ne. rrtmg_swscheme) .and. (sw_physics . |	     IF ((sw_physics .NE. RRTMG_SWSCHEME) .AND. (sw_physics .
        do j=jts,jte					      |	           .AND. (sw_physics .NE. FLGSWSCHEME) .AND. (sw_phys
           do i=its,ite					      |	           .AND. (sw_physics .ne. GODDARDSWSCHEME)) THEN
              ioh=solcon*coszen(i,j) ! TOA irradiance	      |	        DO j=jts,jte
              kt=swdown(i,j)/max(ioh,1e-3) ! clearness index  <
              ! Optical air mass: Rigollier et al. (2000) doi <
              airmass=exp(-ht(i,j)/8434.5)/(coszen(i,j)+ &    <
                     0.50572*((1.5707963267948966-acos(coszen <
              ! kt correction for air-mass at large sza: Pere <
              kt=kt/(0.1+1.031*exp(-1.4/(0.9+(9.4/max(airmass <
              ! Diffuse fraction: Ruiz-Arias et al. (2010) (E <
              kd=0.952-1.041*exp(-exp(2.300-4.702*kt))	      <
              swddif(i,j)=kd*swdown(i,j)		      <
              swddir(i,j)=(1.-kd)*swdown(i,j)		      <
              swddni(i,j)=swddir(i,j)/max(coszen(i,j),1e-4)   <
           end do					      <
        end do						      <
     end if						      <
							      <
       IF ( PRESENT( qc  ) .AND. PRESENT( qc_adjust ) .AND. c <
           DO j=jts,jte					      <
           DO k=kts,kte					      <
           DO i=its,ite						           DO i=its,ite
             qc(i,k,j) = qc_save(i,k,j)			      |	              IF (coszen(i,j).GT.1e-3) THEN
           ENDDO					      |	                 ioh=solcon*coszen(i,j) ! TOA irradiance
							      >	                 kt=swdown(i,j)/max(ioh,1e-3) ! clearness ind
							      >	                 ! Optical air mass: Rigollier et al. (2000) 
							      >	                 ! 10.1016/S0038-092X(99)00055-9
							      >	                 airmass=exp(-ht(i,j)/8434.5)/(coszen(i,j)+ &
							      >	                        0.50572*(asin(coszen(i,j))*57.2957795
							      >	                 ! kt correction for air-mass at large sza: P
							      >	                 ! doi: 10.1016/0038-092X(90)90036-C
							      >	                 kt=kt/(0.1+1.031*exp(-1.4/(0.9+(9.4/max(airm
							      >	                 ! Diffuse fraction: Ruiz-Arias et al. (2010)
							      >	                 ! 10.1016/j.enconman.2009.11.024
							      >	                 kd=0.952-1.041*exp(-exp(2.300-4.702*kt))
							      >	                 swddif(i,j)=kd*swdown(i,j)
							      >	                 swddir(i,j)=(1.-kd)*swdown(i,j)
							      >	                 swddni(i,j)=swddir(i,j)/max(coszen(i,j),1e-4
							      >	              ENDIF
           ENDDO						           ENDDO
           ENDDO						           ENDDO
        ENDIF							        ENDIF
        IF ( PRESENT( qi  ) .AND. PRESENT( qi_adjust ) .AND.  |	        IF ( PRESENT( qs  ) .AND. ICLOUD.eq.3) THEN
           DO j=jts,jte						           DO j=jts,jte
           DO k=kts,kte						           DO k=kts,kte
           DO i=its,ite						           DO i=its,ite
             qi(i,k,j) = qi_save(i,k,j)			      |	             qs(i,k,j) = qs_save(i,k,j)
           ENDDO						           ENDDO
           ENDDO						           ENDDO
           ENDDO						           ENDDO
        ENDIF							        ENDIF

     ! jararias, aug 2013				      |	     IF ( PRESENT( diffuse_frac ) ) THEN 
     if (swint_opt.eq.1) then				      |	         DO j=jts,jte
        do j=jts,jte					      |	         DO i=its,ite
           do i=its,ite					      |	           if (coszen(i,j).gt.1e-3) then
              if ((coszen(i,j).gt.1e-4) .and. (coszen_loc(i,j |	              diffuse_frac(i,j) = swddif(i,j)/swdown(i,j)
                 ! parameters update for DIR		      |	           else
                 if (Bx(i,j).le.0) then			      |	              diffuse_frac(i,j) = 0.
                    swddir_0 =(coszen_loc(i,j)/coszen(i,j))*s |	           endif
                    coszen_0 =coszen_loc(i,j)		      |	         ENDDO
                 else					      |	         ENDDO
                    swddir_0 =swddir_ref(i,j)		      |	      ENDIF
                    coszen_0 =coszen_ref(i,j)		      |
                 end if					      |	     IF ( PRESENT( qc  ) .AND. PRESENT( qc_cu ) ) THEN 
                 if ((coszen(i,j)/coszen_0).lt.1.) then	      |	         IF ( icloud_cu .NE. 0 ) THEN
                    bb(i,j) =log(max(1.,swddir(i,j))/max(1.,s |	         DO j=jts,jte
                 elseif ((coszen(i,j)/coszen_0).gt.1) then    |	         DO k=kts,kte
                    bb(i,j) =log(max(1.,swddir(i,j))/max(1.,s |	         DO i=its,ite
                 else					      |	           qc(i,k,j) = qc_save(i,k,j)
                    bb(i,j) =0.				      |	         ENDDO
                 end if					      |	         ENDDO
                 bb(i,j) =max(-.5,min(2.5,bb(i,j)))	      |	         ENDDO
                 Bx(i,j) =swddir(i,j)/(coszen(i,j)**bb(i,j))  |	         ENDIF
							      |	      ENDIF
                 !write(wrf_err_message,*) 'XXX I=',i,' J=',j |	      IF ( PRESENT( qi  ) .AND. PRESENT( qi_cu ) ) THEN
                 !                         '  swddir_0=',swdd |	         IF ( icloud_cu .NE. 0 ) THEN
                 !call wrf_debug(1,wrf_err_message)	      |	         DO j=jts,jte
							      |	         DO k=kts,kte
                 ! parameters update for GHI		      |	         DO i=its,ite
                 if (Gx(i,j).le.0) then			      |	           qi(i,k,j) = qi_save(i,k,j)
                    swdown_0 =(coszen_loc(i,j)/coszen(i,j))*s |	         ENDDO
                    coszen_0 =coszen_loc(i,j)		      |	         ENDDO
                 else					      |	         ENDDO
                    swdown_0 =swdown_ref(i,j)		      |	         ENDIF
                    coszen_0 =coszen_ref(i,j)		      |	      ENDIF
                 end if					      |
                 if ((coszen(i,j)/coszen_0).lt.1.) then	      |	      ! jararias, aug 2013, updated 2013/11
                    gg(i,j) =log(max(1.,swdown(i,j))/max(1.,s |	      ! parameters update for SW surface fluxes interpolation
                 elseif ((coszen(i,j)/coszen_0).gt.1) then    |	      IF (swint_opt.EQ.1) THEN
                    gg(i,j) =log(max(1.,swdown(i,j))/max(1.,s |	         ! interpolation applies on all-sky fluxes (swddir, s
                 else					      |	         CALL update_swinterp_parameters(ims,ime,jms,jme,its,
                    gg(i,j) =0.				      |	                                         coszen,coszen_loc,sw
                 end if					      |	                                         swddir_ref,bb,Bx,swd
                 gg(i,j) =max(-.5,min(2.5,gg(i,j)))	      |	                                         coszen_ref          
                 Gx(i,j) =swdown(i,j)/(coszen(i,j)**gg(i,j))  |	      ENDIF
							      <
                 ! saving last SW run in state variables      <
                 coszen_ref(i,j) =coszen(i,j)		      <
                 swdown_ref(i,j) =swdown(i,j)		      <
                 swddir_ref(i,j) =swddir(i,j)		      <
							      <
              else					      <
                 Bx(i,j) =0.				      <
                 bb(i,j) =0.				      <
                 Gx(i,j) =0.				      <
                 gg(i,j) =0.				      <
              end if					      <
							      <
              !if ((i.eq.20).and.(j.eq.20)) then	      <
              !   write(wrf_err_message,'("   RADSTEP : tn=", <
              !                           " Bx=",F14.2," bb=" <
              !                           Bx(i,j),bb(i,j)     <
              !   call wrf_debug(1,wrf_err_message)	      <
              !end if					      <

           end do					      <
        end do						      <
     end if						      <
    							      <
   ENDDO							   ENDDO
   !$OMP END PARALLEL DO					   !$OMP END PARALLEL DO

   ENDIF Radiation_step					      |	   IF ( allocated(tauaer_sw) ) deallocate(tauaer_sw)
							      >	   IF ( allocated(ssaaer_sw) ) deallocate(ssaaer_sw)
							      >	   IF ( allocated(asyaer_sw) ) deallocate(asyaer_sw)

							      >	   ENDIF Radiation_step

 ! jararias, aug 2013						 ! jararias, aug 2013
							      >	 ! SW surface fluxes interpolation (meaningful when not in a 
 if (swint_opt .eq. 1) then					 if (swint_opt .eq. 1) then
    call wrf_debug(100,'SW surface irradiance interpolation')	    call wrf_debug(100,'SW surface irradiance interpolation')

    !---------------						    !---------------
    !$OMP PARALLEL DO   &					    !$OMP PARALLEL DO   &
    !$OMP PRIVATE ( ij ,i,j,k,its,ite,jts,jte)			    !$OMP PRIVATE ( ij ,i,j,k,its,ite,jts,jte)
    do ij = 1,num_tiles						    do ij = 1,num_tiles
      its = i_start(ij)						      its = i_start(ij)
      ite = i_end(ij)						      ite = i_end(ij)
      jts = j_start(ij)						      jts = j_start(ij)
      jte = j_end(ij)						      jte = j_end(ij)
							      |	      call interp_sw_radiation(ims,ime,jms,jme,its,ite,jts,jt
      do j=jts,jte					      |	                               coszen_ref,coszen_loc,swddir_r
         do i=its,ite					      |	                               bb,Bx,swdown_ref,gg,Gx,albedo,
            ! sza interpolation of surface fluxes	      |	                               swdown,swddir,swddni,swddif,gs
            if ((coszen_ref(i,j).gt.1e-4) .and. (coszen_loc(i <
               if ((bb(i,j).eq.-0.5).or.(bb(i,j).eq.2.5)) the <
                  swddir(i,j) =(coszen_loc(i,j)/coszen_ref(i, <
               else					      <
                  swddir(i,j) =Bx(i,j)*(coszen_loc(i,j)**bb(i <
               end if					      <
               if ((gg(i,j).eq.-0.5).or.(gg(i,j).eq.2.5)) the <
                  swdown(i,j) =(coszen_loc(i,j)/coszen_ref(i, <
               else					      <
                  swdown(i,j) =Gx(i,j)*(coszen_loc(i,j)**gg(i <
               end if					      <
               swddif(i,j) =swdown(i,j)-swddir(i,j)	      <
               swddni(i,j) =swddir(i,j)/coszen_loc(i,j)	      <
               gsw(i,j)    =swdown(i,j)*(1.-albedo(i,j))      <
            else					      <
               swddir(i,j) =0.				      <
               swdown(i,j) =0.				      <
               swddif(i,j) =0.				      <
               swddni(i,j) =0.				      <
               gsw(i,j)    =0.				      <
            end if					      <
            !if ((i.eq.20).and.(j.eq.20)) then		      <
            !   write(wrf_err_message,'("NO-RADSTEP : tn=",I4 <
            !                           " Bx=",F14.2," bb=",F <
            !                           gg(i,j),swdown(i,j),G <
            !   call wrf_debug(1,wrf_err_message)	      <
            !end if					      <
         end do						      <
      end do  						      <
    enddo							    enddo
    !$OMP END PARALLEL DO					    !$OMP END PARALLEL DO
 end if								 end if

							      <
     accumulate_lw_select: SELECT CASE(lw_physics)		     accumulate_lw_select: SELECT CASE(lw_physics)

     CASE (CAMLWSCHEME,RRTMG_LWSCHEME)			      |	     CASE (CAMLWSCHEME,RRTMG_LWSCHEME,RRTMG_LWSCHEME_FAST)
   IF(PRESENT(LWUPTC))THEN					   IF(PRESENT(LWUPTC))THEN
							      >	!  NMM calls the driver every RADT time steps, EM calls every
							      >	#if (EM_CORE == 1)
							      >	   DTaccum = DT
							      >	#else
							      >	   DTaccum = RADT*60
							      >	#endif
   !$OMP PARALLEL DO   &					   !$OMP PARALLEL DO   &
   !$OMP PRIVATE ( ij ,i,j,k,its,ite,jts,jte)			   !$OMP PRIVATE ( ij ,i,j,k,its,ite,jts,jte)

   DO ij = 1 , num_tiles					   DO ij = 1 , num_tiles
     its = i_start(ij)						     its = i_start(ij)
     ite = i_end(ij)						     ite = i_end(ij)
     jts = j_start(ij)						     jts = j_start(ij)
     jte = j_end(ij)						     jte = j_end(ij)

        DO j=jts,jte						        DO j=jts,jte
        DO i=its,ite						        DO i=its,ite
           ACLWUPT(I,J) = ACLWUPT(I,J) + LWUPT(I,J)*DT	      |	           ACLWUPT(I,J) = ACLWUPT(I,J) + LWUPT(I,J)*DTaccum
           ACLWUPTC(I,J) = ACLWUPTC(I,J) + LWUPTC(I,J)*DT     |	           ACLWUPTC(I,J) = ACLWUPTC(I,J) + LWUPTC(I,J)*DTaccu
           ACLWDNT(I,J) = ACLWDNT(I,J) + LWDNT(I,J)*DT	      |	           ACLWDNT(I,J) = ACLWDNT(I,J) + LWDNT(I,J)*DTaccum
           ACLWDNTC(I,J) = ACLWDNTC(I,J) + LWDNTC(I,J)*DT     |	           ACLWDNTC(I,J) = ACLWDNTC(I,J) + LWDNTC(I,J)*DTaccu
           ACLWUPB(I,J) = ACLWUPB(I,J) + LWUPB(I,J)*DT	      |	           ACLWUPB(I,J) = ACLWUPB(I,J) + LWUPB(I,J)*DTaccum
           ACLWUPBC(I,J) = ACLWUPBC(I,J) + LWUPBC(I,J)*DT     |	           ACLWUPBC(I,J) = ACLWUPBC(I,J) + LWUPBC(I,J)*DTaccu
           ACLWDNB(I,J) = ACLWDNB(I,J) + LWDNB(I,J)*DT	      |	           ACLWDNB(I,J) = ACLWDNB(I,J) + LWDNB(I,J)*DTaccum
           ACLWDNBC(I,J) = ACLWDNBC(I,J) + LWDNBC(I,J)*DT     |	           ACLWDNBC(I,J) = ACLWDNBC(I,J) + LWDNBC(I,J)*DTaccu
        ENDDO							        ENDDO
        ENDDO							        ENDDO
   ENDDO							   ENDDO
   !$OMP END PARALLEL DO					   !$OMP END PARALLEL DO
   ENDIF							   ENDIF
     CASE DEFAULT						     CASE DEFAULT
     END SELECT accumulate_lw_select				     END SELECT accumulate_lw_select

     accumulate_sw_select: SELECT CASE(sw_physics)		     accumulate_sw_select: SELECT CASE(sw_physics)

     CASE (CAMSWSCHEME,RRTMG_SWSCHEME)			      |	     CASE (CAMSWSCHEME,RRTMG_SWSCHEME,RRTMG_SWSCHEME_FAST)
   IF(PRESENT(SWUPTC))THEN					   IF(PRESENT(SWUPTC))THEN
							      >	!  NMM calls the driver every RADT time steps, EM calls every
							      >	#if (EM_CORE == 1)
							      >	   DTaccum = DT
							      >	#else
							      >	   DTaccum = RADT*60
							      >	#endif
   !$OMP PARALLEL DO   &					   !$OMP PARALLEL DO   &
   !$OMP PRIVATE ( ij ,i,j,k,its,ite,jts,jte)			   !$OMP PRIVATE ( ij ,i,j,k,its,ite,jts,jte)

   DO ij = 1 , num_tiles					   DO ij = 1 , num_tiles
     its = i_start(ij)						     its = i_start(ij)
     ite = i_end(ij)						     ite = i_end(ij)
     jts = j_start(ij)						     jts = j_start(ij)
     jte = j_end(ij)						     jte = j_end(ij)

        DO j=jts,jte						        DO j=jts,jte
        DO i=its,ite						        DO i=its,ite
           ACSWUPT(I,J) = ACSWUPT(I,J) + SWUPT(I,J)*DT	      |	           ACSWUPT(I,J) = ACSWUPT(I,J) + SWUPT(I,J)*DTaccum
           ACSWUPTC(I,J) = ACSWUPTC(I,J) + SWUPTC(I,J)*DT     |	           ACSWUPTC(I,J) = ACSWUPTC(I,J) + SWUPTC(I,J)*DTaccu
           ACSWDNT(I,J) = ACSWDNT(I,J) + SWDNT(I,J)*DT	      |	           ACSWDNT(I,J) = ACSWDNT(I,J) + SWDNT(I,J)*DTaccum
           ACSWDNTC(I,J) = ACSWDNTC(I,J) + SWDNTC(I,J)*DT     |	           ACSWDNTC(I,J) = ACSWDNTC(I,J) + SWDNTC(I,J)*DTaccu
           ACSWUPB(I,J) = ACSWUPB(I,J) + SWUPB(I,J)*DT	      |	           ACSWUPB(I,J) = ACSWUPB(I,J) + SWUPB(I,J)*DTaccum
           ACSWUPBC(I,J) = ACSWUPBC(I,J) + SWUPBC(I,J)*DT     |	           ACSWUPBC(I,J) = ACSWUPBC(I,J) + SWUPBC(I,J)*DTaccu
           ACSWDNB(I,J) = ACSWDNB(I,J) + SWDNB(I,J)*DT	      |	           ACSWDNB(I,J) = ACSWDNB(I,J) + SWDNB(I,J)*DTaccum
           ACSWDNBC(I,J) = ACSWDNBC(I,J) + SWDNBC(I,J)*DT     |	           ACSWDNBC(I,J) = ACSWDNBC(I,J) + SWDNBC(I,J)*DTaccu
        ENDDO							        ENDDO
        ENDDO							        ENDDO
   ENDDO							   ENDDO
   !$OMP END PARALLEL DO					   !$OMP END PARALLEL DO
   ENDIF							   ENDIF

     CASE DEFAULT						     CASE DEFAULT
     END SELECT accumulate_sw_select				     END SELECT accumulate_sw_select

							      >	! compute cloud diagnosis (random overlapping)
							      >	! by ZCX
							      >	 IF ( PRESENT ( CLDFRA ) .AND. PRESENT ( CLDT ) .AND.        
							      >	      PRESENT ( F_QC ) .AND. PRESENT ( F_QI ) ) THEN
							      >
							      >	   DO ij = 1 , num_tiles
							      >	     its = i_start(ij)
							      >	     ite = i_end(ij)
							      >	     jts = j_start(ij)
							      >	     jte = j_end(ij)
							      >
							      >	        DO j=jts,jte
							      >	        DO i=its,ite
							      >	          cldji=1.0
							      >	          do k=kte-1,kts,-1
							      >	            cldji=cldji*(1.0-cldfra(i,k,j))
							      >	          enddo
							      >	          cldt(i,j)=1.0-cldji
							      >	!         cldlji=1.0
							      >	!         do k=kte-1,kts,-1
							      >	!         if(znu(k).ge.0.69) then
							      >	!           cldlji=cldlji*(1.0-cldfra(i,k,j))
							      >	!         endif
							      >	!         enddo
							      >	!         cldl(i,j)=1.0-cldlji
							      >	        END DO
							      >	        END DO
							      >	    END DO
							      >	 END IF
							      >
   END SUBROUTINE radiation_driver				   END SUBROUTINE radiation_driver

   SUBROUTINE pre_radiation_driver ( grid, config_flags      	   SUBROUTINE pre_radiation_driver ( grid, config_flags      
              ,itimestep, ra_call_offset                     	              ,itimestep, ra_call_offset                     
              ,XLAT, XLONG, GMT, julian, xtime, RADT, STEPRA 	              ,XLAT, XLONG, GMT, julian, xtime, RADT, STEPRA 
              ,ht,dx,dy,sina,cosa,shadowmask,slope_rad ,topo_	              ,ht,dx,dy,sina,cosa,shadowmask,slope_rad ,topo_
              ,shadlen,ht_shad,ht_loc                        	              ,shadlen,ht_shad,ht_loc                        
              ,ht_shad_bxs, ht_shad_bxe                      	              ,ht_shad_bxs, ht_shad_bxe                      
              ,ht_shad_bys, ht_shad_bye                      	              ,ht_shad_bys, ht_shad_bye                      
              ,nested, min_ptchsz                            	              ,nested, min_ptchsz                            
              ,spec_bdy_width                                	              ,spec_bdy_width                                
              ,ids, ide, jds, jde, kds, kde                  	              ,ids, ide, jds, jde, kds, kde                  
              ,ims, ime, jms, jme, kms, kme                  	              ,ims, ime, jms, jme, kms, kme                  
              ,ips, ipe, jps, jpe, kps, kpe                  	              ,ips, ipe, jps, jpe, kps, kpe                  
              ,i_start, i_end                                	              ,i_start, i_end                                
              ,j_start, j_end                                	              ,j_start, j_end                                
              ,kts, kte                                      	              ,kts, kte                                      
              ,num_tiles                                     	              ,num_tiles                                     

   USE module_domain  , ONLY : domain				   USE module_domain  , ONLY : domain
#ifdef DM_PARALLEL						#ifdef DM_PARALLEL
   USE module_dm        , ONLY : ntasks_x,ntasks_y,local_comm	   USE module_dm        , ONLY : ntasks_x,ntasks_y,local_comm
# if (EM_CORE == 1)						# if (EM_CORE == 1)
   USE module_comm_dm   , ONLY : halo_toposhad_sub		   USE module_comm_dm   , ONLY : halo_toposhad_sub
# endif								# endif
#endif								#endif
   USE module_bc						   USE module_bc
   USE module_model_constants					   USE module_model_constants

   IMPLICIT NONE						   IMPLICIT NONE

   INTEGER,      INTENT(IN   )    ::   ids,ide, jds,jde, kds,	   INTEGER,      INTENT(IN   )    ::   ids,ide, jds,jde, kds,
                                       ims,ime, jms,jme, kms,	                                       ims,ime, jms,jme, kms,
                                       ips,ipe, jps,jpe, kps,	                                       ips,ipe, jps,jpe, kps,
                                                         kts,	                                                         kts,
                                       num_tiles		                                       num_tiles

   TYPE(domain)                   , INTENT(INOUT)  :: grid	   TYPE(domain)                   , INTENT(INOUT)  :: grid
   TYPE(grid_config_rec_type   ) ,   INTENT(IN   ) :: config_	   TYPE(grid_config_rec_type   ) ,   INTENT(IN   ) :: config_

   INTEGER, INTENT(IN  ) :: itimestep, ra_call_offset, stepra	   INTEGER, INTENT(IN  ) :: itimestep, ra_call_offset, stepra
                            slope_rad, topo_shading,         	                            slope_rad, topo_shading,         
                            spec_bdy_width			                            spec_bdy_width

   INTEGER, INTENT(INOUT) :: min_ptchsz				   INTEGER, INTENT(INOUT) :: min_ptchsz

   INTEGER, DIMENSION(num_tiles), INTENT(IN) ::              	   INTEGER, DIMENSION(num_tiles), INTENT(IN) ::              
                i_start,i_end,j_start,j_end			                i_start,i_end,j_start,j_end

   REAL, INTENT(IN  )   :: GMT, radt, julian, xtime, dx, dy, 	   REAL, INTENT(IN  )   :: GMT, radt, julian, xtime, dx, dy, 

   REAL, DIMENSION( ims:ime, jms:jme ),                      	   REAL, DIMENSION( ims:ime, jms:jme ),                      
         INTENT(IN   )  ::                                  X	         INTENT(IN   )  ::                                  X
                                                           XL	                                                           XL
                                                             	                                                             
                                                            S	                                                            S
                                                            C	                                                            C

   REAL, DIMENSION( ims:ime, jms:jme ), INTENT(INOUT)  ::  ht	   REAL, DIMENSION( ims:ime, jms:jme ), INTENT(INOUT)  ::  ht

   REAL,  DIMENSION( jms:jme , kds:kde , spec_bdy_width ),   	   REAL,  DIMENSION( jms:jme , kds:kde , spec_bdy_width ),   
                      INTENT(IN   ) :: ht_shad_bxs, ht_shad_b	                      INTENT(IN   ) :: ht_shad_bxs, ht_shad_b
   REAL,  DIMENSION( ims:ime , kds:kde , spec_bdy_width ),   	   REAL,  DIMENSION( ims:ime , kds:kde , spec_bdy_width ),   
                      INTENT(IN   ) :: ht_shad_bys, ht_shad_b	                      INTENT(IN   ) :: ht_shad_bys, ht_shad_b

   INTEGER, DIMENSION( ims:ime, jms:jme ),                   	   INTEGER, DIMENSION( ims:ime, jms:jme ),                   
         INTENT(INOUT)  ::                            shadowm	         INTENT(INOUT)  ::                            shadowm

   LOGICAL,      INTENT(IN   )    :: nested			   LOGICAL,      INTENT(IN   )    :: nested

!Local								!Local
! For orographic shading					! For orographic shading
   INTEGER :: niter,ni,psx,psy,idum,jdum,i,j,ij			   INTEGER :: niter,ni,psx,psy,idum,jdum,i,j,ij
   REAL :: DECLIN,SOLCON					   REAL :: DECLIN,SOLCON

! Determine minimum patch size for slope-dependent radiation	! Determine minimum patch size for slope-dependent radiation
   if (itimestep .eq. 1) then					   if (itimestep .eq. 1) then
     psx = ipe-ips+1						     psx = ipe-ips+1
     psy = jpe-jps+1						     psy = jpe-jps+1
     min_ptchsz = min(psx,psy)					     min_ptchsz = min(psx,psy)
     idum = 0							     idum = 0
     jdum = 0							     jdum = 0
   endif							   endif

# ifdef DM_PARALLEL						# ifdef DM_PARALLEL
   if (itimestep .eq. 1) then					   if (itimestep .eq. 1) then
     call wrf_dm_minval_integer (psx,idum,jdum)			     call wrf_dm_minval_integer (psx,idum,jdum)
     call wrf_dm_minval_integer (psy,idum,jdum)			     call wrf_dm_minval_integer (psy,idum,jdum)
     min_ptchsz = min(psx,psy)					     min_ptchsz = min(psx,psy)
   endif							   endif
# endif								# endif

! Topographic shading						! Topographic shading
   								   
   if ((topo_shading.eq.1).and.(itimestep .eq. 1 .or. &		   if ((topo_shading.eq.1).and.(itimestep .eq. 1 .or. &
        mod(itimestep,STEPRA) .eq. 1 + ra_call_offset))  then	        mod(itimestep,STEPRA) .eq. 1 + ra_call_offset))  then

!---------------						!---------------
! Calculate constants for short wave radiation			! Calculate constants for short wave radiation
   								   
   CALL radconst(XTIME,DECLIN,SOLCON,JULIAN,DEGRAD,DPD)		   CALL radconst(XTIME,DECLIN,SOLCON,JULIAN,DEGRAD,DPD)
   								   
! Make a local copy of terrain height field			! Make a local copy of terrain height field
     do j=jms,jme						     do j=jms,jme
     do i=ims,ime						     do i=ims,ime
       ht_loc(i,j) = ht(i,j)					       ht_loc(i,j) = ht(i,j)
     enddo							     enddo
     enddo							     enddo
! Determine if iterations are necessary for shadows to propag	! Determine if iterations are necessary for shadows to propag
     if ((ids.eq.ips).and.(ide.eq.ipe).and.(jds.eq.jps).and.(	     if ((ids.eq.ips).and.(ide.eq.ipe).and.(jds.eq.jps).and.(
       niter = 1						       niter = 1
     else							     else
       niter = int(shadlen/(dx*min_ptchsz)+3)			       niter = int(shadlen/(dx*min_ptchsz)+3)
     endif							     endif



    IF( nested ) THEN						    IF( nested ) THEN

      !$OMP PARALLEL DO   &					      !$OMP PARALLEL DO   &
      !$OMP PRIVATE ( ij )					      !$OMP PRIVATE ( ij )

      DO ij = 1 , num_tiles					      DO ij = 1 , num_tiles

           CALL spec_bdyfield(ht_shad,                       	           CALL spec_bdyfield(ht_shad,                       
                               ht_shad_bxs, ht_shad_bxe,     	                               ht_shad_bxs, ht_shad_bxe,     
                               ht_shad_bys, ht_shad_bye,     	                               ht_shad_bys, ht_shad_bye,     
                               'm', config_flags, spec_bdy_wi	                               'm', config_flags, spec_bdy_wi
                               ids,ide, jds,jde, 1  ,1  ,  & 	                               ids,ide, jds,jde, 1  ,1  ,  & 
                               ims,ime, jms,jme, 1  ,1  ,  & 	                               ims,ime, jms,jme, 1  ,1  ,  & 
                               ips,ipe, jps,jpe, 1  ,1  ,  & 	                               ips,ipe, jps,jpe, 1  ,1  ,  & 
                               i_start(ij), i_end(ij),       	                               i_start(ij), i_end(ij),       
                               j_start(ij), j_end(ij),       	                               j_start(ij), j_end(ij),       
                               1    , 1             )		                               1    , 1             )
      ENDDO							      ENDDO
    ENDIF							    ENDIF

     do ni = 1, niter						     do ni = 1, niter

   !$OMP PARALLEL DO   &					   !$OMP PARALLEL DO   &
   !$OMP PRIVATE ( ij,i,j )					   !$OMP PRIVATE ( ij,i,j )
         do ij = 1 , num_tiles					         do ij = 1 , num_tiles

         call toposhad_init (ht_shad,ht_loc,                 	         call toposhad_init (ht_shad,ht_loc,                 
                       shadowmask,nested,ni,                 	                       shadowmask,nested,ni,                 
                       ids,ide, jds,jde, kds,kde,            	                       ids,ide, jds,jde, kds,kde,            
                       ims,ime, jms,jme, kms,kme,            	                       ims,ime, jms,jme, kms,kme,            
                       ips,min(ipe,ide-1), jps,min(jpe,jde-1)	                       ips,min(ipe,ide-1), jps,min(jpe,jde-1)
                       i_start(ij),min(i_end(ij), ide-1),j_st	                       i_start(ij),min(i_end(ij), ide-1),j_st
                       min(j_end(ij), jde-1), kts, kte       	                       min(j_end(ij), jde-1), kts, kte       

         enddo							         enddo
   !$OMP END PARALLEL DO					   !$OMP END PARALLEL DO


   !$OMP PARALLEL DO   &					   !$OMP PARALLEL DO   &
   !$OMP PRIVATE ( ij,i,j )					   !$OMP PRIVATE ( ij,i,j )
       do ij = 1 , num_tiles					       do ij = 1 , num_tiles

       call toposhad (xlat,xlong,sina,cosa,xtime,gmt,radt,dec	       call toposhad (xlat,xlong,sina,cosa,xtime,gmt,radt,dec
                       dx,dy,ht_shad,ht_loc,ni,              	                       dx,dy,ht_shad,ht_loc,ni,              
                       shadowmask,shadlen,                   	                       shadowmask,shadlen,                   
                       ids,ide, jds,jde, kds,kde,            	                       ids,ide, jds,jde, kds,kde,            
                       ims,ime, jms,jme, kms,kme,            	                       ims,ime, jms,jme, kms,kme,            
                       ips,min(ipe,ide-1), jps,min(jpe,jde-1)	                       ips,min(ipe,ide-1), jps,min(jpe,jde-1)
                       i_start(ij),min(i_end(ij), ide-1),j_st	                       i_start(ij),min(i_end(ij), ide-1),j_st
                       min(j_end(ij), jde-1), kts, kte       	                       min(j_end(ij), jde-1), kts, kte       

       enddo							       enddo
   !$OMP END PARALLEL DO					   !$OMP END PARALLEL DO

#if defined( DM_PARALLEL ) && (EM_CORE == 1)			#if defined( DM_PARALLEL ) && (EM_CORE == 1)
#     include "HALO_TOPOSHAD.inc"				#     include "HALO_TOPOSHAD.inc"
#endif								#endif
     enddo							     enddo
   endif							   endif

   END SUBROUTINE pre_radiation_driver				   END SUBROUTINE pre_radiation_driver

!------------------------------------------------------------	!------------------------------------------------------------
!BOP								!BOP
! !IROUTINE: radconst - compute radiation terms			! !IROUTINE: radconst - compute radiation terms
! !INTERFAC:							! !INTERFAC:
   SUBROUTINE radconst(XTIME,DECLIN,SOLCON,JULIAN,           	   SUBROUTINE radconst(XTIME,DECLIN,SOLCON,JULIAN,           
                       DEGRAD,DPD                            	                       DEGRAD,DPD                            
!------------------------------------------------------------	!------------------------------------------------------------
   USE module_wrf_error						   USE module_wrf_error
   IMPLICIT NONE						   IMPLICIT NONE
!------------------------------------------------------------	!------------------------------------------------------------

! !ARGUMENTS:							! !ARGUMENTS:
   REAL, INTENT(IN   )      ::       DEGRAD,DPD,XTIME,JULIAN	   REAL, INTENT(IN   )      ::       DEGRAD,DPD,XTIME,JULIAN
   REAL, INTENT(OUT  )      ::       DECLIN,SOLCON		   REAL, INTENT(OUT  )      ::       DECLIN,SOLCON
   REAL                     ::       OBECL,SINOB,SXLONG,ARG, 	   REAL                     ::       OBECL,SINOB,SXLONG,ARG, 
                                     DECDEG,DJUL,RJUL,ECCFAC	                                     DECDEG,DJUL,RJUL,ECCFAC
!								!
! !DESCRIPTION:							! !DESCRIPTION:
! Compute terms used in radiation physics 			! Compute terms used in radiation physics 
!EOP								!EOP

! for short wave radiation					! for short wave radiation

   DECLIN=0.							   DECLIN=0.
   SOLCON=0.							   SOLCON=0.

!-----OBECL : OBLIQUITY = 23.5 DEGREE.				!-----OBECL : OBLIQUITY = 23.5 DEGREE.
        							        
   OBECL=23.5*DEGRAD						   OBECL=23.5*DEGRAD
   SINOB=SIN(OBECL)						   SINOB=SIN(OBECL)
        							        
!-----CALCULATE LONGITUDE OF THE SUN FROM VERNAL EQUINOX:	!-----CALCULATE LONGITUDE OF THE SUN FROM VERNAL EQUINOX:
        							        
   IF(JULIAN.GE.80.)SXLONG=DPD*(JULIAN-80.)			   IF(JULIAN.GE.80.)SXLONG=DPD*(JULIAN-80.)
   IF(JULIAN.LT.80.)SXLONG=DPD*(JULIAN+285.)			   IF(JULIAN.LT.80.)SXLONG=DPD*(JULIAN+285.)
   SXLONG=SXLONG*DEGRAD						   SXLONG=SXLONG*DEGRAD
   ARG=SINOB*SIN(SXLONG)					   ARG=SINOB*SIN(SXLONG)
   DECLIN=ASIN(ARG)						   DECLIN=ASIN(ARG)
   DECDEG=DECLIN/DEGRAD						   DECDEG=DECLIN/DEGRAD
!----SOLAR CONSTANT ECCENTRICITY FACTOR (PALTRIDGE AND PLATT 	!----SOLAR CONSTANT ECCENTRICITY FACTOR (PALTRIDGE AND PLATT 
   DJUL=JULIAN*360./365.					   DJUL=JULIAN*360./365.
   RJUL=DJUL*DEGRAD						   RJUL=DJUL*DEGRAD
   ECCFAC=1.000110+0.034221*COS(RJUL)+0.001280*SIN(RJUL)+0.00	   ECCFAC=1.000110+0.034221*COS(RJUL)+0.001280*SIN(RJUL)+0.00
          COS(2*RJUL)+0.000077*SIN(2*RJUL)			          COS(2*RJUL)+0.000077*SIN(2*RJUL)
   SOLCON=1370.*ECCFAC						   SOLCON=1370.*ECCFAC
   								   
   END SUBROUTINE radconst					   END SUBROUTINE radconst


   SUBROUTINE calc_coszen(ims,ime,jms,jme,its,ite,jts,jte,  &	   SUBROUTINE calc_coszen(ims,ime,jms,jme,its,ite,jts,jte,  &
                          julian,xtime,gmt, &			                          julian,xtime,gmt, &
                          declin,degrad,xlon,xlat,coszen,hran	                          declin,degrad,xlon,xlat,coszen,hran
       ! Added Equation of Time correction : jararias, 2013/0	       ! Added Equation of Time correction : jararias, 2013/0
       implicit none						       implicit none
       integer, intent(in) :: ims,ime,jms,jme,its,ite,jts,jte	       integer, intent(in) :: ims,ime,jms,jme,its,ite,jts,jte
       real, intent(in)    :: julian,declin,xtime,gmt,degrad	       real, intent(in)    :: julian,declin,xtime,gmt,degrad
       real, dimension(ims:ime,jms:jme), intent(in)    :: xla	       real, dimension(ims:ime,jms:jme), intent(in)    :: xla
       real, dimension(ims:ime,jms:jme), intent(inout) :: cos	       real, dimension(ims:ime,jms:jme), intent(inout) :: cos

       integer :: i,j						       integer :: i,j
       real    :: da,eot,xt24,tloctm,xxlat			       real    :: da,eot,xt24,tloctm,xxlat

       da=6.2831853071795862*(julian-1)/365.			       da=6.2831853071795862*(julian-1)/365.
       eot=(0.000075+0.001868*cos(da)-0.032077*sin(da) &	       eot=(0.000075+0.001868*cos(da)-0.032077*sin(da) &
            -0.014615*cos(2*da)-0.04089*sin(2*da))*(229.18)	            -0.014615*cos(2*da)-0.04089*sin(2*da))*(229.18)
       xt24=mod(xtime,1440.)+eot				       xt24=mod(xtime,1440.)+eot
       do j=jts,jte						       do j=jts,jte
          do i=its,ite						          do i=its,ite
             tloctm=gmt+xt24/60.+xlon(i,j)/15.			             tloctm=gmt+xt24/60.+xlon(i,j)/15.
             hrang(i,j)=15.*(tloctm-12.)*degrad			             hrang(i,j)=15.*(tloctm-12.)*degrad
             xxlat=xlat(i,j)*degrad				             xxlat=xlat(i,j)*degrad
             coszen(i,j)=sin(xxlat)*sin(declin) &		             coszen(i,j)=sin(xxlat)*sin(declin) &
                        +cos(xxlat)*cos(declin) *cos(hrang(i,	                        +cos(xxlat)*cos(declin) *cos(hrang(i,
          enddo							          enddo
       enddo							       enddo
   END SUBROUTINE calc_coszen					   END SUBROUTINE calc_coszen

							      >	   subroutine update_swinterp_parameters(ims,ime,jms,jme,its,
							      >	                                         coszen,coszen_loc,sw
							      >	                                         swddir_ref,bb,Bx,   
							      >	                                         swdown_ref,gg,Gx,   
							      >	                                         coszen_ref          
							      >	      ! Author: jararias 2013/11
							      >	      implicit None
							      >	      integer, intent(in) :: ims,ime,jms,jme,its,ite,jts,jte
							      >	      real, dimension(ims:ime,jms:jme), intent(in)    :: cosz
							      >	      real, dimension(ims:ime,jms:jme), intent(inout) :: swdd
							      >	                                                         swdo
							      >	                                                         cosz
							      >
							      >	      integer :: i,j
							      >	      real :: swddir_0,swdown_0,coszen_0
							      >	      real, parameter :: coszen_min=1e-4
							      >
							      >	      do j=jts,jte
							      >	         do i=its,ite
							      >	            if ((coszen(i,j).gt.coszen_min) .and. (coszen_loc
							      >	               ! parameters update for DIR
							      >	               if (Bx(i,j).le.0) then
							      >	                  swddir_0 =(coszen_loc(i,j)/coszen(i,j))*swd
							      >	                  coszen_0 =coszen_loc(i,j)
							      >	               else
							      >	                  swddir_0 =swddir_ref(i,j)
							      >	                  coszen_0 =coszen_ref(i,j)
							      >	               end if
							      >	               if ((coszen(i,j)/coszen_0).lt.1.) then
							      >	                  bb(i,j) =log(max(1.,swddir(i,j))/max(1.,swd
							      >	               elseif ((coszen(i,j)/coszen_0).gt.1) then
							      >	                  bb(i,j) =log(max(1.,swddir(i,j))/max(1.,swd
							      >	               else
							      >	                  bb(i,j) =0.
							      >	               end if
							      >	               bb(i,j) =max(-.5,min(2.5,bb(i,j)))
							      >	               Bx(i,j) =swddir(i,j)/(coszen(i,j)**bb(i,j))

							      >	               !write(wrf_err_message,*) 'XXX I=',i,' J=',j,'
							      >	               !                         '  swddir_0=',swddir
							      >	               !call wrf_debug(1,wrf_err_message)
							      >
							      >	               ! parameters update for GHI
							      >	               if (Gx(i,j).le.0) then
							      >	                  swdown_0 =(coszen_loc(i,j)/coszen(i,j))*swd
							      >	                  coszen_0 =coszen_loc(i,j)
							      >	               else
							      >	                  swdown_0 =swdown_ref(i,j)
							      >	                  coszen_0 =coszen_ref(i,j)
							      >	               end if
							      >	               if ((coszen(i,j)/coszen_0).lt.1.) then
							      >	                  gg(i,j) =log(max(1.,swdown(i,j))/max(1.,swd
							      >	               elseif ((coszen(i,j)/coszen_0).gt.1) then
							      >	                  gg(i,j) =log(max(1.,swdown(i,j))/max(1.,swd
							      >	               else
							      >	                  gg(i,j) =0.
							      >	               end if
							      >	               gg(i,j) =max(-.5,min(2.5,gg(i,j)))
							      >	               Gx(i,j) =swdown(i,j)/(coszen(i,j)**gg(i,j))
							      >	            else
							      >	               Bx(i,j) =0.
							      >	               bb(i,j) =0.
							      >	               Gx(i,j) =0.
							      >	               gg(i,j) =0.
							      >	            end if
							      >
							      >	            ! saving last SW run in state variables
							      >	            coszen_ref(i,j) =coszen(i,j)
							      >	            swdown_ref(i,j) =swdown(i,j)
							      >	            swddir_ref(i,j) =swddir(i,j)
							      >
							      >	            !if ((i.eq.20).and.(j.eq.20)) then
							      >	            !   write(wrf_err_message,'("   RADSTEP : tn=",I4
							      >	            !                           " Bx=",F14.2," bb=",F
							      >	            !                           Bx(i,j),bb(i,j)
							      >	            !   call wrf_debug(1,wrf_err_message)
							      >	            !end if
							      >
							      >	         end do
							      >	      end do
							      >
							      >	   end subroutine update_swinterp_parameters
							      >
							      >	   subroutine interp_sw_radiation(ims,ime,jms,jme,its,ite,jts
							      >	                                  coszen_ref,coszen_loc,swddi
							      >	                                  bb,Bx,swdown_ref,gg,Gx,albe
							      >	                                  swdown,swddir,swddni,swddif
							      >	      ! Author: jararias 2013/11
							      >	      implicit None
							      >	      integer, intent(in) :: ims,ime,jms,jme,its,ite,jts,jte
							      >	      real, dimension(ims:ime,jms:jme), intent(in) :: coszen_
							      >	                                                      swddir_
							      >	                                                      swdown_
							      >	                                                      albedo
							      >
							      >	      real, dimension(ims:ime,jms:jme), intent(inout) :: swdd
							      >	                                                         swdd
							      >
							      >	      integer :: i,j
							      >	      real, parameter :: coszen_min=1e-4
							      >
							      >	      do j=jts,jte
							      >	         do i=its,ite
							      >	            ! sza interpolation of surface fluxes
							      >	            if ((coszen_ref(i,j).gt.coszen_min) .and. (coszen
							      >	               if ((bb(i,j).eq.-0.5).or.(bb(i,j).eq.2.5)) the
							      >	                  swddir(i,j) =(coszen_loc(i,j)/coszen_ref(i,
							      >	               else
							      >	                  swddir(i,j) =Bx(i,j)*(coszen_loc(i,j)**bb(i
							      >	               end if
							      >	               if ((gg(i,j).eq.-0.5).or.(gg(i,j).eq.2.5)) the
							      >	                  swdown(i,j) =(coszen_loc(i,j)/coszen_ref(i,
							      >	               else
							      >	                  swdown(i,j) =Gx(i,j)*(coszen_loc(i,j)**gg(i
							      >	               end if
							      >	               swddif(i,j) =swdown(i,j)-swddir(i,j)
							      >	               swddni(i,j) =swddir(i,j)/coszen_loc(i,j)
							      >	               gsw(i,j)    =swdown(i,j)*(1.-albedo(i,j))
							      >	            else
							      >	               swddir(i,j) =0.
							      >	               swdown(i,j) =0.
							      >	               swddif(i,j) =0.
							      >	               swddni(i,j) =0.
							      >	               gsw(i,j)    =0.
							      >	            end if
							      >	         end do
							      >	      end do
							      >	   end subroutine interp_sw_radiation

!------------------------------------------------------------	!------------------------------------------------------------
!BOP								!BOP
! !IROUTINE: cal_cldfra - Compute cloud fraction	      |	! !IROUTINE: cal_cldfra2 - Compute cloud fraction
! !INTERFACE:							! !INTERFACE:
   SUBROUTINE cal_cldfra(CLDFRA,QC,QI,F_QC,F_QI,              |	   SUBROUTINE cal_cldfra2(CLDFRA,QC,QI,F_QC,F_QI,            
          !BSINGH - For WRFCuP scheme			      <
          cu_physics,shallowcu_forced_ra,                     <
          cubot,cutop,shall,cupflag,cldfra_cup,               <
          !BSINGH - ENDS				      <
          ids,ide, jds,jde, kds,kde,                         	          ids,ide, jds,jde, kds,kde,                         
          ims,ime, jms,jme, kms,kme,                         	          ims,ime, jms,jme, kms,kme,                         
          its,ite, jts,jte, kts,kte                          	          its,ite, jts,jte, kts,kte                          
     USE module_state_description, ONLY : KFCUPSCHEME, KFETAS <
!------------------------------------------------------------	!------------------------------------------------------------
   IMPLICIT NONE						   IMPLICIT NONE
!------------------------------------------------------------	!------------------------------------------------------------
   INTEGER,  INTENT(IN   ), optional ::   cu_physics          <
   INTEGER,  INTENT(IN   )   ::           ids,ide, jds,jde, k	   INTEGER,  INTENT(IN   )   ::           ids,ide, jds,jde, k
                                          ims,ime, jms,jme, k	                                          ims,ime, jms,jme, k
                                          its,ite, jts,jte, k	                                          its,ite, jts,jte, k

!								!
   REAL, DIMENSION( ims:ime, kms:kme, jms:jme ), INTENT(OUT  	   REAL, DIMENSION( ims:ime, kms:kme, jms:jme ), INTENT(OUT  
                                                             	                                                             
   !BSINGH - For WRFCuP scheme				      <
   REAL, DIMENSION( ims:ime, jms:jme ), INTENT(IN   ),optiona <
                                                              <
                                                              <
                                                              <
   !BSINGH - ENDS					      <

   REAL, DIMENSION( ims:ime, kms:kme, jms:jme ), INTENT(IN   	   REAL, DIMENSION( ims:ime, kms:kme, jms:jme ), INTENT(IN   
                                                             	                                                             
                                                             	                                                             
   !BSINGH - For WRFCuP scheme				      <
   REAL, DIMENSION( ims:ime, kms:kme, jms:jme ), INTENT(INOUT <
                                                         cldf <
							      <
   LOGICAL,DIMENSION(ims:ime, jms:jme), INTENT(IN),optional : <
							      <
   LOGICAL,INTENT(IN),optional ::                        shal <
   !BSINGH - ENDS					      <

   LOGICAL,INTENT(IN) :: F_QC,F_QI				   LOGICAL,INTENT(IN) :: F_QC,F_QI

   REAL thresh							   REAL thresh
   INTEGER:: i,j,k						   INTEGER:: i,j,k
! !DESCRIPTION:							! !DESCRIPTION:
! Compute cloud fraction from input ice and cloud water field	! Compute cloud fraction from input ice and cloud water field
! if provided.							! if provided.
!								!
! Whether QI or QC is active or not is determined from the in	! Whether QI or QC is active or not is determined from the in
! the fields into the 4D scalar arrays in WRF. These indices 	! the fields into the 4D scalar arrays in WRF. These indices 
! P_QI and P_QC, respectively, and they are passed in to the 	! P_QI and P_QC, respectively, and they are passed in to the 
! to enable testing to see if QI and QC represent active fiel	! to enable testing to see if QI and QC represent active fiel
! the moisture 4D scalar array carried by WRF.			! the moisture 4D scalar array carried by WRF.
!								!
! If a field is active its index will have a value greater th	! If a field is active its index will have a value greater th
! equal to PARAM_FIRST_SCALAR, which is also an input argumen	! equal to PARAM_FIRST_SCALAR, which is also an input argumen
! this routine.							! this routine.
!EOP								!EOP
!------------------------------------------------------------	!------------------------------------------------------------
     thresh=1.0e-6						     thresh=1.0e-6

     IF ( f_qi .AND. f_qc ) THEN				     IF ( f_qi .AND. f_qc ) THEN
        DO j = jts,jte						        DO j = jts,jte
        DO k = kts,kte						        DO k = kts,kte
        DO i = its,ite						        DO i = its,ite
           IF ( QC(i,k,j)+QI(I,k,j) .gt. thresh) THEN		           IF ( QC(i,k,j)+QI(I,k,j) .gt. thresh) THEN
              CLDFRA(i,k,j)=1.					              CLDFRA(i,k,j)=1.
           ELSE							           ELSE
              CLDFRA(i,k,j)=0.					              CLDFRA(i,k,j)=0.
           ENDIF						           ENDIF
        ENDDO							        ENDDO
        ENDDO							        ENDDO
        ENDDO							        ENDDO
     ELSE IF ( f_qc ) THEN					     ELSE IF ( f_qc ) THEN
        DO j = jts,jte						        DO j = jts,jte
        DO k = kts,kte						        DO k = kts,kte
        DO i = its,ite						        DO i = its,ite
           IF ( QC(i,k,j) .gt. thresh) THEN			           IF ( QC(i,k,j) .gt. thresh) THEN
              CLDFRA(i,k,j)=1.					              CLDFRA(i,k,j)=1.
           ELSE							           ELSE
              CLDFRA(i,k,j)=0.					              CLDFRA(i,k,j)=0.
           ENDIF						           ENDIF
        ENDDO							        ENDDO
        ENDDO							        ENDDO
        ENDDO							        ENDDO
     ELSE							     ELSE
        DO j = jts,jte						        DO j = jts,jte
        DO k = kts,kte						        DO k = kts,kte
        DO i = its,ite						        DO i = its,ite
           CLDFRA(i,k,j)=0.					           CLDFRA(i,k,j)=0.
        ENDDO							        ENDDO
        ENDDO							        ENDDO
        ENDDO							        ENDDO
     ENDIF							     ENDIF

							      |	   END SUBROUTINE cal_cldfra2
     !BSINGH - For WRFCuP scheme     			      <
     !BSINGH -  Assuming if 'cu_physics' is present then othe <
     if(present(cu_physics)) then !**BALLI added to this to a <
        !wig, 28-Sep-2006 begin:			      <
        ! Force cloud fraction if cumulus triggered.	      <
        if( cu_physics == KFCUPSCHEME ) then		      <
           DO j = jts,jte				      <
              DO k = kts,kte				      <
                 DO i = its,ite				      <
                    if( k >= int(cubot(i,j)) .and. k <= int(c <
                       CLDFRA(i,k,j) = cldfra_cup(i,k,j)      <
                       print*,'cldfra=cldfra_cup',CLDFRA(i,k, <
                    else if( shall(i,j) .gt. 1) then       !! <
                       cldfra_cup(i,k,j) = 0.0		      <
                    end if				      <
                 ENDDO					      <
              ENDDO					      <
           ENDDO					      <
        end if						      <
        						      <
        !						      <
        ! Override the cloud fraction values calculated above <
        ! convection triggered. For shallow convection, use a <
        ! cloud fraction. In this case, the median value for  <
        ! at the ARM SGP site, 36%, Berg et al. 2008, J. Clim <
        !						      <
        if( shallowcu_forced_ra ) then			      <
           select case (cu_physics)			      <
           case (KFCUPSCHEME, KFETASCHEME)		      <
              if( shall(i,j) == 1           &  ! 1=Shallow Cu <
                   .AND. k >= cubot(i,j)    &		      <
                   .AND. k <= cutop(i,j)  ) &		      <
                   cldfra(i,k,j) = max(0.36, cldfra(i,k,j)) ! <
           end select					      <
        end if     					      <
     ! End: wig, 4-Feb-2008				      <
     endif						      <
     !BSINGH -ENDS					      <
     							      <
							      <
							      <
   END SUBROUTINE cal_cldfra				      <

!BOP								!BOP
! !IROUTINE: cal_cldfra2 - Compute cloud fraction	      |	! !IROUTINE: cal_cldfra1 - Compute cloud fraction
! !INTERFACE:							! !INTERFACE:
! cal_cldfra_xr - Compute cloud fraction.			! cal_cldfra_xr - Compute cloud fraction.
! Code adapted from that in module_ra_gfdleta.F in WRF_v2.0.3	! Code adapted from that in module_ra_gfdleta.F in WRF_v2.0.3
!!								!!
!!---  Cloud fraction parameterization follows Xu and Randall	!!---  Cloud fraction parameterization follows Xu and Randall
!!     (see Hong et al., 1998)					!!     (see Hong et al., 1998)
!!     (modified by Ferrier, Feb '02)				!!     (modified by Ferrier, Feb '02)
!								!
   SUBROUTINE cal_cldfra2(CLDFRA, QV, QC, QI, QS,             |	   SUBROUTINE cal_cldfra1(CLDFRA, QV, QC, QI, QS,            
                         F_QV, F_QC, F_QI, F_QS, t_phy, p_phy	                         F_QV, F_QC, F_QI, F_QS, t_phy, p_phy
                         F_ICE_PHY,F_RAIN_PHY,               	                         F_ICE_PHY,F_RAIN_PHY,               
                         !BSINGH - For WRFCuP scheme	      <
                         cubot, cutop, shall,                 <
                         cupflag, cldfra_cup,                 <
                         cu_physics, shallowcu_forced_ra,     <
                         !BSINGH -ENDS			      <
          ids,ide, jds,jde, kds,kde,                         	          ids,ide, jds,jde, kds,kde,                         
          ims,ime, jms,jme, kms,kme,                         	          ims,ime, jms,jme, kms,kme,                         
          its,ite, jts,jte, kts,kte                          	          its,ite, jts,jte, kts,kte                          
!------------------------------------------------------------	!------------------------------------------------------------
   USE module_state_description, ONLY : KFCUPSCHEME, KFETASCH <
   IMPLICIT NONE						   IMPLICIT NONE
!------------------------------------------------------------	!------------------------------------------------------------
							      <
   INTEGER,  INTENT(IN   )   ::           cu_physics !BSINGH  <
							      <
   INTEGER,  INTENT(IN   )   ::           ids,ide, jds,jde, k	   INTEGER,  INTENT(IN   )   ::           ids,ide, jds,jde, k
                                          ims,ime, jms,jme, k	                                          ims,ime, jms,jme, k
                                          its,ite, jts,jte, k	                                          its,ite, jts,jte, k

!								!
   REAL, DIMENSION( ims:ime, kms:kme, jms:jme ), INTENT(OUT  	   REAL, DIMENSION( ims:ime, kms:kme, jms:jme ), INTENT(OUT  
                                                             	                                                             

   REAL, DIMENSION( ims:ime, kms:kme, jms:jme ), INTENT(IN   	   REAL, DIMENSION( ims:ime, kms:kme, jms:jme ), INTENT(IN   
                                                             	                                                             
                                                             	                                                             
                                                             	                                                             
                                                             	                                                             
                                                             	                                                             
                                                             	                                                             
!                                                            	!                                                            
!                                                          F_	!                                                          F_
!                                                         F_R	!                                                         F_R

   REAL, DIMENSION( ims:ime, kms:kme, jms:jme ),             	   REAL, DIMENSION( ims:ime, kms:kme, jms:jme ),             
         OPTIONAL,                                           	         OPTIONAL,                                           
         INTENT(IN   ) ::                                    	         INTENT(IN   ) ::                                    
                                                          F_I	                                                          F_I
                                                         F_RA	                                                         F_RA

   !BSINGH - For WRFCuP scheme				      <
   REAL, DIMENSION( ims:ime, kms:kme, jms:jme ), INTENT(INOUT <
                                                         cldf <
   							      <
   REAL, DIMENSION( ims:ime, jms:jme ), INTENT(IN   ) ::      <
                                                              <
                                                              <
                                                              <
   							      <
   LOGICAL,DIMENSION(ims:ime, jms:jme), INTENT(IN) ::       c <
   							      <
   LOGICAL,INTENT(IN) ::                        shallowcu_for <
   !BSINGH - ENDS					      <
							      <
   LOGICAL,OPTIONAL,INTENT(IN) :: F_QC,F_QI,F_QV,F_QS		   LOGICAL,OPTIONAL,INTENT(IN) :: F_QC,F_QI,F_QV,F_QS

!  REAL thresh							!  REAL thresh
   INTEGER:: i,j,k						   INTEGER:: i,j,k
   REAL    :: RHUM, tc, esw, esi, weight, qvsw, qvsi, qvs_wei	   REAL    :: RHUM, tc, esw, esi, weight, qvsw, qvsi, qvs_wei

   REAL    ,PARAMETER :: ALPHA0=100., GAMMA=0.49, QCLDMIN=1.E	   REAL    ,PARAMETER :: ALPHA0=100., GAMMA=0.49, QCLDMIN=1.E
                                        PEXP=0.25, RHGRID=1.0	                                        PEXP=0.25, RHGRID=1.0
   REAL    , PARAMETER ::  SVP1=0.61078				   REAL    , PARAMETER ::  SVP1=0.61078
   REAL    , PARAMETER ::  SVP2=17.2693882			   REAL    , PARAMETER ::  SVP2=17.2693882
   REAL    , PARAMETER ::  SVPI2=21.8745584			   REAL    , PARAMETER ::  SVPI2=21.8745584
   REAL    , PARAMETER ::  SVP3=35.86				   REAL    , PARAMETER ::  SVP3=35.86
   REAL    , PARAMETER ::  SVPI3=7.66				   REAL    , PARAMETER ::  SVPI3=7.66
   REAL    , PARAMETER ::  SVPT0=273.15				   REAL    , PARAMETER ::  SVPT0=273.15
   REAL    , PARAMETER ::  r_d = 287.				   REAL    , PARAMETER ::  r_d = 287.
   REAL    , PARAMETER ::  r_v = 461.6				   REAL    , PARAMETER ::  r_v = 461.6
   REAL    , PARAMETER ::  ep_2=r_d/r_v				   REAL    , PARAMETER ::  ep_2=r_d/r_v
! !DESCRIPTION:							! !DESCRIPTION:
! Compute cloud fraction from input ice and cloud water field	! Compute cloud fraction from input ice and cloud water field
! if provided.							! if provided.
!								!
! Whether QI or QC is active or not is determined from the in	! Whether QI or QC is active or not is determined from the in
! the fields into the 4D scalar arrays in WRF. These indices 	! the fields into the 4D scalar arrays in WRF. These indices 
! P_QI and P_QC, respectively, and they are passed in to the 	! P_QI and P_QC, respectively, and they are passed in to the 
! to enable testing to see if QI and QC represent active fiel	! to enable testing to see if QI and QC represent active fiel
! the moisture 4D scalar array carried by WRF.			! the moisture 4D scalar array carried by WRF.
! 								! 
! If a field is active its index will have a value greater th	! If a field is active its index will have a value greater th
! equal to PARAM_FIRST_SCALAR, which is also an input argumen	! equal to PARAM_FIRST_SCALAR, which is also an input argumen
! this routine.							! this routine.
!EOP								!EOP


!------------------------------------------------------------	!------------------------------------------------------------
!---  COMPUTE GRID-SCALE CLOUD COVER FOR RADIATION		!---  COMPUTE GRID-SCALE CLOUD COVER FOR RADIATION
!     (modified by Ferrier, Feb '02)				!     (modified by Ferrier, Feb '02)
!								!
!---  Cloud fraction parameterization follows Randall, 1994	!---  Cloud fraction parameterization follows Randall, 1994
!     (see Hong et al., 1998)					!     (see Hong et al., 1998)
!------------------------------------------------------------	!------------------------------------------------------------
! Note: ep_2=287./461.6 Rd/Rv					! Note: ep_2=287./461.6 Rd/Rv
! Note: R_D=287.						! Note: R_D=287.

! Alternative calculation for critical RH for grid saturation	! Alternative calculation for critical RH for grid saturation
!     RHGRID=0.90+.08*((100.-DX)/95.)**.5			!     RHGRID=0.90+.08*((100.-DX)/95.)**.5

! Calculate saturation mixing ratio weighted according to the	! Calculate saturation mixing ratio weighted according to the
! water and ice.						! water and ice.
! Following:							! Following:
! Murray, F.W. 1966. ``On the computation of Saturation Vapor	! Murray, F.W. 1966. ``On the computation of Saturation Vapor
!    es (in mb) = 6.1078 . exp[ a . (T-273.16)/ (T-b) ]		!    es (in mb) = 6.1078 . exp[ a . (T-273.16)/ (T-b) ]
!								!
!       over ice        over water				!       over ice        over water
! a =   21.8745584      17.2693882				! a =   21.8745584      17.2693882
! b =   7.66            35.86					! b =   7.66            35.86

!------------------------------------------------------------	!------------------------------------------------------------

    DO j = jts,jte						    DO j = jts,jte
    DO k = kts,kte						    DO k = kts,kte
    DO i = its,ite						    DO i = its,ite
      tc         = t_phy(i,k,j) - SVPT0				      tc         = t_phy(i,k,j) - SVPT0
      esw     = 1000.0 * SVP1 * EXP( SVP2  * tc / ( t_phy(i,k	      esw     = 1000.0 * SVP1 * EXP( SVP2  * tc / ( t_phy(i,k
      esi     = 1000.0 * SVP1 * EXP( SVPI2 * tc / ( t_phy(i,k	      esi     = 1000.0 * SVP1 * EXP( SVPI2 * tc / ( t_phy(i,k
      QVSW = EP_2 * esw / ( p_phy(i,k,j) - esw )		      QVSW = EP_2 * esw / ( p_phy(i,k,j) - esw )
      QVSI = EP_2 * esi / ( p_phy(i,k,j) - esi )		      QVSI = EP_2 * esi / ( p_phy(i,k,j) - esi )

      IF ( PRESENT(F_QI) .and. PRESENT(F_QC) .and. PRESENT(F_	      IF ( PRESENT(F_QI) .and. PRESENT(F_QC) .and. PRESENT(F_

! mji - For MP options 2, 4, 6, 7, 8, etc. (qc = liquid, qi =	! mji - For MP options 2, 4, 6, 7, 8, etc. (qc = liquid, qi =
         IF ( F_QI .and. F_QC .and. F_QS) THEN			         IF ( F_QI .and. F_QC .and. F_QS) THEN
            QCLD = QI(i,k,j)+QC(i,k,j)+QS(i,k,j)		            QCLD = QI(i,k,j)+QC(i,k,j)+QS(i,k,j)
            IF (QCLD .LT. QCLDMIN) THEN				            IF (QCLD .LT. QCLDMIN) THEN
               weight = 0.					               weight = 0.
            ELSE						            ELSE
               weight = (QI(i,k,j)+QS(i,k,j)) / QCLD		               weight = (QI(i,k,j)+QS(i,k,j)) / QCLD
            ENDIF						            ENDIF
         ENDIF							         ENDIF

! mji - For MP options 1 and 3, (qc only)			! mji - For MP options 1 and 3, (qc only)
!  For MP=1, qc = liquid, for MP=3, qc = liquid or ice depend	!  For MP=1, qc = liquid, for MP=3, qc = liquid or ice depend
         IF ( F_QC .and. .not. F_QI .and. .not. F_QS ) THEN	         IF ( F_QC .and. .not. F_QI .and. .not. F_QS ) THEN
            QCLD = QC(i,k,j)					            QCLD = QC(i,k,j)
            IF (QCLD .LT. QCLDMIN) THEN				            IF (QCLD .LT. QCLDMIN) THEN
               weight = 0.					               weight = 0.
            ELSE						            ELSE
               if (t_phy(i,k,j) .gt. 273.15) weight = 0.	               if (t_phy(i,k,j) .gt. 273.15) weight = 0.
               if (t_phy(i,k,j) .le. 273.15) weight = 1.	               if (t_phy(i,k,j) .le. 273.15) weight = 1.
            ENDIF						            ENDIF
         ENDIF							         ENDIF

! mji - For MP option 5; (qc = liquid, qs = ice)		! mji - For MP option 5; (qc = liquid, qs = ice)
         IF ( F_QC .and. .not. F_QI .and. F_QS .and. PRESENT(	         IF ( F_QC .and. .not. F_QI .and. F_QS .and. PRESENT(

! Mixing ratios of cloud water & total ice (cloud ice + snow)	! Mixing ratios of cloud water & total ice (cloud ice + snow)
! Mixing ratios of rain are not considered in this scheme.	! Mixing ratios of rain are not considered in this scheme.
! F_ICE is fraction of ice					! F_ICE is fraction of ice
! F_RAIN is fraction of rain					! F_RAIN is fraction of rain

           QIMID = QS(i,k,j)					           QIMID = QS(i,k,j)
           QWMID = QC(i,k,j)					           QWMID = QC(i,k,j)
! old method							! old method
!           QIMID = QC(i,k,j)*F_ICE_PHY(i,k,j)			!           QIMID = QC(i,k,j)*F_ICE_PHY(i,k,j)
!           QWMID = (QC(i,k,j)-QIMID)*(1.-F_RAIN_PHY(i,k,j))	!           QWMID = (QC(i,k,j)-QIMID)*(1.-F_RAIN_PHY(i,k,j))
!								!
!--- Total "cloud" mixing ratio, QCLD.  Rain is not part of c	!--- Total "cloud" mixing ratio, QCLD.  Rain is not part of c
!    only cloud water + cloud ice + snow			!    only cloud water + cloud ice + snow
!								!
           QCLD=QWMID+QIMID					           QCLD=QWMID+QIMID
           IF (QCLD .LT. QCLDMIN) THEN				           IF (QCLD .LT. QCLDMIN) THEN
              weight = 0.					              weight = 0.
           ELSE							           ELSE
              weight = F_ICE_PHY(i,k,j)				              weight = F_ICE_PHY(i,k,j)
           ENDIF						           ENDIF
         ENDIF							         ENDIF

      ELSE							      ELSE
         CLDFRA(i,k,j)=0.					         CLDFRA(i,k,j)=0.

      ENDIF !  IF ( F_QI .and. F_QC .and. F_QS)			      ENDIF !  IF ( F_QI .and. F_QC .and. F_QS)


      QVS_WEIGHT = (1-weight)*QVSW + weight*QVSI		      QVS_WEIGHT = (1-weight)*QVSW + weight*QVSI
      RHUM=QV(i,k,j)/QVS_WEIGHT   !--- Relative humidity	      RHUM=QV(i,k,j)/QVS_WEIGHT   !--- Relative humidity
!								!
!--- Determine cloud fraction (modified from original algorit	!--- Determine cloud fraction (modified from original algorit
!								!
      !IF (QCLD .LT. QCLDMIN) THEN !BSINGH - commented out fo |	      IF (QCLD .LT. QCLDMIN) THEN
      IF (QCLD .LT. QCLDMIN .and. shall(i,j) .gt. 1) THEN ! L <
!								!
!--- Assume zero cloud fraction if there is no cloud mixing r	!--- Assume zero cloud fraction if there is no cloud mixing r
!								!
        CLDFRA(i,k,j)=0.					        CLDFRA(i,k,j)=0.
      !ELSEIF(RHUM.GE.RHGRID)THEN!BSINGH - commented out for  |	      ELSEIF(RHUM.GE.RHGRID)THEN
     ELSEIF(RHUM.GE.RHGRID .and. shall(i,j) .gt. 1) THEN !LD  <
!								!
!--- Assume cloud fraction of unity if near saturation and th	!--- Assume cloud fraction of unity if near saturation and th
!    mixing ratio is at or above the minimum threshold		!    mixing ratio is at or above the minimum threshold
!								!
        CLDFRA(i,k,j)=1.					        CLDFRA(i,k,j)=1.
      ELSE							      ELSE
!								!
!--- Adaptation of original algorithm (Randall, 1994; Zhao, 1	!--- Adaptation of original algorithm (Randall, 1994; Zhao, 1
!    modified based on assumed grid-scale saturation at RH=RH	!    modified based on assumed grid-scale saturation at RH=RH
!								!
        SUBSAT=MAX(1.E-10,RHGRID*QVS_WEIGHT-QV(i,k,j))		        SUBSAT=MAX(1.E-10,RHGRID*QVS_WEIGHT-QV(i,k,j))
        DENOM=(SUBSAT)**GAMMA					        DENOM=(SUBSAT)**GAMMA
        ARG=MAX(-6.9, -ALPHA0*QCLD/DENOM)    ! <-- EXP(-6.9)=	        ARG=MAX(-6.9, -ALPHA0*QCLD/DENOM)    ! <-- EXP(-6.9)=
! prevent negative values  (new)				! prevent negative values  (new)
        RHUM=MAX(1.E-10, RHUM)					        RHUM=MAX(1.E-10, RHUM)
        CLDFRA(i,k,j)=(RHUM/RHGRID)**PEXP*(1.-EXP(ARG))		        CLDFRA(i,k,j)=(RHUM/RHGRID)**PEXP*(1.-EXP(ARG))
!!              ARG=-1000*QCLD/(RHUM-RHGRID)			!!              ARG=-1000*QCLD/(RHUM-RHGRID)
!!              ARG=MAX(ARG, ARGMIN)				!!              ARG=MAX(ARG, ARGMIN)
!!              CLDFRA(i,k,j)=(RHUM/RHGRID)*(1.-EXP(ARG))	!!              CLDFRA(i,k,j)=(RHUM/RHGRID)*(1.-EXP(ARG))
        IF (CLDFRA(i,k,j) .LT. .01) CLDFRA(i,k,j)=0.		        IF (CLDFRA(i,k,j) .LT. .01) CLDFRA(i,k,j)=0.
							      <
        !BSINGH - For WRFCuP scheme			      <
             						      <
        ! Section aded by LKB - 5/4/09			      <
        select case (cu_physics)			      <
        case(KFCUPSCHEME)				      <
           !           if( k<=int(cutop(i,j)) .and. k >= int( <
           !!         if( k >= int(cubot(i,j)) .and. k <= int <
           if( k >= int(cubot(i,j)) .and. k <= int(cutop(i,j) <
              CLDFRA(i,k,j) = cldfra_cup(i,k,j)		      <
              !!         write(*,*) cubot(i,j),cutop(i,j),CLD <
              !!         else if( shall(i,j) .ne. 1) then     <
           else if( shall(i,j) .gt. 1) then       !! LD ;Adde <
              cldfra_cup(i,k,j) = 0.0			      <
           end if					      <
        end select        				      <
        !BSINGH -ENDS					      <
      ENDIF          !--- End IF (QCLD .LT. QCLDMIN) ...	      ENDIF          !--- End IF (QCLD .LT. QCLDMIN) ...
							      <
      !BSINGH - For WRFCuP scheme			      <
      ! Begin: wig, 4-Feb-2008				      <
      !							      <
      ! Override the cloud fraction values calculated above i <
      ! convection triggered. For shallow convection, use a r <
      ! cloud fraction. In this case, the median value for sh <
      ! at the ARM SGP site, 36%, Berg et al. 2008, J. Clim.  <
      !							      <
      if( shallowcu_forced_ra ) then			      <
         select case (cu_physics)			      <
         case (KFCUPSCHEME, KFETASCHEME)		      <
            if( shall(i,j) == 1           &  ! 1=Shallow Cu   <
                 .AND. k >= cubot(i,j)    &		      <
                 .AND. k <= cutop(i,j)  ) &		      <
                 cldfra(i,k,j) = max(0.36, cldfra(i,k,j)) ! M <
         end select					      <
      end if						      <
      ! End: wig, 4-Feb-2008				      <
      !BSINGH - ENDS					      <
							      <
							      <
    ENDDO          !--- End DO i				    ENDDO          !--- End DO i
    ENDDO          !--- End DO k				    ENDDO          !--- End DO k
    ENDDO          !--- End DO j				    ENDDO          !--- End DO j

   END SUBROUTINE cal_cldfra2				      |	   END SUBROUTINE cal_cldfra1
							      >
							      >	!+---+-------------------------------------------------------
							      >	!..Cloud fraction scheme by G. Thompson (NCAR-RAL), not inten
							      >	!.. combining with any cumulus or shallow cumulus parameteriz
							      >	!.. scheme cloud fractions.  This is intended as a stand-alon
							      >	!.. cloud fraction and is relatively good at getting widespre
							      >	!.. and stratoCu without caring whether any deep/shallow Cu p
							      >	!.. is making sub-grid-spacing clouds/precip.  Under the hood
							      >	!.. scheme follows Mocko and Cotton (1995) in applicaiton of 
							      >	!.. Sundqvist et al (1989) scheme but using a grid-scale depe
							      >	!.. RH threshold, one each for land v. ocean points based on
							      >	!.. experiences with HWRF testing.
							      >	!+---+-------------------------------------------------------
							      >	!
							      >	!+---+-------------------------------------------------------
							      >
							      >	      SUBROUTINE cal_cldfra3(CLDFRA, qv, qc, qi, qs,         
							      >	     &                 p,t,rho, XLAND, gridkm,               
							      >	     &                 ids,ide, jds,jde, kds,kde,            
							      >	     &                 ims,ime, jms,jme, kms,kme,            
							      >	     &                 its,ite, jts,jte, kts,kte)
							      >	!
							      >	      USE module_mp_thompson   , ONLY : rsif, rslf
							      >	      IMPLICIT NONE
							      >	!
							      >	      INTEGER, INTENT(IN):: ids,ide, jds,jde, kds,kde,       
							      >	     &                      ims,ime, jms,jme, kms,kme,       
							      >	     &                      its,ite, jts,jte, kts,kte
							      >
							      >	      REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(IN):: 
							      >	      REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(INOUT)
							      >	      REAL, DIMENSION(ims:ime,jms:jme), INTENT(IN):: XLAND
							      >
							      >	      REAL, DIMENSION(ims:ime,kms:kme,jms:jme), INTENT(INOUT)
							      >	      REAL, INTENT(IN):: gridkm
							      >
							      >	!..Local vars.
							      >	      REAL:: RH_00L, RH_00O, RH_00, RHI_max
							      >	      REAL, DIMENSION(ims:ime,kms:kme,jms:jme):: qvsat
							      >	      INTEGER:: i,j,k
							      >	      REAL:: TK, TC, qvsi, qvsw, RHUM
							      >	      REAL, DIMENSION(kms:kme):: qvs1d, cfr1d, T1d,          
							      >	     &                           P1d, R1d, qc1d, qi1d, qs1d
							      >
							      >	      character*512 dbg_msg
							      >	      LOGICAL:: debug_flag
							      >
							      >	!+---+
							      >
							      >	!..First cut scale-aware. Higher resolution should require cl
							      >	!.. saturated grid box for higher cloud fraction.  Simple fun
							      >	!.. chosen based on Mocko and Cotton (1995) starting point an
							      >	!.. to get near 100% RH as grid spacing moves toward 1.0km, b
							      >	!.. RH over ocean required as compared to over land.
							      >
							      >	      RH_00L = 0.839 + SQRT(1./(50.0+gridkm*gridkm*gridkm*0.5
							      >	      RH_00O = 0.879 + SQRT(1./(100.0+gridkm*gridkm))
							      >
							      >	      DO j = jts,jte
							      >	      DO k = kts,kte
							      >	      DO i = its,ite
							      >	         RHI_max = 0.0
							      >	         CLDFRA(I,K,J) = 0.0
							      >
							      >	         if (qc(i,k,j)+qi(i,k,j) .gt. 1.E-8) then
							      >	            CLDFRA(I,K,J) = 1.0
							      >	            qvsat(i,k,j) = qv(i,k,j)
							      >	         else
							      >
							      >	            TK   = t(i,k,j)
							      >	            TC   = TK - 273.16
							      >
							      >	            qvsw = rslf(P(i,k,j), TK)
							      >	            qvsi = rsif(P(i,k,j), TK)
							      >
							      >	            if (tc .ge. -12.0) then
							      >	               qvsat(i,k,j) = qvsw
							      >	            elseif (tc .lt. -30.0) then
							      >	               qvsat(i,k,j) = qvsi
							      >	            else
							      >	               qvsat(i,k,j) = qvsw - (qvsw-qvsi)*(-12.0-tc)/(
							      >	            endif
							      >	            RHUM = qv(i,k,j)/qvsat(i,k,j)
							      >
							      >	            IF ((XLAND(I,J)-1.5).GT.0.) THEN                 
							      >	               RH_00 = RH_00O
							      >	            ELSE                                             
							      >	               RH_00 = RH_00L
							      >	            ENDIF
							      >
							      >	            if (tc .ge. -12.0) then
							      >	               RHUM = MIN(0.999, RHUM)
							      >	               CLDFRA(I,K,J) = MAX(0.0, 1.0-SQRT((1.0-RHUM)/(
							      >	            elseif (tc.lt.-12..and.tc.gt.-70. .and. RHUM.gt.R
							      >	               RHI_max = MAX(RHUM+1.E-6, qvsw/qvsi)
							      >	               CLDFRA(I,K,J) = MAX(0., ((RH_00O-RHUM)/(RH_00O
							      >	     &                                *((RH_00O-RHUM)/(RH_00O
							      >	            endif
							      >
							      >	            CLDFRA(I,K,J) = MAX(0.0, MIN(CLDFRA(I,K,J), 0.95)
							      >
							      >	         endif
							      >	      ENDDO
							      >	      ENDDO
							      >	      ENDDO
							      >
							      >	!..Prepare for a 1-D column to find various cloud layers.
							      >
							      >	      DO j = jts,jte
							      >	      DO i = its,ite
							      >	!        if (i.gt.10.and.i.le.20 .and. j.gt.10.and.j.le.20) t
							      >	!          debug_flag = .true.
							      >	!        else
							      >	!           debug_flag = .false.
							      >	!        endif
							      >	         DO k = kts,kte
							      >	            qvs1d(k) = qvsat(i,k,j)
							      >	            cfr1d(k) = cldfra(i,k,j)
							      >	            T1d(k) = t(i,k,j)
							      >	            P1d(k) = p(i,k,j)
							      >	            R1d(k) = rho(i,k,j)
							      >	            qc1d(k) = qc(i,k,j)
							      >	            qi1d(k) = qi(i,k,j)
							      >	            qs1d(k) = qs(i,k,j)
							      >	         ENDDO
							      >
							      >	!     if (debug_flag) then
							      >	!       WRITE (dbg_msg,*) 'DEBUG-GT: finding cloud layers at 
							      >	!       CALL wrf_debug (150, dbg_msg)
							      >	!     endif
							      >	         call find_cloudLayers(qvs1d, cfr1d, T1d, P1d, R1d,  
							      >	     &                         debug_flag, qc1d, qi1d, qs1d, 
							      >
							      >	         DO k = kts,kte
							      >	            cldfra(i,k,j) = cfr1d(k)
							      >	            qc(i,k,j) = qc1d(k)
							      >	            qi(i,k,j) = qi1d(k)
							      >	         ENDDO
							      >	      ENDDO
							      >	      ENDDO
							      >
							      >	      END SUBROUTINE cal_cldfra3
							      >
							      >	!+---+-------------------------------------------------------
							      >	!..From cloud fraction array, find clouds of multi-level dept
							      >	!.. a reasonable value of LWP or IWP that might be contained 
							      >	!.. unless existing LWC/IWC is already there.
							      >
							      >	      SUBROUTINE find_cloudLayers(qvs1d, cfr1d, T1d, P1d, R1d
							      >	     &                            debugfl, qc1d, qi1d, qs1d, 
							      >	!
							      >	      IMPLICIT NONE
							      >	!
							      >	      INTEGER, INTENT(IN):: kts, kte
							      >	      LOGICAL, INTENT(IN):: debugfl
							      >	      REAL, DIMENSION(kts:kte), INTENT(IN):: qvs1d,T1d,P1d,R1
							      >	      REAL, DIMENSION(kts:kte), INTENT(INOUT):: cfr1d
							      >	      REAL, DIMENSION(kts:kte), INTENT(INOUT):: qc1d, qi1d, q
							      >
							      >	!..Local vars.
							      >	      REAL, DIMENSION(kts:kte):: theta, dz
							      >	      REAL:: Z1, Z2, theta1, theta2, ht1, ht2
							      >	      INTEGER:: k, k2, k_tropo, k_m12C, k_m40C, k_cldb, k_cld
							      >	      LOGICAL:: in_cloud
							      >	      character*512 dbg_msg
							      >
							      >	!+---+
							      >
							      >	      k_m12C = 0
							      >	      k_m40C = 0
							      >	      DO k = kte, kts, -1
							      >	         theta(k) = T1d(k)*((100000.0/P1d(k))**(287.05/1004.)
							      >	         if (T1d(k)-273.16 .gt. -40.0) k_m40C = MAX(k_m40C, k
							      >	         if (T1d(k)-273.16 .gt. -12.0) k_m12C = MAX(k_m12C, k
							      >	      ENDDO
							      >	      if (k_m40C .le. kts) k_m40C = kts
							      >	      if (k_m12C .le. kts) k_m12C = kts
							      >
							      >	      Z2 = 44307.692 * (1.0 - (P1d(kte)/101325.)**0.190)
							      >	      DO k = kte-1, kts, -1
							      >	         Z1 = 44307.692 * (1.0 - (P1d(k)/101325.)**0.190)
							      >	         dz(k+1) = Z2 - Z1
							      >	         Z2 = Z1
							      >	      ENDDO
							      >	      dz(kts) = dz(kts+1)
							      >
							      >	!..Find tropopause height, best surrogate, because we would n
							      >	!.. wish to put fake clouds into the stratosphere.  The 10/15
							      >	!.. d(Theta)/d(Z) approximates a vertical line on typical Ske
							      >	!.. near typical (mid-latitude) tropopause height.  Since mes
							      >	!.. could give us a false signal of such a transition, do the
							      >	!.. three K-level change, not just a level-to-level check.  T
							      >	!.. has potential failure in arctic-like conditions with extr
							      >	!.. tropopause height, as would any other diagnostic, so ensu
							      >	!.. k_tropo level is above 4km.
							      >
							      >	      DO k = kte-3, kts, -1
							      >	         theta1 = theta(k)
							      >	         theta2 = theta(k+2)
							      >	         ht1 = 44307.692 * (1.0 - (P1d(k)/101325.)**0.190)
							      >	         ht2 = 44307.692 * (1.0 - (P1d(k+2)/101325.)**0.190)
							      >	         if ( (((theta2-theta1)/(ht2-ht1)) .lt. 10./1500. ) .
							      >	     &                       (ht1.lt.19000.) .and. (ht1.gt.40
							      >	            goto 86
							      >	         endif
							      >	      ENDDO
							      >	 86   continue
							      >	      k_tropo = MAX(kts+2, k+2)
							      >
							      >	!     if (debugfl) then
							      >	!     print*, ' FOUND TROPOPAUSE ', k_tropo, ' near ', ht2, '
							      >	!       WRITE (dbg_msg,*) 'DEBUG-GT: FOUND TROPOPAUSE ', k_tr
							      >	!       CALL wrf_debug (150, dbg_msg)
							      >	!     endif

							      >	!..Eliminate possible fractional clouds above supposed tropop
							      >	      DO k = k_tropo+1, kte
							      >	         if (cfr1d(k).gt.0.0 .and. cfr1d(k).lt.0.999) then
							      >	            cfr1d(k) = 0.
							      >	         endif
							      >	      ENDDO
							      >
							      >	!..We would like to prevent fractional clouds below LCL in id
							      >	!.. situation with deep well-mixed convective PBL, that other
							      >	!.. likely to get clouds in more realistic capping inversion 
							      >
							      >	      kbot = kts+2
							      >	      DO k = kbot, k_m12C
							      >	         if ( (theta(k)-theta(k-1)) .gt. 0.05E-3*dz(k)) EXIT
							      >	      ENDDO
							      >	      kbot = MAX(kts+1, k-1)
							      >	      DO k = kts, kbot
							      >	         if (cfr1d(k).gt.0.0 .and. cfr1d(k).lt.0.999) cfr1d(k
							      >	      ENDDO
							      >
							      >
							      >	!..Starting below tropo height, if cloud fraction greater tha
							      >	!.. compute an approximate total layer depth of cloud, determ
							      >	!.. liquid water/ice path (LWP/IWP), then reduce that amount 
							      >	!.. parameter to represent entrainment factor, then divide up
							      >	!.. into delta-Z weighted amounts for individual levels per c
							      >
							      >	      k_cldb = k_tropo
							      >	      in_cloud = .false.
							      >	      k = k_tropo
							      >	      DO WHILE (.not. in_cloud .AND. k.gt.k_m12C)
							      >	         k_cldt = 0
							      >	         if (cfr1d(k).ge.0.01) then
							      >	            in_cloud = .true.
							      >	            k_cldt = MAX(k_cldt, k)
							      >	         endif
							      >	         if (in_cloud) then
							      >	            DO k2 = k_cldt-1, k_m12C, -1
							      >	               if (cfr1d(k2).lt.0.01 .or. k2.eq.k_m12C) then
							      >	                  k_cldb = k2+1
							      >	                  goto 87
							      >	               endif
							      >	            ENDDO
							      >	 87         continue
							      >	            in_cloud = .false.
							      >	         endif
							      >	         if ((k_cldt - k_cldb + 1) .ge. 2) then
							      >	!     if (debugfl) then
							      >	!           print*, 'An ice cloud layer is found between ', k
							      >	!       WRITE (dbg_msg,*) 'DEBUG-GT: An ice cloud layer is fo
							      >	!       CALL wrf_debug (150, dbg_msg)
							      >	!     endif
							      >	            call adjust_cloudIce(cfr1d, qi1d, qs1d, qvs1d, T1
							      >	     &                           k_cldb,k_cldt,kts,kte)
							      >	            k = k_cldb
							      >	         endif
							      >	         k = k - 1
							      >	      ENDDO
							      >
							      >
							      >	      k_cldb = k_tropo
							      >	      in_cloud = .false.
							      >	      k = k_m12C
							      >	      DO WHILE (.not. in_cloud .AND. k.gt.kbot)
							      >	         k_cldt = 0
							      >	         if (cfr1d(k).ge.0.01) then
							      >	            in_cloud = .true.
							      >	            k_cldt = MAX(k_cldt, k)
							      >	         endif
							      >	         if (in_cloud) then
							      >	            DO k2 = k_cldt-1, kbot, -1
							      >	               if (cfr1d(k2).lt.0.01 .or. k2.eq.kbot) then
							      >	                  k_cldb = k2+1
							      >	                  goto 88
							      >	               endif
							      >	            ENDDO
							      >	 88         continue
							      >	            in_cloud = .false.
							      >	         endif
							      >	         if ((k_cldt - k_cldb + 1) .ge. 2) then
							      >	!     if (debugfl) then
							      >	!           print*, 'A water cloud layer is found between ', 
							      >	!       WRITE (dbg_msg,*) 'DEBUG-GT: A water cloud layer is f
							      >	!       CALL wrf_debug (150, dbg_msg)
							      >	!     endif
							      >	            call adjust_cloudH2O(cfr1d, qc1d, qvs1d, T1d,R1d,
							      >	     &                           k_cldb,k_cldt,kts,kte)
							      >	            k = k_cldb
							      >	         endif
							      >	         k = k - 1
							      >	      ENDDO
							      >
							      >	!..Do a final total column adjustment since we may have added
							      >	!.. LWP/IWP for multiple cloud decks.
							      >
							      >	      call adjust_cloudFinal(cfr1d, qc1d, qi1d, R1d,dz, kts,k
							      >
							      >	!     if (debugfl) then
							      >	!     print*, ' Made-up fake profile of clouds'
							      >	!     do k = kte, kts, -1
							      >	!        write(*,'(i3, 2x, f8.2, 2x, f9.2, 2x, f6.2, 2x,  f15
							      >	!    &        K, T1d(k)-273.15, P1d(k)*0.01, cfr1d(k)*100., q
							      >	!     enddo
							      >	!       WRITE (dbg_msg,*) 'DEBUG-GT:  Made-up fake profile of
							      >	!       CALL wrf_debug (150, dbg_msg)
							      >	!       do k = kte, kts, -1
							      >	!          write(dbg_msg,'(f8.2, 2x, f9.2, 2x, f6.2, 2x,  f15
							      >	!    &          T1d(k)-273.15, P1d(k)*0.01, cfr1d(k)*100., qc
							      >	!          CALL wrf_debug (150, dbg_msg)
							      >	!       enddo
							      >	!     endif
							      >
							      >	      END SUBROUTINE find_cloudLayers
							      >
							      >	!+---+-------------------------------------------------------
							      >
							      >	      SUBROUTINE adjust_cloudIce(cfr,qi,qs,qvs, T,Rho,dz, k1,
							      >	!
							      >	      IMPLICIT NONE
							      >	!
							      >	      INTEGER, INTENT(IN):: k1,k2, kts,kte
							      >	      REAL, DIMENSION(kts:kte), INTENT(IN):: cfr, qvs, T, Rho
							      >	      REAL, DIMENSION(kts:kte), INTENT(INOUT):: qi, qs
							      >	      REAL:: iwp, xiwp, max_iwp, tdz, this_iwp, iwp_exists
							      >	      INTEGER:: k
							      >	      REAL, PARAMETER:: entr=0.35
							      >
							      >	      max_iwp = ABS(qvs(k2-1)-qvs(k2))*Rho(k2-1)*dz(k2-1)
							      >
							      >	      tdz = 0.
							      >	      iwp = 0.
							      >	      iwp_exists = 0.
							      >	      do k = k1, k2
							      >	         tdz = tdz + dz(k)
							      >	         iwp = iwp + MAX(0., (qvs(k-1)-qvs(k))*Rho(k)*dz(k))
							      >	         iwp_exists = iwp_exists + (qi(k)+qs(k))*Rho(k)*dz(k)
							      >	      enddo
							      >	      if (iwp_exists .gt. 1.0) RETURN
							      >	      max_iwp = MAX(max_iwp*(1.-entr), MIN(1.0, iwp*(1.0-entr
							      >
							      >	      do k = k1, k2
							      >	         this_iwp = max_iwp*dz(k)/tdz
							      >	         if (cfr(k).gt.0.01.and.cfr(k).lt.0.99.and.T(k).ge.20
							      >	            qi(k) = qi(k) + cfr(k)*cfr(k)*this_iwp/Rho(k)/dz(
							      >	         endif
							      >	      enddo
							      >
							      >	      END SUBROUTINE adjust_cloudIce
							      >
							      >	!+---+-------------------------------------------------------
							      >
							      >	      SUBROUTINE adjust_cloudH2O(cfr, qc, qvs, T,Rho,dz, k1,k
							      >	!
							      >	      IMPLICIT NONE
							      >	!
							      >	      INTEGER, INTENT(IN):: k1,k2, kts,kte
							      >	      REAL, DIMENSION(kts:kte):: cfr, qc, qvs, T, Rho, dz
							      >	      REAL:: lwp, xlwp, max_lwp, tdz, this_lwp, lwp_exists
							      >	      INTEGER:: k
							      >	      REAL, PARAMETER:: entr=0.35
							      >
							      >	      max_lwp = ABS(qvs(k2-1)-qvs(k2))*Rho(k2-1)*dz(k2-1)
							      >
							      >	      tdz = 0.
							      >	      lwp = 0.
							      >	      lwp_exists = 0.
							      >	      do k = k1, k2
							      >	         tdz = tdz + dz(k)
							      >	         lwp = lwp + MAX(0., (qvs(k-1)-qvs(k))*Rho(k)*dz(k))
							      >	         lwp_exists = lwp_exists + qc(k)*Rho(k)*dz(k)
							      >	      enddo
							      >	      if (lwp_exists .gt. 1.0) RETURN
							      >	      max_lwp = MAX(max_lwp*(1.-entr), MIN(1.0, lwp*(1.0-entr
							      >
							      >	      do k = k1, k2
							      >	         this_lwp = max_lwp*dz(k)/tdz
							      >	         if (cfr(k).gt.0.95.and.qc(k).lt.1.E-7.and.T(k).lt.25
							      >	            qc(k) = qc(k) + 0.05*this_lwp/Rho(k)/dz(k)
							      >	         elseif (cfr(k).gt.0.01.and.cfr(k).lt.0.99.and.T(k).l
							      >	            qc(k) = qc(k) + cfr(k)*this_lwp/Rho(k)/dz(k)
							      >	         elseif (cfr(k).gt.0.01.and.cfr(k).lt.0.99.and.T(k).l
							      >	            qc(k) = qc(k) + cfr(k)*cfr(k)*this_lwp/Rho(k)/dz(
							      >	         endif
							      >	      enddo
							      >
							      >	      END SUBROUTINE adjust_cloudH2O
							      >
							      >	!+---+-------------------------------------------------------
							      >	!..Do not alter any grid-explicitly resolved hydrometeors, ra
							      >	!.. the supposed amounts due to the cloud fraction scheme.
							      >
							      >	      SUBROUTINE adjust_cloudFinal(cfr, qc, qi, Rho,dz, kts,k
							      >	!
							      >	      IMPLICIT NONE
							      >	!
							      >	      INTEGER, INTENT(IN):: kts,kte,k_tropo
							      >	      REAL, DIMENSION(kts:kte), INTENT(IN):: cfr, Rho, dz
							      >	      REAL, DIMENSION(kts:kte), INTENT(INOUT):: qc, qi
							      >	      REAL:: lwp, iwp, xfac
							      >	      INTEGER:: k
							      >
							      >	      lwp = 0.
							      >	      do k = kts, k_tropo
							      >	         if (cfr(k).gt.0.01 .and. cfr(k).lt.0.99) then
							      >	            lwp = lwp + qc(k)*Rho(k)*dz(k)
							      >	         endif
							      >	      enddo
							      >
							      >	      iwp = 0.
							      >	      do k = kts, k_tropo
							      >	         if (cfr(k).gt.0.01 .and. cfr(k).lt.0.99) then
							      >	            iwp = iwp + qi(k)*Rho(k)*dz(k)
							      >	         endif
							      >	      enddo
							      >
							      >	      if (lwp .gt. 1.0) then
							      >	         xfac = 1./lwp
							      >	         do k = kts, k_tropo
							      >	            if (cfr(k).gt.0.01 .and. cfr(k).lt.0.99) then
							      >	               qc(k) = qc(k)*xfac
							      >	            endif
							      >	         enddo
							      >	      endif
							      >
							      >	      if (iwp .gt. 1.0) then
							      >	         xfac = 1./iwp
							      >	         do k = kts, k_tropo
							      >	            if (cfr(k).gt.0.01 .and. cfr(k).lt.0.99) then
							      >	               qi(k) = qi(k)*xfac
							      >	            endif
							      >	         enddo
							      >	      endif
							      >
							      >	      END SUBROUTINE adjust_cloudFinal
							      >
							      >	!+---+-------------------------------------------------------

   SUBROUTINE toposhad_init(ht_shad,ht_loc,shadowmask,nested,	   SUBROUTINE toposhad_init(ht_shad,ht_loc,shadowmask,nested,
                       ids,ide, jds,jde, kds,kde,            	                       ids,ide, jds,jde, kds,kde,            
                       ims,ime, jms,jme, kms,kme,            	                       ims,ime, jms,jme, kms,kme,            
                       ips,ipe, jps,jpe, kps,kpe,            	                       ips,ipe, jps,jpe, kps,kpe,            
                       its,ite, jts,jte, kts,kte             	                       its,ite, jts,jte, kts,kte             

   USE module_model_constants					   USE module_model_constants

 implicit none							 implicit none

   INTEGER,    INTENT(IN) ::           ids,ide, jds,jde, kds,	   INTEGER,    INTENT(IN) ::           ids,ide, jds,jde, kds,
                                       ims,ime, jms,jme, kms,	                                       ims,ime, jms,jme, kms,
                                       ips,ipe, jps,jpe, kps,	                                       ips,ipe, jps,jpe, kps,
                                       its,ite, jts,jte, kts,	                                       its,ite, jts,jte, kts,

   LOGICAL, INTENT(IN)      :: nested				   LOGICAL, INTENT(IN)      :: nested

   REAL, DIMENSION( ims:ime, jms:jme ), INTENT(INOUT)  ::  ht	   REAL, DIMENSION( ims:ime, jms:jme ), INTENT(INOUT)  ::  ht

   INTEGER, DIMENSION( ims:ime, jms:jme ), INTENT(INOUT)  :: 	   INTEGER, DIMENSION( ims:ime, jms:jme ), INTENT(INOUT)  :: 
   INTEGER, INTENT(IN)      :: iter				   INTEGER, INTENT(IN)      :: iter

! Local variables						! Local variables

   INTEGER :: i, j						   INTEGER :: i, j

 if (iter.eq.1) then						 if (iter.eq.1) then

! Initialize shadow mask					! Initialize shadow mask
   do j=jts,jte							   do j=jts,jte
   do i=its,ite							   do i=its,ite
     shadowmask(i,j) = 0					     shadowmask(i,j) = 0
   ENDDO							   ENDDO
   ENDDO							   ENDDO

! Initialize shading height 					! Initialize shading height 

   IF ( nested ) THEN  ! Do not overwrite input from parent d	   IF ( nested ) THEN  ! Do not overwrite input from parent d
     do j=max(jts,jds+2),min(jte,jde-3)				     do j=max(jts,jds+2),min(jte,jde-3)
     do i=max(its,ids+2),min(ite,ide-3)				     do i=max(its,ids+2),min(ite,ide-3)
       ht_shad(i,j) = ht_loc(i,j)-0.001				       ht_shad(i,j) = ht_loc(i,j)-0.001
     ENDDO							     ENDDO
     ENDDO							     ENDDO
   ELSE								   ELSE
     do j=jts,jte						     do j=jts,jte
     do i=its,ite						     do i=its,ite
       ht_shad(i,j) = ht_loc(i,j)-0.001				       ht_shad(i,j) = ht_loc(i,j)-0.001
     ENDDO							     ENDDO
     ENDDO							     ENDDO
   ENDIF							   ENDIF

   IF ( nested ) THEN  ! Check if a shadow exceeding the topo	   IF ( nested ) THEN  ! Check if a shadow exceeding the topo
     if (its.eq.ids) then					     if (its.eq.ids) then
       do j=jts,jte						       do j=jts,jte
         if (ht_shad(its,j) .gt. ht_loc(its,j)) then		         if (ht_shad(its,j) .gt. ht_loc(its,j)) then
           shadowmask(its,j) = 1				           shadowmask(its,j) = 1
           ht_loc(its,j) = ht_shad(its,j)			           ht_loc(its,j) = ht_shad(its,j)
         endif							         endif
         if (ht_shad(its+1,j) .gt. ht_loc(its+1,j)) then	         if (ht_shad(its+1,j) .gt. ht_loc(its+1,j)) then
           shadowmask(its+1,j) = 1				           shadowmask(its+1,j) = 1
           ht_loc(its+1,j) = ht_shad(its+1,j)			           ht_loc(its+1,j) = ht_shad(its+1,j)
         endif							         endif
       enddo							       enddo
     endif							     endif
     if (ite.eq.ide-1) then					     if (ite.eq.ide-1) then
       do j=jts,jte						       do j=jts,jte
         if (ht_shad(ite,j) .gt. ht_loc(ite,j)) then		         if (ht_shad(ite,j) .gt. ht_loc(ite,j)) then
           shadowmask(ite,j) = 1				           shadowmask(ite,j) = 1
           ht_loc(ite,j) = ht_shad(ite,j)			           ht_loc(ite,j) = ht_shad(ite,j)
         endif							         endif
         if (ht_shad(ite-1,j) .gt. ht_loc(ite-1,j)) then	         if (ht_shad(ite-1,j) .gt. ht_loc(ite-1,j)) then
           shadowmask(ite-1,j) = 1				           shadowmask(ite-1,j) = 1
           ht_loc(ite-1,j) = ht_shad(ite-1,j)			           ht_loc(ite-1,j) = ht_shad(ite-1,j)
         endif							         endif
       enddo							       enddo
     endif							     endif
     if (jts.eq.jds) then					     if (jts.eq.jds) then
       do i=its,ite						       do i=its,ite
         if (ht_shad(i,jts) .gt. ht_loc(i,jts)) then		         if (ht_shad(i,jts) .gt. ht_loc(i,jts)) then
           shadowmask(i,jts) = 1				           shadowmask(i,jts) = 1
           ht_loc(i,jts) = ht_shad(i,jts)			           ht_loc(i,jts) = ht_shad(i,jts)
         endif							         endif
         if (ht_shad(i,jts+1) .gt. ht_loc(i,jts+1)) then	         if (ht_shad(i,jts+1) .gt. ht_loc(i,jts+1)) then
           shadowmask(i,jts+1) = 1				           shadowmask(i,jts+1) = 1
           ht_loc(i,jts+1) = ht_shad(i,jts+1)			           ht_loc(i,jts+1) = ht_shad(i,jts+1)
         endif							         endif
       enddo							       enddo
     endif							     endif
     if (jte.eq.jde-1) then					     if (jte.eq.jde-1) then
       do i=its,ite						       do i=its,ite
         if (ht_shad(i,jte) .gt. ht_loc(i,jte)) then		         if (ht_shad(i,jte) .gt. ht_loc(i,jte)) then
           shadowmask(i,jte) = 1				           shadowmask(i,jte) = 1
           ht_loc(i,jte) = ht_shad(i,jte)			           ht_loc(i,jte) = ht_shad(i,jte)
         endif							         endif
         if (ht_shad(i,jte-1) .gt. ht_loc(i,jte-1)) then	         if (ht_shad(i,jte-1) .gt. ht_loc(i,jte-1)) then
           shadowmask(i,jte-1) = 1				           shadowmask(i,jte-1) = 1
           ht_loc(i,jte-1) = ht_shad(i,jte-1)			           ht_loc(i,jte-1) = ht_shad(i,jte-1)
         endif							         endif
       enddo							       enddo
     endif							     endif
   ENDIF							   ENDIF

 else								 else

! Fill the local topography field at the points next to inter	! Fill the local topography field at the points next to inter
! A 2-pt halo has been applied to the ht_shad before the repe	! A 2-pt halo has been applied to the ht_shad before the repe

   if ((its.ne.ids).and.(its.eq.ips)) then			   if ((its.ne.ids).and.(its.eq.ips)) then
     do j=jts-2,jte+2						     do j=jts-2,jte+2
       ht_loc(its-1,j) = max(ht_loc(its-1,j),ht_shad(its-1,j)	       ht_loc(its-1,j) = max(ht_loc(its-1,j),ht_shad(its-1,j)
       ht_loc(its-2,j) = max(ht_loc(its-2,j),ht_shad(its-2,j)	       ht_loc(its-2,j) = max(ht_loc(its-2,j),ht_shad(its-2,j)
     enddo							     enddo
   endif							   endif
   if ((ite.ne.ide-1).and.(ite.eq.ipe)) then			   if ((ite.ne.ide-1).and.(ite.eq.ipe)) then
     do j=jts-2,jte+2						     do j=jts-2,jte+2
       ht_loc(ite+1,j) = max(ht_loc(ite+1,j),ht_shad(ite+1,j)	       ht_loc(ite+1,j) = max(ht_loc(ite+1,j),ht_shad(ite+1,j)
       ht_loc(ite+2,j) = max(ht_loc(ite+2,j),ht_shad(ite+2,j)	       ht_loc(ite+2,j) = max(ht_loc(ite+2,j),ht_shad(ite+2,j)
     enddo							     enddo
   endif							   endif
   if ((jts.ne.jds).and.(jts.eq.jps)) then			   if ((jts.ne.jds).and.(jts.eq.jps)) then
     do i=its-2,ite+2						     do i=its-2,ite+2
       ht_loc(i,jts-1) = max(ht_loc(i,jts-1),ht_shad(i,jts-1)	       ht_loc(i,jts-1) = max(ht_loc(i,jts-1),ht_shad(i,jts-1)
       ht_loc(i,jts-2) = max(ht_loc(i,jts-2),ht_shad(i,jts-2)	       ht_loc(i,jts-2) = max(ht_loc(i,jts-2),ht_shad(i,jts-2)
     enddo							     enddo
   endif							   endif
   if ((jte.ne.jde-1).and.(jte.eq.jpe)) then			   if ((jte.ne.jde-1).and.(jte.eq.jpe)) then
     do i=its-2,ite+2						     do i=its-2,ite+2
       ht_loc(i,jte+1) = max(ht_loc(i,jte+1),ht_shad(i,jte+1)	       ht_loc(i,jte+1) = max(ht_loc(i,jte+1),ht_shad(i,jte+1)
       ht_loc(i,jte+2) = max(ht_loc(i,jte+2),ht_shad(i,jte+2)	       ht_loc(i,jte+2) = max(ht_loc(i,jte+2),ht_shad(i,jte+2)
     enddo							     enddo
   endif							   endif

 endif								 endif

   END SUBROUTINE toposhad_init					   END SUBROUTINE toposhad_init

   SUBROUTINE toposhad(xlat,xlong,sina,cosa,xtime,gmt,radfrq,	   SUBROUTINE toposhad(xlat,xlong,sina,cosa,xtime,gmt,radfrq,
                       dx,dy,ht_shad,ht_loc,iter,            	                       dx,dy,ht_shad,ht_loc,iter,            
                       shadowmask,shadlen,                   	                       shadowmask,shadlen,                   
                       ids,ide, jds,jde, kds,kde,            	                       ids,ide, jds,jde, kds,kde,            
                       ims,ime, jms,jme, kms,kme,            	                       ims,ime, jms,jme, kms,kme,            
                       ips,ipe, jps,jpe, kps,kpe,            	                       ips,ipe, jps,jpe, kps,kpe,            
                       its,ite, jts,jte, kts,kte             	                       its,ite, jts,jte, kts,kte             


   USE module_model_constants					   USE module_model_constants

 implicit none							 implicit none

   INTEGER,    INTENT(IN) ::           ids,ide, jds,jde, kds,	   INTEGER,    INTENT(IN) ::           ids,ide, jds,jde, kds,
                                       ims,ime, jms,jme, kms,	                                       ims,ime, jms,jme, kms,
                                       ips,ipe, jps,jpe, kps,	                                       ips,ipe, jps,jpe, kps,
                                       its,ite, jts,jte, kts,	                                       its,ite, jts,jte, kts,

   INTEGER,   INTENT(IN) ::      iter				   INTEGER,   INTENT(IN) ::      iter

   REAL, INTENT(IN)      ::        RADFRQ,XTIME,DECLIN,dx,dy,	   REAL, INTENT(IN)      ::        RADFRQ,XTIME,DECLIN,dx,dy,

   REAL, DIMENSION( ims:ime, jms:jme ), INTENT(IN)  :: XLAT, 	   REAL, DIMENSION( ims:ime, jms:jme ), INTENT(IN)  :: XLAT, 

   REAL, DIMENSION( ims:ime, jms:jme ), INTENT(INOUT)  ::  ht	   REAL, DIMENSION( ims:ime, jms:jme ), INTENT(INOUT)  ::  ht

   INTEGER, DIMENSION( ims:ime, jms:jme ), INTENT(INOUT)  :: 	   INTEGER, DIMENSION( ims:ime, jms:jme ), INTENT(INOUT)  :: 

! Local variables						! Local variables

   REAL :: pi, xt24, wgt, ri, rj, argu, sol_azi, topoelev, dx	   REAL :: pi, xt24, wgt, ri, rj, argu, sol_azi, topoelev, dx
   INTEGER :: gpshad, ii, jj, i1, i2, j1, j2, i, j		   INTEGER :: gpshad, ii, jj, i1, i2, j1, j2, i, j



 XT24=MOD(XTIME+RADFRQ*0.5,1440.)				 XT24=MOD(XTIME+RADFRQ*0.5,1440.)
 pi = 4.*atan(1.)						 pi = 4.*atan(1.)
 gpshad = int(shadlen/dx+1.)					 gpshad = int(shadlen/dx+1.)

 if (iter.eq.1) then  						 if (iter.eq.1) then  


   j_loop1: DO J=jts,jte					   j_loop1: DO J=jts,jte
   i_loop1: DO I=its,ite					   i_loop1: DO I=its,ite

     TLOCTM=GMT+XT24/60.+XLONG(i,j)/15.				     TLOCTM=GMT+XT24/60.+XLONG(i,j)/15.
     HRANG=15.*(TLOCTM-12.)*DEGRAD				     HRANG=15.*(TLOCTM-12.)*DEGRAD
     XXLAT=XLAT(i,j)*DEGRAD					     XXLAT=XLAT(i,j)*DEGRAD
     CSZA=SIN(XXLAT)*SIN(DECLIN)+COS(XXLAT)*COS(DECLIN)*COS(H	     CSZA=SIN(XXLAT)*SIN(DECLIN)+COS(XXLAT)*COS(DECLIN)*COS(H

     if (csza.lt.1.e-2) then   ! shadow mask does not need to	     if (csza.lt.1.e-2) then   ! shadow mask does not need to
     shadowmask(i,j) = 0					     shadowmask(i,j) = 0
     ht_shad(i,j) = ht_loc(i,j)-0.001				     ht_shad(i,j) = ht_loc(i,j)-0.001
     goto 120							     goto 120
     endif							     endif

! Solar azimuth angle						! Solar azimuth angle

     argu=(csza*sin(XXLAT)-sin(DECLIN))/(sin(acos(csza))*cos(	     argu=(csza*sin(XXLAT)-sin(DECLIN))/(sin(acos(csza))*cos(
     if (argu.gt.1) argu = 1					     if (argu.gt.1) argu = 1
     if (argu.lt.-1) argu = -1					     if (argu.lt.-1) argu = -1
     sol_azi = sign(acos(argu),sin(HRANG))+pi  ! azimuth angl	     sol_azi = sign(acos(argu),sin(HRANG))+pi  ! azimuth angl
     if (cosa(i,j).ge.0) then					     if (cosa(i,j).ge.0) then
       sol_azi = sol_azi + asin(sina(i,j))  ! rotation toward	       sol_azi = sol_azi + asin(sina(i,j))  ! rotation toward
     else							     else
       sol_azi = sol_azi + pi - asin(sina(i,j)) 		       sol_azi = sol_azi + pi - asin(sina(i,j)) 
     endif							     endif

! Scan for higher surrounding topography			! Scan for higher surrounding topography

          if ((sol_azi.gt.1.75*pi).or.(sol_azi.lt.0.25*pi)) t	          if ((sol_azi.gt.1.75*pi).or.(sol_azi.lt.0.25*pi)) t

            do jj = j+1,j+gpshad				            do jj = j+1,j+gpshad
              ri = i + (jj-j)*tan(sol_azi)			              ri = i + (jj-j)*tan(sol_azi)
              i1 = int(ri) 					              i1 = int(ri) 
              i2 = i1+1						              i2 = i1+1
              wgt = ri-i1					              wgt = ri-i1
              dxabs = sqrt((dy*(jj-j))**2+(dx*(ri-i))**2)	              dxabs = sqrt((dy*(jj-j))**2+(dx*(ri-i))**2)
              if ((jj.ge.jpe+1).or.(i1.le.ips-1).or.(i2.ge.ip	              if ((jj.ge.jpe+1).or.(i1.le.ips-1).or.(i2.ge.ip
                if (shadowmask(i,j).eq.0) shadowmask(i,j) = -	                if (shadowmask(i,j).eq.0) shadowmask(i,j) = -
                goto 120					                goto 120
              endif						              endif
              topoelev=atan((wgt*ht_loc(i2,jj)+(1.-wgt)*ht_lo	              topoelev=atan((wgt*ht_loc(i2,jj)+(1.-wgt)*ht_lo
              if (sin(topoelev).ge.csza) then			              if (sin(topoelev).ge.csza) then
                shadowmask(i,j) = 1				                shadowmask(i,j) = 1
                ht_shad(i,j) = max(ht_shad(i,j),ht_loc(i,j)+d	                ht_shad(i,j) = max(ht_shad(i,j),ht_loc(i,j)+d
              endif						              endif
            enddo						            enddo

          else if (sol_azi.lt.0.75*pi) then  ! sun is in the 	          else if (sol_azi.lt.0.75*pi) then  ! sun is in the 
            do ii = i+1,i+gpshad				            do ii = i+1,i+gpshad
              rj = j - (ii-i)*tan(pi/2.+sol_azi)		              rj = j - (ii-i)*tan(pi/2.+sol_azi)
              j1 = int(rj)					              j1 = int(rj)
              j2 = j1+1						              j2 = j1+1
              wgt = rj-j1					              wgt = rj-j1
              dxabs = sqrt((dx*(ii-i))**2+(dy*(rj-j))**2)	              dxabs = sqrt((dx*(ii-i))**2+(dy*(rj-j))**2)
              if ((ii.ge.ipe+1).or.(j1.le.jps-1).or.(j2.ge.jp	              if ((ii.ge.ipe+1).or.(j1.le.jps-1).or.(j2.ge.jp
                if (shadowmask(i,j).eq.0) shadowmask(i,j) = -	                if (shadowmask(i,j).eq.0) shadowmask(i,j) = -
                goto 120					                goto 120
              endif						              endif
              topoelev=atan((wgt*ht_loc(ii,j2)+(1.-wgt)*ht_lo	              topoelev=atan((wgt*ht_loc(ii,j2)+(1.-wgt)*ht_lo
              if (sin(topoelev).ge.csza) then			              if (sin(topoelev).ge.csza) then
                shadowmask(i,j) = 1				                shadowmask(i,j) = 1
                ht_shad(i,j) = max(ht_shad(i,j),ht_loc(i,j)+d	                ht_shad(i,j) = max(ht_shad(i,j),ht_loc(i,j)+d
              endif						              endif
            enddo						            enddo

          else if (sol_azi.lt.1.25*pi) then ! sun is in the s	          else if (sol_azi.lt.1.25*pi) then ! sun is in the s
            do jj = j-1,j-gpshad,-1				            do jj = j-1,j-gpshad,-1
              ri = i + (jj-j)*tan(sol_azi)			              ri = i + (jj-j)*tan(sol_azi)
              i1 = int(ri)					              i1 = int(ri)
              i2 = i1+1						              i2 = i1+1
              wgt = ri-i1					              wgt = ri-i1
              dxabs = sqrt((dy*(jj-j))**2+(dx*(ri-i))**2)	              dxabs = sqrt((dy*(jj-j))**2+(dx*(ri-i))**2)
              if ((jj.le.jps-1).or.(i1.le.ips-1).or.(i2.ge.ip	              if ((jj.le.jps-1).or.(i1.le.ips-1).or.(i2.ge.ip
                if (shadowmask(i,j).eq.0) shadowmask(i,j) = -	                if (shadowmask(i,j).eq.0) shadowmask(i,j) = -
                goto 120					                goto 120
              endif						              endif
              topoelev=atan((wgt*ht_loc(i2,jj)+(1.-wgt)*ht_lo	              topoelev=atan((wgt*ht_loc(i2,jj)+(1.-wgt)*ht_lo
              if (sin(topoelev).ge.csza) then			              if (sin(topoelev).ge.csza) then
                shadowmask(i,j) = 1				                shadowmask(i,j) = 1
                ht_shad(i,j) = max(ht_shad(i,j),ht_loc(i,j)+d	                ht_shad(i,j) = max(ht_shad(i,j),ht_loc(i,j)+d
              endif						              endif
            enddo						            enddo

          else                          ! sun is in the weste	          else                          ! sun is in the weste
            do ii = i-1,i-gpshad,-1				            do ii = i-1,i-gpshad,-1
              rj = j - (ii-i)*tan(pi/2.+sol_azi)		              rj = j - (ii-i)*tan(pi/2.+sol_azi)
              j1 = int(rj)					              j1 = int(rj)
              j2 = j1+1						              j2 = j1+1
              wgt = rj-j1					              wgt = rj-j1
              dxabs = sqrt((dx*(ii-i))**2+(dy*(rj-j))**2)	              dxabs = sqrt((dx*(ii-i))**2+(dy*(rj-j))**2)
              if ((ii.le.ips-1).or.(j1.le.jps-1).or.(j2.ge.jp	              if ((ii.le.ips-1).or.(j1.le.jps-1).or.(j2.ge.jp
                if (shadowmask(i,j).eq.0) shadowmask(i,j) = -	                if (shadowmask(i,j).eq.0) shadowmask(i,j) = -
                goto 120					                goto 120
              endif						              endif
              topoelev=atan((wgt*ht_loc(ii,j2)+(1.-wgt)*ht_lo	              topoelev=atan((wgt*ht_loc(ii,j2)+(1.-wgt)*ht_lo
              if (sin(topoelev).ge.csza) then			              if (sin(topoelev).ge.csza) then
                shadowmask(i,j) = 1				                shadowmask(i,j) = 1
                ht_shad(i,j) = max(ht_shad(i,j),ht_loc(i,j)+d	                ht_shad(i,j) = max(ht_shad(i,j),ht_loc(i,j)+d
              endif						              endif
            enddo						            enddo
          endif							          endif

 120      continue						 120      continue

   ENDDO i_loop1						   ENDDO i_loop1
   ENDDO j_loop1						   ENDDO j_loop1

 else   ! iteration > 1						 else   ! iteration > 1


   j_loop2: DO J=jts,jte					   j_loop2: DO J=jts,jte
   i_loop2: DO I=its,ite					   i_loop2: DO I=its,ite

!     if (shadowmask(i,j).eq.-1) then  ! this indicates that 	!     if (shadowmask(i,j).eq.-1) then  ! this indicates that 

       TLOCTM=GMT+XT24/60.+XLONG(i,j)/15.			       TLOCTM=GMT+XT24/60.+XLONG(i,j)/15.
       HRANG=15.*(TLOCTM-12.)*DEGRAD				       HRANG=15.*(TLOCTM-12.)*DEGRAD
       XXLAT=XLAT(i,j)*DEGRAD					       XXLAT=XLAT(i,j)*DEGRAD
       CSZA=SIN(XXLAT)*SIN(DECLIN)+COS(XXLAT)*COS(DECLIN)*COS	       CSZA=SIN(XXLAT)*SIN(DECLIN)+COS(XXLAT)*COS(DECLIN)*COS

! Solar azimuth angle						! Solar azimuth angle

       argu=(csza*sin(XXLAT)-sin(DECLIN))/(sin(acos(csza))*co	       argu=(csza*sin(XXLAT)-sin(DECLIN))/(sin(acos(csza))*co
       if (argu.gt.1) argu = 1					       if (argu.gt.1) argu = 1
       if (argu.lt.-1) argu = -1				       if (argu.lt.-1) argu = -1
       sol_azi = sign(acos(argu),sin(HRANG))+pi  ! azimuth an	       sol_azi = sign(acos(argu),sin(HRANG))+pi  ! azimuth an
       if (cosa(i,j).ge.0) then					       if (cosa(i,j).ge.0) then
         sol_azi = sol_azi + asin(sina(i,j))  ! rotation towa	         sol_azi = sol_azi + asin(sina(i,j))  ! rotation towa
       else							       else
         sol_azi = sol_azi + pi - asin(sina(i,j)) 		         sol_azi = sol_azi + pi - asin(sina(i,j)) 
       endif							       endif

! Scan for higher surrounding topography			! Scan for higher surrounding topography

          if ((sol_azi.gt.1.75*pi).or.(sol_azi.lt.0.25*pi)) t	          if ((sol_azi.gt.1.75*pi).or.(sol_azi.lt.0.25*pi)) t

            do jj = j+1,j+gpshad				            do jj = j+1,j+gpshad
              ri = i + (jj-j)*tan(sol_azi)			              ri = i + (jj-j)*tan(sol_azi)
              i1 = int(ri) 					              i1 = int(ri) 
              i2 = i1+1						              i2 = i1+1
              wgt = ri-i1					              wgt = ri-i1
              dxabs = sqrt((dy*(jj-j))**2+(dx*(ri-i))**2)	              dxabs = sqrt((dy*(jj-j))**2+(dx*(ri-i))**2)
              if ((jj.ge.min(jde,jpe+3)).or.(i1.le.max(ids-1,	              if ((jj.ge.min(jde,jpe+3)).or.(i1.le.max(ids-1,
              topoelev=atan((wgt*ht_loc(i2,jj)+(1.-wgt)*ht_lo	              topoelev=atan((wgt*ht_loc(i2,jj)+(1.-wgt)*ht_lo
              if (sin(topoelev).ge.csza) then			              if (sin(topoelev).ge.csza) then
                shadowmask(i,j) = 1				                shadowmask(i,j) = 1
                ht_shad(i,j) = max(ht_shad(i,j),ht_loc(i,j)+d	                ht_shad(i,j) = max(ht_shad(i,j),ht_loc(i,j)+d
              endif						              endif
            enddo						            enddo

          else if (sol_azi.lt.0.75*pi) then  ! sun is in the 	          else if (sol_azi.lt.0.75*pi) then  ! sun is in the 
            do ii = i+1,i+gpshad				            do ii = i+1,i+gpshad
              rj = j - (ii-i)*tan(pi/2.+sol_azi)		              rj = j - (ii-i)*tan(pi/2.+sol_azi)
              j1 = int(rj)					              j1 = int(rj)
              j2 = j1+1						              j2 = j1+1
              wgt = rj-j1					              wgt = rj-j1
              dxabs = sqrt((dx*(ii-i))**2+(dy*(rj-j))**2)	              dxabs = sqrt((dx*(ii-i))**2+(dy*(rj-j))**2)
              if ((ii.ge.min(ide,ipe+3)).or.(j1.le.max(jds-1,	              if ((ii.ge.min(ide,ipe+3)).or.(j1.le.max(jds-1,
              topoelev=atan((wgt*ht_loc(ii,j2)+(1.-wgt)*ht_lo	              topoelev=atan((wgt*ht_loc(ii,j2)+(1.-wgt)*ht_lo
              if (sin(topoelev).ge.csza) then			              if (sin(topoelev).ge.csza) then
                shadowmask(i,j) = 1				                shadowmask(i,j) = 1
                ht_shad(i,j) = max(ht_shad(i,j),ht_loc(i,j)+d	                ht_shad(i,j) = max(ht_shad(i,j),ht_loc(i,j)+d
              endif						              endif
            enddo						            enddo

          else if (sol_azi.lt.1.25*pi) then ! sun is in the s	          else if (sol_azi.lt.1.25*pi) then ! sun is in the s
            do jj = j-1,j-gpshad,-1				            do jj = j-1,j-gpshad,-1
              ri = i + (jj-j)*tan(sol_azi)			              ri = i + (jj-j)*tan(sol_azi)
              i1 = int(ri)					              i1 = int(ri)
              i2 = i1+1						              i2 = i1+1
              wgt = ri-i1					              wgt = ri-i1
              dxabs = sqrt((dy*(jj-j))**2+(dx*(ri-i))**2)	              dxabs = sqrt((dy*(jj-j))**2+(dx*(ri-i))**2)
              if ((jj.le.max(jds-1,jps-3)).or.(i1.le.max(ids-	              if ((jj.le.max(jds-1,jps-3)).or.(i1.le.max(ids-
              topoelev=atan((wgt*ht_loc(i2,jj)+(1.-wgt)*ht_lo	              topoelev=atan((wgt*ht_loc(i2,jj)+(1.-wgt)*ht_lo
              if (sin(topoelev).ge.csza) then			              if (sin(topoelev).ge.csza) then
                shadowmask(i,j) = 1				                shadowmask(i,j) = 1
                ht_shad(i,j) = max(ht_shad(i,j),ht_loc(i,j)+d	                ht_shad(i,j) = max(ht_shad(i,j),ht_loc(i,j)+d
              endif						              endif
            enddo						            enddo

          else                          ! sun is in the weste	          else                          ! sun is in the weste
            do ii = i-1,i-gpshad,-1				            do ii = i-1,i-gpshad,-1
              rj = j - (ii-i)*tan(pi/2.+sol_azi)		              rj = j - (ii-i)*tan(pi/2.+sol_azi)
              j1 = int(rj)					              j1 = int(rj)
              j2 = j1+1						              j2 = j1+1
              wgt = rj-j1					              wgt = rj-j1
              dxabs = sqrt((dx*(ii-i))**2+(dy*(rj-j))**2)	              dxabs = sqrt((dx*(ii-i))**2+(dy*(rj-j))**2)
              if ((ii.le.max(ids-1,ips-3)).or.(j1.le.max(jds-	              if ((ii.le.max(ids-1,ips-3)).or.(j1.le.max(jds-
              topoelev=atan((wgt*ht_loc(ii,j2)+(1.-wgt)*ht_lo	              topoelev=atan((wgt*ht_loc(ii,j2)+(1.-wgt)*ht_lo
              if (sin(topoelev).ge.csza) then			              if (sin(topoelev).ge.csza) then
                shadowmask(i,j) = 1				                shadowmask(i,j) = 1
                ht_shad(i,j) = max(ht_shad(i,j),ht_loc(i,j)+d	                ht_shad(i,j) = max(ht_shad(i,j),ht_loc(i,j)+d
              endif						              endif
            enddo						            enddo
          endif							          endif

 220      continue						 220      continue
!     endif							!     endif

   ENDDO i_loop2						   ENDDO i_loop2
   ENDDO j_loop2						   ENDDO j_loop2

 endif ! iteration						 endif ! iteration

   END SUBROUTINE toposhad					   END SUBROUTINE toposhad

SUBROUTINE ozn_time_int(julday,julian,ozmixm,ozmixt,levsiz,nu	SUBROUTINE ozn_time_int(julday,julian,ozmixm,ozmixt,levsiz,nu
                              ids , ide , jds , jde , kds , k	                              ids , ide , jds , jde , kds , k
                              ims , ime , jms , jme , kms , k	                              ims , ime , jms , jme , kms , k
                              its , ite , jts , jte , kts , k	                              its , ite , jts , jte , kts , k

! adapted from oznint from CAM module				! adapted from oznint from CAM module
!  input: ozmixm - read from physics_init			!  input: ozmixm - read from physics_init
! output: ozmixt - time interpolated				! output: ozmixt - time interpolated

!  USE module_ra_cam_support, ONLY : getfactors			!  USE module_ra_cam_support, ONLY : getfactors

   IMPLICIT NONE						   IMPLICIT NONE

   INTEGER,    INTENT(IN) ::           ids,ide, jds,jde, kds,	   INTEGER,    INTENT(IN) ::           ids,ide, jds,jde, kds,
                                       ims,ime, jms,jme, kms,	                                       ims,ime, jms,jme, kms,
                                       its,ite, jts,jte, kts,	                                       its,ite, jts,jte, kts,

   INTEGER,      INTENT(IN   )    ::   levsiz, num_months	   INTEGER,      INTENT(IN   )    ::   levsiz, num_months

   REAL,  DIMENSION( ims:ime, levsiz, jms:jme, num_months ), 	   REAL,  DIMENSION( ims:ime, levsiz, jms:jme, num_months ), 
          INTENT(IN   ) ::                                  o	          INTENT(IN   ) ::                                  o

   INTEGER, INTENT(IN )      ::        JULDAY			   INTEGER, INTENT(IN )      ::        JULDAY
   REAL,    INTENT(IN )      ::        JULIAN			   REAL,    INTENT(IN )      ::        JULIAN

   REAL,  DIMENSION( ims:ime, levsiz, jms:jme ),      &		   REAL,  DIMENSION( ims:ime, levsiz, jms:jme ),      &
          INTENT(OUT  ) ::                                  o	          INTENT(OUT  ) ::                                  o

   !Local							   !Local
   REAL      :: intJULIAN					   REAL      :: intJULIAN
   integer   :: np1,np,nm,m,k,i,j				   integer   :: np1,np,nm,m,k,i,j
   integer   :: IJUL						   integer   :: IJUL
   integer, dimension(12) ::  date_oz				   integer, dimension(12) ::  date_oz
   data date_oz/16, 45, 75, 105, 136, 166, 197, 228, 258, 289	   data date_oz/16, 45, 75, 105, 136, 166, 197, 228, 258, 289
   real, parameter :: daysperyear = 365.  ! number of days in	   real, parameter :: daysperyear = 365.  ! number of days in
   real      :: cdayozp, cdayozm				   real      :: cdayozp, cdayozm
   real      :: fact1, fact2, deltat				   real      :: fact1, fact2, deltat
   logical   :: finddate					   logical   :: finddate
   logical   :: ozncyc						   logical   :: ozncyc
   CHARACTER(LEN=256) :: msgstr					   CHARACTER(LEN=256) :: msgstr

   ozncyc = .true.						   ozncyc = .true.
   ! JULIAN starts from 0.0 at 0Z on 1 Jan.			   ! JULIAN starts from 0.0 at 0Z on 1 Jan.
   intJULIAN = JULIAN + 1.0       ! offset by one day		   intJULIAN = JULIAN + 1.0       ! offset by one day
! jan 1st 00z is julian=1.0 here				! jan 1st 00z is julian=1.0 here
   IJUL=INT(intJULIAN)						   IJUL=INT(intJULIAN)
!  Note that following will drift.				!  Note that following will drift.
!    Need to use actual month/day info to compute julian.	!    Need to use actual month/day info to compute julian.
   intJULIAN=intJULIAN-FLOAT(IJUL)				   intJULIAN=intJULIAN-FLOAT(IJUL)
   IJUL=MOD(IJUL,365)						   IJUL=MOD(IJUL,365)
   IF(IJUL.EQ.0)IJUL=365					   IF(IJUL.EQ.0)IJUL=365
   intJULIAN=intJULIAN+IJUL					   intJULIAN=intJULIAN+IJUL
   np1=1							   np1=1
   finddate=.false.						   finddate=.false.

!  do m=1,num_months						!  do m=1,num_months
   do m=1,12							   do m=1,12
      if(date_oz(m).gt.intjulian.and..not.finddate) then	      if(date_oz(m).gt.intjulian.and..not.finddate) then
        np1=m							        np1=m
        finddate=.true.						        finddate=.true.
      endif							      endif
   enddo							   enddo
   cdayozp=date_oz(np1)						   cdayozp=date_oz(np1)

   if(np1.gt.1) then						   if(np1.gt.1) then
      cdayozm=date_oz(np1-1)					      cdayozm=date_oz(np1-1)
      np=np1							      np=np1
      nm=np-1							      nm=np-1
   else								   else
      cdayozm=date_oz(12)					      cdayozm=date_oz(12)
      np=np1							      np=np1
      nm=12							      nm=12
   endif							   endif

!  call getfactors(ozncyc,np1, cdayozm, cdayozp,intjulian, &	!  call getfactors(ozncyc,np1, cdayozm, cdayozp,intjulian, &
!                   fact1, fact2)				!                   fact1, fact2)
!								!
! Determine time interpolation factors.  Account for December	! Determine time interpolation factors.  Account for December
! interpolation if dataset is being cycled yearly.		! interpolation if dataset is being cycled yearly.
!								!
   if (ozncyc .and. np1 == 1) then                      ! Dec	   if (ozncyc .and. np1 == 1) then                      ! Dec
      deltat = cdayozp + daysperyear - cdayozm			      deltat = cdayozp + daysperyear - cdayozm
      if (intjulian > cdayozp) then                     ! We 	      if (intjulian > cdayozp) then                     ! We 
         fact1 = (cdayozp + daysperyear - intjulian)/deltat	         fact1 = (cdayozp + daysperyear - intjulian)/deltat
         fact2 = (intjulian - cdayozm)/deltat			         fact2 = (intjulian - cdayozm)/deltat
      else                                              ! We 	      else                                              ! We 
         fact1 = (cdayozp - intjulian)/deltat			         fact1 = (cdayozp - intjulian)/deltat
         fact2 = (intjulian + daysperyear - cdayozm)/deltat	         fact2 = (intjulian + daysperyear - cdayozm)/deltat
      end if							      end if
   else								   else
      deltat = cdayozp - cdayozm				      deltat = cdayozp - cdayozm
      fact1 = (cdayozp - intjulian)/deltat			      fact1 = (cdayozp - intjulian)/deltat
      fact2 = (intjulian - cdayozm)/deltat			      fact2 = (intjulian - cdayozm)/deltat
   end if							   end if
!								!
! Time interpolation.						! Time interpolation.
!								!
      do j=jts,jte						      do j=jts,jte
      do k=1,levsiz						      do k=1,levsiz
      do i=its,ite						      do i=its,ite
            ozmixt(i,k,j) = ozmixm(i,k,j,nm)*fact1 + ozmixm(i	            ozmixt(i,k,j) = ozmixm(i,k,j,nm)*fact1 + ozmixm(i
      end do							      end do
      end do							      end do
      end do							      end do

END SUBROUTINE ozn_time_int					END SUBROUTINE ozn_time_int

SUBROUTINE ozn_p_int(p ,pin, levsiz, ozmixt, o3vmr, &		SUBROUTINE ozn_p_int(p ,pin, levsiz, ozmixt, o3vmr, &
                              ids , ide , jds , jde , kds , k	                              ids , ide , jds , jde , kds , k
                              ims , ime , jms , jme , kms , k	                              ims , ime , jms , jme , kms , k
                              its , ite , jts , jte , kts , k	                              its , ite , jts , jte , kts , k

!------------------------------------------------------------	!------------------------------------------------------------
!								!
! Purpose: Interpolate ozone from current time-interpolated v	! Purpose: Interpolate ozone from current time-interpolated v
!								!
! Method: Use pressure values to determine interpolation leve	! Method: Use pressure values to determine interpolation leve
!								!
! Author: Bruce Briegleb					! Author: Bruce Briegleb
! WW: Adapted for general use					! WW: Adapted for general use
!								!
!------------------------------------------------------------	!------------------------------------------------------------
   implicit none						   implicit none
!------------------------------------------------------------	!------------------------------------------------------------
!								!
! Arguments							! Arguments
!								!
   INTEGER,    INTENT(IN) ::           ids,ide, jds,jde, kds,	   INTEGER,    INTENT(IN) ::           ids,ide, jds,jde, kds,
                                       ims,ime, jms,jme, kms,	                                       ims,ime, jms,jme, kms,
                                       its,ite, jts,jte, kts,	                                       its,ite, jts,jte, kts,

   integer, intent(in) :: levsiz              ! number of ozo	   integer, intent(in) :: levsiz              ! number of ozo

   real, intent(in) :: p(ims:ime,kms:kme,jms:jme)   ! level p	   real, intent(in) :: p(ims:ime,kms:kme,jms:jme)   ! level p
   real, intent(in) :: pin(levsiz)        ! ozone data level 	   real, intent(in) :: pin(levsiz)        ! ozone data level 
   real, intent(in) :: ozmixt(ims:ime,levsiz,jms:jme) ! ozone	   real, intent(in) :: ozmixt(ims:ime,levsiz,jms:jme) ! ozone

   real, intent(out) :: o3vmr(ims:ime,kms:kme,jms:jme) ! ozon	   real, intent(out) :: o3vmr(ims:ime,kms:kme,jms:jme) ! ozon
!								!
! local storage							! local storage
!								!
   real    pmid(its:ite,kts:kte)				   real    pmid(its:ite,kts:kte)
   integer i,j                 ! longitude index		   integer i,j                 ! longitude index
   integer k, kk, kkstart, kout! level indices			   integer k, kk, kkstart, kout! level indices
   integer kupper(its:ite)     ! Level indices for interpolat	   integer kupper(its:ite)     ! Level indices for interpolat
   integer kount               ! Counter			   integer kount               ! Counter
   integer ncol, pver						   integer ncol, pver

   real    dpu                 ! upper level pressure differe	   real    dpu                 ! upper level pressure differe
   real    dpl                 ! lower level pressure differe	   real    dpl                 ! lower level pressure differe

   ncol = ite - its + 1						   ncol = ite - its + 1
   pver = kte - kts + 1						   pver = kte - kts + 1

   do j=jts,jte							   do j=jts,jte
!								!
! Initialize index array					! Initialize index array
!								!
!  do i=1, ncol							!  do i=1, ncol
   do i=its, ite						   do i=its, ite
      kupper(i) = 1						      kupper(i) = 1
   end do							   end do
!								!
! Reverse the pressure array, and pin is in Pa, the same as m	! Reverse the pressure array, and pin is in Pa, the same as m
!								!
      do k = kts,kte						      do k = kts,kte
         kk = kte - k + kts					         kk = kte - k + kts
      do i = its,ite						      do i = its,ite
         pmid(i,kk) = p(i,k,j)					         pmid(i,kk) = p(i,k,j)
      enddo							      enddo
      enddo							      enddo

   do k=1,pver							   do k=1,pver

      kout = pver - k + 1					      kout = pver - k + 1
!     kout = k							!     kout = k
!								!
! Top level we need to start looking is the top level for the	! Top level we need to start looking is the top level for the
! for all longitude points					! for all longitude points
!								!
      kkstart = levsiz						      kkstart = levsiz
!     do i=1,ncol						!     do i=1,ncol
      do i=its,ite						      do i=its,ite
         kkstart = min0(kkstart,kupper(i))			         kkstart = min0(kkstart,kupper(i))
      end do							      end do
      kount = 0							      kount = 0
!								!
! Store level indices for interpolation				! Store level indices for interpolation
!								!
      do kk=kkstart,levsiz-1					      do kk=kkstart,levsiz-1
!        do i=1,ncol						!        do i=1,ncol
         do i=its,ite						         do i=its,ite
            if (pin(kk).lt.pmid(i,k) .and. pmid(i,k).le.pin(k	            if (pin(kk).lt.pmid(i,k) .and. pmid(i,k).le.pin(k
               kupper(i) = kk					               kupper(i) = kk
               kount = kount + 1				               kount = kount + 1
            end if						            end if
         end do							         end do
!								!
! If all indices for this level have been found, do the inter	! If all indices for this level have been found, do the inter
! go to the next level						! go to the next level
!								!
         if (kount.eq.ncol) then				         if (kount.eq.ncol) then
!           do i=1,ncol						!           do i=1,ncol
            do i=its,ite					            do i=its,ite
               dpu = pmid(i,k) - pin(kupper(i))			               dpu = pmid(i,k) - pin(kupper(i))
               dpl = pin(kupper(i)+1) - pmid(i,k)		               dpl = pin(kupper(i)+1) - pmid(i,k)
               o3vmr(i,kout,j) = (ozmixt(i,kupper(i),j)*dpl +	               o3vmr(i,kout,j) = (ozmixt(i,kupper(i),j)*dpl +
                             ozmixt(i,kupper(i)+1,j)*dpu)/(dp	                             ozmixt(i,kupper(i)+1,j)*dpu)/(dp
            end do						            end do
            goto 35						            goto 35
         end if							         end if
      end do							      end do
!								!
! If we've fallen through the kk=1,levsiz-1 loop, we cannot i	! If we've fallen through the kk=1,levsiz-1 loop, we cannot i
! must extrapolate from the bottom or top ozone data level fo	! must extrapolate from the bottom or top ozone data level fo
! of the longitude points.					! of the longitude points.
!								!
!     do i=1,ncol						!     do i=1,ncol
      do i=its,ite						      do i=its,ite
         if (pmid(i,k) .lt. pin(1)) then			         if (pmid(i,k) .lt. pin(1)) then
            o3vmr(i,kout,j) = ozmixt(i,1,j)*pmid(i,k)/pin(1)	            o3vmr(i,kout,j) = ozmixt(i,1,j)*pmid(i,k)/pin(1)
         else if (pmid(i,k) .gt. pin(levsiz)) then		         else if (pmid(i,k) .gt. pin(levsiz)) then
            o3vmr(i,kout,j) = ozmixt(i,levsiz,j)		            o3vmr(i,kout,j) = ozmixt(i,levsiz,j)
         else							         else
            dpu = pmid(i,k) - pin(kupper(i))			            dpu = pmid(i,k) - pin(kupper(i))
            dpl = pin(kupper(i)+1) - pmid(i,k)			            dpl = pin(kupper(i)+1) - pmid(i,k)
            o3vmr(i,kout,j) = (ozmixt(i,kupper(i),j)*dpl + &	            o3vmr(i,kout,j) = (ozmixt(i,kupper(i),j)*dpl + &
                          ozmixt(i,kupper(i)+1,j)*dpu)/(dpl +	                          ozmixt(i,kupper(i)+1,j)*dpu)/(dpl +
         end if							         end if
      end do							      end do

      if (kount.gt.ncol) then					      if (kount.gt.ncol) then
!        call endrun ('OZN_P_INT: Bad ozone data: non-monoton	!        call endrun ('OZN_P_INT: Bad ozone data: non-monoton
         call wrf_error_fatal ('OZN_P_INT: Bad ozone data: no	         call wrf_error_fatal ('OZN_P_INT: Bad ozone data: no
      end if							      end if
35    continue							35    continue

   end do							   end do
   end do							   end do

   return							   return
END SUBROUTINE ozn_p_int					END SUBROUTINE ozn_p_int

SUBROUTINE aer_time_int(julday,julian,aerodm,aerodt,levsiz,nu	SUBROUTINE aer_time_int(julday,julian,aerodm,aerodt,levsiz,nu
                              ids , ide , jds , jde , kds , k	                              ids , ide , jds , jde , kds , k
                              ims , ime , jms , jme , kms , k	                              ims , ime , jms , jme , kms , k
                              its , ite , jts , jte , kts , k	                              its , ite , jts , jte , kts , k

! adapted from oznint from CAM module				! adapted from oznint from CAM module
!  input: aerodm - read from physics_init			!  input: aerodm - read from physics_init
! output: aerodt - time interpolated				! output: aerodt - time interpolated

!  USE module_ra_cam_support, ONLY : getfactors			!  USE module_ra_cam_support, ONLY : getfactors

   IMPLICIT NONE						   IMPLICIT NONE

   INTEGER,    INTENT(IN) ::           ids,ide, jds,jde, kds,	   INTEGER,    INTENT(IN) ::           ids,ide, jds,jde, kds,
                                       ims,ime, jms,jme, kms,	                                       ims,ime, jms,jme, kms,
                                       its,ite, jts,jte, kts,	                                       its,ite, jts,jte, kts,

   INTEGER,      INTENT(IN   )    ::   levsiz, num_months, no	   INTEGER,      INTENT(IN   )    ::   levsiz, num_months, no

   REAL,  DIMENSION( ims:ime, levsiz, jms:jme, num_months, no	   REAL,  DIMENSION( ims:ime, levsiz, jms:jme, num_months, no
          INTENT(IN   ) ::                                  a	          INTENT(IN   ) ::                                  a

   INTEGER, INTENT(IN )      ::        JULDAY			   INTEGER, INTENT(IN )      ::        JULDAY
   REAL,    INTENT(IN )      ::        JULIAN			   REAL,    INTENT(IN )      ::        JULIAN

   REAL,  DIMENSION( ims:ime, levsiz, jms:jme, no_src ),     	   REAL,  DIMENSION( ims:ime, levsiz, jms:jme, no_src ),     
          INTENT(OUT  ) ::                                  a	          INTENT(OUT  ) ::                                  a

   !Local							   !Local
   REAL      :: intJULIAN					   REAL      :: intJULIAN
   integer   :: np1,np,nm,m,k,i,j,s				   integer   :: np1,np,nm,m,k,i,j,s
   integer   :: IJUL						   integer   :: IJUL
   integer, dimension(12) ::  date_oz				   integer, dimension(12) ::  date_oz
   data date_oz/16, 45, 75, 105, 136, 166, 197, 228, 258, 289	   data date_oz/16, 45, 75, 105, 136, 166, 197, 228, 258, 289
   real, parameter :: daysperyear = 365.  ! number of days in	   real, parameter :: daysperyear = 365.  ! number of days in
   real      :: cdayozp, cdayozm				   real      :: cdayozp, cdayozm
   real      :: fact1, fact2, deltat				   real      :: fact1, fact2, deltat
   logical   :: finddate					   logical   :: finddate
   logical   :: ozncyc						   logical   :: ozncyc
   CHARACTER(LEN=256) :: msgstr					   CHARACTER(LEN=256) :: msgstr

   ozncyc = .true.						   ozncyc = .true.
   ! JULIAN starts from 0.0 at 0Z on 1 Jan.			   ! JULIAN starts from 0.0 at 0Z on 1 Jan.
   intJULIAN = JULIAN + 1.0       ! offset by one day		   intJULIAN = JULIAN + 1.0       ! offset by one day
! jan 1st 00z is julian=1.0 here				! jan 1st 00z is julian=1.0 here
   IJUL=INT(intJULIAN)						   IJUL=INT(intJULIAN)
!  Note that following will drift.				!  Note that following will drift.
!    Need to use actual month/day info to compute julian.	!    Need to use actual month/day info to compute julian.
   intJULIAN=intJULIAN-FLOAT(IJUL)				   intJULIAN=intJULIAN-FLOAT(IJUL)
   IJUL=MOD(IJUL,365)						   IJUL=MOD(IJUL,365)
   IF(IJUL.EQ.0)IJUL=365					   IF(IJUL.EQ.0)IJUL=365
   intJULIAN=intJULIAN+IJUL					   intJULIAN=intJULIAN+IJUL
   np1=1							   np1=1
   finddate=.false.						   finddate=.false.

!  do m=1,num_months						!  do m=1,num_months
   do m=1,12							   do m=1,12
      if(date_oz(m).gt.intjulian.and..not.finddate) then	      if(date_oz(m).gt.intjulian.and..not.finddate) then
        np1=m							        np1=m
        finddate=.true.						        finddate=.true.
      endif							      endif
   enddo							   enddo
   cdayozp=date_oz(np1)						   cdayozp=date_oz(np1)

   if(np1.gt.1) then						   if(np1.gt.1) then
      cdayozm=date_oz(np1-1)					      cdayozm=date_oz(np1-1)
      np=np1							      np=np1
      nm=np-1							      nm=np-1
   else								   else
      cdayozm=date_oz(12)					      cdayozm=date_oz(12)
      np=np1							      np=np1
      nm=12							      nm=12
   endif							   endif

!  call getfactors(ozncyc,np1, cdayozm, cdayozp,intjulian, &	!  call getfactors(ozncyc,np1, cdayozm, cdayozp,intjulian, &
!                   fact1, fact2)				!                   fact1, fact2)
!								!
! Determine time interpolation factors.  Account for December	! Determine time interpolation factors.  Account for December
! interpolation if dataset is being cycled yearly.		! interpolation if dataset is being cycled yearly.
!								!
   if (ozncyc .and. np1 == 1) then                      ! Dec	   if (ozncyc .and. np1 == 1) then                      ! Dec
      deltat = cdayozp + daysperyear - cdayozm			      deltat = cdayozp + daysperyear - cdayozm
      if (intjulian > cdayozp) then                     ! We 	      if (intjulian > cdayozp) then                     ! We 
         fact1 = (cdayozp + daysperyear - intjulian)/deltat	         fact1 = (cdayozp + daysperyear - intjulian)/deltat
         fact2 = (intjulian - cdayozm)/deltat			         fact2 = (intjulian - cdayozm)/deltat
      else                                              ! We 	      else                                              ! We 
         fact1 = (cdayozp - intjulian)/deltat			         fact1 = (cdayozp - intjulian)/deltat
         fact2 = (intjulian + daysperyear - cdayozm)/deltat	         fact2 = (intjulian + daysperyear - cdayozm)/deltat
      end if							      end if
   else								   else
      deltat = cdayozp - cdayozm				      deltat = cdayozp - cdayozm
      fact1 = (cdayozp - intjulian)/deltat			      fact1 = (cdayozp - intjulian)/deltat
      fact2 = (intjulian - cdayozm)/deltat			      fact2 = (intjulian - cdayozm)/deltat
   end if							   end if
!								!
! Time interpolation.						! Time interpolation.
!								!
      do s=1, no_src						      do s=1, no_src
      do j=jts,jte						      do j=jts,jte
      do k=1,levsiz						      do k=1,levsiz
      do i=its,ite						      do i=its,ite
            aerodt(i,k,j,s) = aerodm(i,k,j,nm,s)*fact1 + aero	            aerodt(i,k,j,s) = aerodm(i,k,j,nm,s)*fact1 + aero
      end do							      end do
      end do							      end do
      end do							      end do
      end do							      end do

END SUBROUTINE aer_time_int					END SUBROUTINE aer_time_int

SUBROUTINE aer_p_int(p ,pin, levsiz, aerodt, aerod, no_src, p	SUBROUTINE aer_p_int(p ,pin, levsiz, aerodt, aerod, no_src, p
                     ids , ide , jds , jde , kds , kde ,     	                     ids , ide , jds , jde , kds , kde ,     
                     ims , ime , jms , jme , kms , kme ,     	                     ims , ime , jms , jme , kms , kme ,     
                     its , ite , jts , jte , kts , kte )	                     its , ite , jts , jte , kts , kte )

!------------------------------------------------------------	!------------------------------------------------------------
!								!
! Purpose: Interpolate aerosol from current time-interpolated	! Purpose: Interpolate aerosol from current time-interpolated
!								!
! Method: Use pressure values to determine interpolation leve	! Method: Use pressure values to determine interpolation leve
!								!
! Author: Bruce Briegleb					! Author: Bruce Briegleb
! WW: Adapted for general use					! WW: Adapted for general use
!								!
!   p:  model level pressure at half levels (Pa, bottom-up)	!   p:  model level pressure at half levels (Pa, bottom-up)
!   pf: model level pressure at full levles (Pa, bottom-up)	!   pf: model level pressure at full levles (Pa, bottom-up)
!								!
!------------------------------------------------------------	!------------------------------------------------------------
   implicit none						   implicit none
!------------------------------------------------------------	!------------------------------------------------------------
!								!
! Arguments							! Arguments
!								!
   INTEGER,    INTENT(IN) ::           ids,ide, jds,jde, kds,	   INTEGER,    INTENT(IN) ::           ids,ide, jds,jde, kds,
                                       ims,ime, jms,jme, kms,	                                       ims,ime, jms,jme, kms,
                                       its,ite, jts,jte, kts,	                                       its,ite, jts,jte, kts,

   integer, intent(in) :: levsiz              ! number of aer	   integer, intent(in) :: levsiz              ! number of aer
   integer, intent(in) :: no_src              ! types of aero	   integer, intent(in) :: no_src              ! types of aero

   real, intent(in) :: p(ims:ime,kms:kme,jms:jme)		   real, intent(in) :: p(ims:ime,kms:kme,jms:jme)
   real, intent(in) :: pf(ims:ime,kms:kme,jms:jme)		   real, intent(in) :: pf(ims:ime,kms:kme,jms:jme)
   real, intent(in) :: pin(levsiz)        ! aerosol data leve	   real, intent(in) :: pin(levsiz)        ! aerosol data leve
   real, intent(in) :: aerodt(ims:ime,levsiz,jms:jme,1:no_src	   real, intent(in) :: aerodt(ims:ime,levsiz,jms:jme,1:no_src

   real, intent(out) :: aerod(ims:ime,kms:kme,jms:jme,1:no_sr	   real, intent(out) :: aerod(ims:ime,kms:kme,jms:jme,1:no_sr
   real, intent(out) :: totaod(ims:ime,jms:jme)              	   real, intent(out) :: totaod(ims:ime,jms:jme)              
!								!
! local storage							! local storage
!								!
   real    pmid(its:ite,kts:kte)				   real    pmid(its:ite,kts:kte)
   integer i,j                 ! longitude index		   integer i,j                 ! longitude index
   integer k, kk, kkstart, kout! level indices			   integer k, kk, kkstart, kout! level indices
   integer kupper(its:ite)     ! Level indices for interpolat	   integer kupper(its:ite)     ! Level indices for interpolat
   integer kount               ! Counter			   integer kount               ! Counter
   integer ncol, pver, s					   integer ncol, pver, s

   real    dpu                 ! upper level pressure differe	   real    dpu                 ! upper level pressure differe
   real    dpl                 ! lower level pressure differe	   real    dpl                 ! lower level pressure differe
   real    dpm                 ! pressure difference in a mod	   real    dpm                 ! pressure difference in a mod

   ncol = ite - its + 1						   ncol = ite - its + 1
   pver = kte - kts + 1						   pver = kte - kts + 1

   do s=1,no_src						   do s=1,no_src
   do j=jts,jte							   do j=jts,jte
!								!
! Initialize index array					! Initialize index array
!								!
   do i=its, ite						   do i=its, ite
      kupper(i) = 1						      kupper(i) = 1
   end do							   end do
!								!
! The pressure from incoming data is in hPa and top-down, 	! The pressure from incoming data is in hPa and top-down, 
!     while model pressure is in Pa and bottom-up		!     while model pressure is in Pa and bottom-up
!								!
      do k = kts,kte						      do k = kts,kte
         kk = kte - k + kts					         kk = kte - k + kts
      do i = its,ite						      do i = its,ite
         pmid(i,kk) = p(i,k,j)*0.01				         pmid(i,kk) = p(i,k,j)*0.01
      enddo							      enddo
      enddo							      enddo

   do k=1,pver							   do k=1,pver

      kout = pver - k + 1					      kout = pver - k + 1
!								!
! Top level we need to start looking is the top level for the	! Top level we need to start looking is the top level for the
! for all longitude points					! for all longitude points
!								!
      kkstart = levsiz						      kkstart = levsiz
      do i=its,ite						      do i=its,ite
         kkstart = min0(kkstart,kupper(i))			         kkstart = min0(kkstart,kupper(i))
      end do							      end do
      kount = 0							      kount = 0
!								!
! Store level indices for interpolation				! Store level indices for interpolation
!								!
      do kk=kkstart,levsiz-1					      do kk=kkstart,levsiz-1
         do i=its,ite						         do i=its,ite
            if (pin(kk).lt.pmid(i,k) .and. pmid(i,k).le.pin(k	            if (pin(kk).lt.pmid(i,k) .and. pmid(i,k).le.pin(k
               kupper(i) = kk					               kupper(i) = kk
               kount = kount + 1				               kount = kount + 1
            end if						            end if
         end do							         end do
!								!
! If all indices for this level have been found, do the inter	! If all indices for this level have been found, do the inter
! go to the next level						! go to the next level
!								!
         if (kount.eq.ncol) then				         if (kount.eq.ncol) then
            do i=its,ite					            do i=its,ite
               dpu = pmid(i,k) - pin(kupper(i))			               dpu = pmid(i,k) - pin(kupper(i))
               dpl = pin(kupper(i)+1) - pmid(i,k)		               dpl = pin(kupper(i)+1) - pmid(i,k)
               dpm = pf(i,kout,j) - pf(i,kout+1,j)		               dpm = pf(i,kout,j) - pf(i,kout+1,j)
               aerod(i,kout,j,s) = (aerodt(i,kupper(i),j,s)*d	               aerod(i,kout,j,s) = (aerodt(i,kupper(i),j,s)*d
                             aerodt(i,kupper(i)+1,j,s)*dpu)/(	                             aerodt(i,kupper(i)+1,j,s)*dpu)/(
               aerod(i,kout,j,s) = aerod(i,kout,j,s)*dpm	               aerod(i,kout,j,s) = aerod(i,kout,j,s)*dpm
            end do						            end do
            goto 35						            goto 35
         end if							         end if
      end do							      end do
!								!
! If we've fallen through the kk=1,levsiz-1 loop, we cannot i	! If we've fallen through the kk=1,levsiz-1 loop, we cannot i
! must extrapolate from the bottom or top aerosol data level 	! must extrapolate from the bottom or top aerosol data level 
! of the longitude points.					! of the longitude points.
!								!
      do i=its,ite						      do i=its,ite
         if (pmid(i,k) .lt. pin(1)) then			         if (pmid(i,k) .lt. pin(1)) then
            dpm = pf(i,kout,j) - pf(i,kout+1,j)			            dpm = pf(i,kout,j) - pf(i,kout+1,j)
            aerod(i,kout,j,s) = aerodt(i,1,j,s)*pmid(i,k)/pin	            aerod(i,kout,j,s) = aerodt(i,1,j,s)*pmid(i,k)/pin
            aerod(i,kout,j,s) = aerod(i,kout,j,s)*dpm		            aerod(i,kout,j,s) = aerod(i,kout,j,s)*dpm
         else if (pmid(i,k) .gt. pin(levsiz)) then		         else if (pmid(i,k) .gt. pin(levsiz)) then
            dpm = pf(i,kout,j) - pf(i,kout+1,j)			            dpm = pf(i,kout,j) - pf(i,kout+1,j)
            aerod(i,kout,j,s) = aerodt(i,levsiz,j,s)		            aerod(i,kout,j,s) = aerodt(i,levsiz,j,s)
            aerod(i,kout,j,s) = aerod(i,kout,j,s)*dpm		            aerod(i,kout,j,s) = aerod(i,kout,j,s)*dpm
         else							         else
            dpu = pmid(i,k) - pin(kupper(i))			            dpu = pmid(i,k) - pin(kupper(i))
            dpl = pin(kupper(i)+1) - pmid(i,k)			            dpl = pin(kupper(i)+1) - pmid(i,k)
            dpm = pf(i,kout,j) - pf(i,kout+1,j)			            dpm = pf(i,kout,j) - pf(i,kout+1,j)
            aerod(i,kout,j,s) = (aerodt(i,kupper(i),j,s)*dpl 	            aerod(i,kout,j,s) = (aerodt(i,kupper(i),j,s)*dpl 
                          aerodt(i,kupper(i)+1,j,s)*dpu)/(dpl	                          aerodt(i,kupper(i)+1,j,s)*dpu)/(dpl
            aerod(i,kout,j,s) = aerod(i,kout,j,s)*dpm		            aerod(i,kout,j,s) = aerod(i,kout,j,s)*dpm
         end if							         end if
      end do							      end do

      if (kount.gt.ncol) then					      if (kount.gt.ncol) then
         call wrf_error_fatal ('AER_P_INT: Bad aerosol data: 	         call wrf_error_fatal ('AER_P_INT: Bad aerosol data: 
      end if							      end if
35    continue							35    continue

   end do							   end do
   end do							   end do
   end do							   end do

!  totaod = 0.						      |	   do j=jts,jte
							      >	   do i=its,ite
							      >	      totaod(i,j) = 0.
							      >	   end do
							      >	   end do
							      >
   do s=1,no_src						   do s=1,no_src
   do j=jts,jte							   do j=jts,jte
   do k=1,pver							   do k=1,pver
   do i=its,ite							   do i=its,ite
      totaod(i,j) = totaod(i,j) + aerod(i,k,j,s)		      totaod(i,j) = totaod(i,j) + aerod(i,k,j,s)
   end do							   end do
   end do							   end do
   end do							   end do
   end do							   end do

   return							   return
END SUBROUTINE aer_p_int					END SUBROUTINE aer_p_int

END MODULE module_radiation_driver				END MODULE module_radiation_driver
